<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="yejf"><link rel="icon" href="/avatar.jpg"><title>YeJF的篝火</title><meta name="description" content="Loneliness is not the same as loneliness, loneliness will panic, loneliness is full."><link rel="alternate" type="application/rss+xml" title="YeJF的篝火" href="/atom.xml"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/styles/kimbie-dark.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><script src="https://hm.baidu.com/hm.js?5be0398a8708180d8b755eb54268fe15"> </script><meta name="generator" content="Hexo 5.4.2"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#main-navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">YeJF的篝火</a></div><div class="collapse navbar-collapse" id="main-navbar"><ul class="nav navbar-nav navbar-right"><li><form class="site-search-form"><i class="fa fa-search icon" aria-hidden="true"></i><input class="local-search-input-cls" type="text" id="local-search-input"></form><div class="local-search-result-cls" id="local-search-result"></div></li><li><a href="/archives">Archive</a></li><li><a href="https://donnieYeh.github.io/">Github</a></li><li><a href="/about/">About</a></li><li><a href="/tags/">Tags</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img class="avatar-img" src="/avatar.jpg"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="page-heading"><h1></h1></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article class="blog-post" role="main"><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="不常用模式的记忆索引"><a href="#不常用模式的记忆索引" class="headerlink" title="不常用模式的记忆索引"></a>不常用模式的记忆索引</h2><ul>
<li>桥接模式：接口就是桥，java中无处不桥接（面向接口设计）</li>
<li>访问者模式：操作逻辑放在访问者，数据结构与操作逻辑分离。通过(数据结构).accept(访问者)的方式来操作数据结构。一般跟组合模式结合起来使用。</li>
<li>组合模式：简化树操作。仅操作单一节点，对于子节点进行递归操作。</li>
</ul>
<h1 id="概要设计、详细设计、项目管理-实践"><a href="#概要设计、详细设计、项目管理-实践" class="headerlink" title="概要设计、详细设计、项目管理 实践"></a>概要设计、详细设计、项目管理 实践</h1><h1 id="跳槽面试"><a href="#跳槽面试" class="headerlink" title="跳槽面试"></a>跳槽面试</h1><p>简历项目优化<br>    ddd<br>    rocketmq<br>    es<br>    redis<br>    分库分表</p>
<p>重点：</p>
<ol>
<li>项目介绍不要写流水账，跳近期的重点项目来讲</li>
<li>按star模型来写，situation、task、action、result</li>
</ol>
<h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><p>程序员通常都是面向数据库编程，缺点：代码完全丢弃了业务语义，跟真实业务流程、模型几乎没关系，代码跟业务脱离严重，可维护性差。哪怕是自己写的可能几个月后就看不懂了。数据库思维害死人。</p>
<p>小栗子，初步结论就是代码需要匹配业务语义来封装，按业务语义划分方法模块，不要上来直接暴力crud，直接丢失了业务语义。</p>
<p>专业术语：</p>
<ul>
<li>战略设计：划分界限上下文（事件风暴）、确定子域类型、上下文映射（确定好各个上下文的交互关系）、通用语言制定</li>
<li>界限上下文：目标业务需要解决的问题范围</li>
<li>映射：描述各个界限上下文之间如何交互的</li>
<li>子域类型：每个界限上下文都是一个子域，例如电商这个领域，就能划分为订单子域、仓储子域、履约子域等等，同时每个子域各自有自己的界限上下文，每个子域都有自己的类型：<ul>
<li>核心子域：如对于电商领域而言，完成用户购物这个核心需求，所需具备的一些核心子域</li>
<li>支持子域：用于支持核心子域，如：仓储子域、物流子域 都用于支持 履约子域</li>
<li>通用子域：不用自己公司开发，都是外购软件，或者第三方的通用平台，如第三方支付平台、第三方物流平台</li>
</ul>
</li>
<li>通用语言：限定于当前有界上下文边界范围内，专门描述你的有界上下文里的各种各样的事情，如动作、操作、行为、名词、事务、字段、数据、状态、命令、事件，全部动词和名词要有一套统一的命名规范<ul>
<li>以履约系统收到订单做例子，不同的小组命名为：order、FullFillOrder、OrderFullFill，其实讲的都是同一回事。</li>
</ul>
</li>
</ul>
<p>事件风暴会议五步走（以履约系统为例）</p>
<ul>
<li>召集一个会议，程序员、用户、产品经理、管理者、其他人，开始一块儿进行头脑风暴，一块儿来梳理和说出来，该<strong>履约</strong>相关的所有事件，有多少事件说多少，但凡跟<strong>履约</strong>相关的事件都可以说出来。</li>
<li>把所有梳理出来的<strong>履约</strong>事件，按时间线进行排列</li>
<li>梳理出来<strong>履约</strong>相关的所有用户界面和命令：针对上面的所有事件的发生，是否有系统用户界面，有用户参与进来发送一个指令、命令（在系统界面那里，点击按钮、提交表单、发起操作），驱动了业务的各个事件的执行</li>
<li>把用户界面、命令、事件，按照时间线、先后顺序、交互逻辑，全部串联起来，一环扣一环</li>
<li>在上面的那个大串连的逻辑里，找出<strong>履约</strong>有界上下文，那些事情应该属于<strong>履约</strong>要解决的问题，哪些事情明显是属于别的有界上下文，属于别人要做的事</li>
</ul>
<p>简单的项目，纯粹的增删改查，没有复杂业务的，不要用ddd，反而会加深复杂度。</p>
<p>玩ddd，就是要拽名词，有界上下文（事件风暴），划分子域类型，上下文映射（太拽了），通用语言</p>
<p>映射关系分类：</p>
<ul>
<li>sw：完全没关系</li>
<li>cs：提供者、消费者</li>
<li>ps：发布订阅</li>
<li>ACL：防腐层</li>
<li>conformist：没得商量</li>
<li>partnership：强耦合，一起开发一起上线</li>
<li>ohs+pl：第三方平台接口</li>
<li>share kernel：一起维护模型</li>
</ul>
<p>战术设计，牵扯到类层面的设计，设计你的上下文里有哪些类，这些类如何配合，可以实现你的上下文里要解决的各种各样的问题。</p>
<p>战术设计涉及概念：领域事件、命令、聚合（实体+值对象）、领域服务、业务组件、仓储</p>
<ul>
<li><p>实体：Domain类，如Order（有唯一标识，orderId，里面很多数据是可以变化的），我们的上下文里，对于一些核心数据，一般都会设计成一些类，如果它有唯一标识，且数据允许变化，此时在ddd战术设计里，它被称之为实体，Entity</p>
</li>
<li><p>值对象：ValueObject，如OrderId（建模成一个独立的类），对于一个订单的唯一标识OrderId而言，里面可能包含和封装了订单在数据库里唯一的主键（物理主键）以及我们分配给它的一个订单编号（业务主键），这些东西是绝对不会变化的，而且OrderId自己没必要再有一个唯一标识，什么OrderIdId这样的，它代表的就是一份不会变化的数据，DDD战术设计里称之为值对象</p>
</li>
<li><p>聚合</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;
    <span class="hljs-keyword">private</span> Long orderId;
    <span class="hljs-comment">//有十几个Order自己的字段</span>
    List&lt;OrderItem&gt; orderItems;
    DeliveryAddress deliveryAddress;
    PayType paytype;
    PaymentDetail paymentDetail;
&#125;</code></pre>

<p>在ddd战术设计里，上面那套东西就叫一个聚合，一个聚合代表了多个class绑定在一起，放在一块，而且是可以有多层级的，就是class里还能嵌套其他class（区别于面向数据库开发，Class一般都会跟表字段对齐，里面的属性都是基础类型，Class结构是扁平的）。一个聚合里，聚合根（aggregate root），一组聚合在一起的class，放在最外面的，最上层的，就是一个聚合根，在例子里Order就是聚合根。</p>
<p>怎么要求你把哪些class搞成一个聚合的？聚合是有边界概念的，要求聚合里面的classes的生命周期是一致的，创建的时候一起创建，更新的时候一起更新，删除的时候一起删除，所以一个聚合里的这些东西的更新，需要放在事务里进行，确保一起成功或者一起失败。</p>
</li>
</ul>
<p>充血模型是DDD战术设计的关键、精华所在。贫血模型的问题：所有的业务逻辑都会封装在service里。但这些对ddd还是不够。还需要引入一个概念：领域服务。</p>
<p>领域服务：有些业务行为，是没法放到聚合里的，Order来举例，如果要对多个Order一起进行运算，这种业务逻辑不可能放到Order类里去设计这个语义，此时这种业务行为就会放在另一个类中，这种类叫做领域服务（DomainService）；又或者说，与其他上下文交互，进行一些业务操作，也会放到领域服务中处理。也就类似于贫血模型中的那种编排业务的<strong>xxxService</strong>。</p>
<p>业务组件：包含一些贴合业务语义的业务组件，在业务场景里，此时可能有一个概念，比如<strong>订单状态机</strong>，它不属于聚合、领域服务，它其实是一个<strong>业务组件</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderStateMachine</span></span>&#123;<span class="hljs-comment">// 贴合业务语义的业务组件</span>
    
&#125;</code></pre>



<p>聚合（数据+行为）+领域服务+业务组件 = 战术设计</p>
<p>如果仅仅生硬设计，照葫芦画瓢，把ddd里需要的东西和概念设计出来，做出来，让他们结合起来运行和跑起来，可能看着还觉得挺不错，觉得自己把ddd做出来了。</p>
<p>而石杉老师认为，验证你的DDD做的对不对，成功与否，关键点在于你的代码能够还原出一套完整的业务语义、业务流程、业务模型出来。这套还原出来的代码，有一个验收标准，就是代码的主流程PM结合代码注释也能读的懂，而且认为和他理解的业务流程很接近，才算是DDD成功了。DDD成功的一个关键点在于，你的代码做出来，基本贴合业务语义和流程，抛弃技术细节不说，底层的crud、sql、缓存、mq、es等等，单纯是业务代码主流程，能把业务语义还原出来，DDD就算成功了。</p>
<p>用<strong>命令、查询</strong>和<strong>领域事件</strong>来串起整个业务流程</p>
<p>领域内的业务流程通常由两种情况驱动，分别是<strong>”人为驱动“</strong>和**”事件驱动”<strong>。人为驱动即由人在界面上通过点击等动作触发命令，来驱动业务进行。而像</strong>”订单支付完成“**事件会触发履约流程，这种就是由领域事件来驱动业务流程进行的。命令，command，与Query同为CQRS框架延生出来的，command通常代表人为发出的更新、新增操作命令，query代表查询操作。</p>
<p> 仓储，基于具体的技术实现聚合数据的持久化和读取，类似但不等于DAO</p>
<p>可以这样类比于传统mvc模型：</p>
<p>命令、领域事件——Controller的request</p>
<p>聚合、实体、值对象——Model</p>
<p>领域服务、业务组件——Service</p>
<p>仓储——Dao</p>
<p><strong>DDD的三个层次划分</strong></p>
<p>分别为：接口层、应用服务层、domain层</p>
<p>接口层，最外层跟用户界面、其他上下文进行交互的一层，属于表现层，是DDD里最外面一层对接用户的，对接用户界面发送的一些命令，command或query</p>
<p>如果我们的有界上下文，是对其他有界上下文提供映射和交互的，提供一个内部调用接口，一般来说内部接口命名为XXXApi，通过spring cloud netflix（openfeign）或者说spring cloud alibaba（dubbo）rpc框架，对外去提供一套API接口，供其他上下文进行调用和交互</p>
<p>或者说别的有界上下文会发布一个领域事件，发布到MQ，RocketMq、RabbitMq、Kafka这样子，我们就需要去进行领域事件监听，这个负责领域事件监听的监听器，listener，rocketMq、kafka、rabbitmq里面的consumer，也算是对外的接口层，不是给别人调用的，是基于MQ的事件消费的接口</p>
<p>当我们的接口层收到了Controller的http请求，xxxApi收到了rpc请求，Listener接收到了MQ消费事件，此时每个请求（command、query），rpc调用，event时间，都对应了去执行某个业务流程、业务链路</p>
<p>这个业务流程或者业务链路，一般都对应了很多步骤，每个步骤可能是通过仓储对聚合做了一些查询或更新，也有可能是基于聚合的业务行为做了个动作，也可能是找领域服务执行了一个比较复杂的业务逻辑，可能是不同动作串联起来，完成了一个比较复杂的业务流程，或者说是链路</p>
<p>接口层收到了东西（http请求、rpc调用请求、event事件），做一些转化（防腐层，把外部传进来的东西，转化为内部的一些东西，ACL防腐层，比如说把 http request转化为一个内部的command或query，rpc调用请求也同理，需要把请求-响应模型，转化为内部的command、query），然后传给应用服务层（Application Service layer）</p>
<p>应用服务层，类似于传统的Service层，用于进行业务流程编排，它来基于仓储、聚合、领域服务，执行各种各样的动作，把这个业务流程、链路里的各个环节和动作都完成。</p>
<p>domain层，聚合、领域服务、业务组件、仓储</p>
<p>当了解了以上概念，各种模型，以及它们归属的层次，就可以开始战术设计的落地：业务建模。业务建模的核心，领域里的所有流程和模型都是与业务相匹配的，不包含任何技术内容，所有技术细节都隐藏在聚合、领域服务、业务组件、仓储这些模型底下了。理应做到产品、客户甚至普通人只看业务建模，就能还原出对业务的正确理解</p>
<p>基于ddd思想，代码落地时有以下几种分层架构可以参考：清洁架构、六边形架构、CQRS</p>
<p>清洁架构太严格，不灵活，通常项目的ddd分层可以借鉴六边形架构+CQRS的思想 结合起来使用</p>
<p>interface层：接口层，controller、api、listener来组成，直接跟外界交互</p>
<p>application service：应用服务层，主要是业务流程编排</p>
<p>domain：aggregate、entity、value object、domain service、 domain event、command、query、business component，属于核心领域层， 把业务模型、业务流程、业务语义，完全用代码还原出来，让代码跟业务吻合，而不是完全从技术角度、数据库角度去设计写出来的代码</p>
<p>infrastructure：基础设施层，repository，主要负责跟具体的基础设施进行交互，跟数据库、MQ、缓存、ES、NoSql 以及其他外部的基础设施一类的系统进行交互，偏向于技术流的地方主要就是这块</p>
<p> DDD框架：COLA 4.0</p>
<p>面试<br>bad case </p>
<ol>
<li>不要流水账</li>
<li>主动聊难点挑战，要直接亮剑</li>
<li>不要答非所问</li>
<li>理论知识要体系复习到位，不要回避</li>
<li>不要上来讲细节，要学会梳理和总结，对各个技术方案都要起一个简短的总结性的名称</li>
</ol>
<p>未来规划：</p>
<ol>
<li>一方面英语很重要，会重点去深造英语，以达到能快速查阅一手博客甚至原版论文、书籍的能力，甚至在英语上面花钱都觉得是值的。</li>
<li>会去重点深造c语言方面，因为这能提供阅读JVM源码、linux源码的能力，我喜欢知其然并知其所以然，跟马斯克说的第一性原理是一个道理。</li>
<li>会重点去培养管理者思维，因为自己光有能力不够，如何洞察上层决策、上层意识，如何通过自己的经验、知识来整合一线员工的力量，以有限的能力创造最大的价值，这种思维更加重要，不然缺乏团队作战能力，做事事倍功半那个人再牛逼也是没有意义的，这种能力可能会通过报培训班或者读书这些途径来达到</li>
</ol>
<p>整理star案例<br>整理下鉴权微服务的重点功能，原理是什么，解决什么问题<br>整理下核心中间件的技术选型：mq、缓存、nosql、注册中心<br>什么叫中台</p>
<p>响应式编程</p>
</article></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a target="_blank" rel="noopener" href="https://github.com/donnieYeh" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a href="mailto:xr08255920@gmail.com" title="Email me"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-envelope"></i></span></a></li></ul><p class="copyright text-muted"><span>© 2022</span><span class="meta-devider">•</span><span class="with-love"><i class="fa fa-user"></i></span><span>yejf</span></p><p class="site_counter"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span class="meta-devider">|</span><span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>次</span><span class="theme-by text-muted">Theme base on
    <a target="_blank" rel="noopener" href="https://github.com/twoyao/beautiful-hexo">beautiful-hexo</a></span></p></div></div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script><script src="/js/main.js"></script><!-- 代码高亮--><!-- 导航栏搜索框--><script src="/js/search.js"></script><script type="text/javascript" id="local.search.active">var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><!-- 切换标签彩蛋--><script src="/js/crash_cheat.js"> </script><!--看板娘--><script src="/live2d-widget/autoload.js"> </script></body></html>