<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeJF的篝火</title>
  
  <subtitle>回血、存档、再出发</subtitle>
  <link href="http://xr08255920.github.io/atom.xml" rel="self"/>
  
  <link href="http://xr08255920.github.io/"/>
  <updated>2022-01-30T11:26:49.707Z</updated>
  <id>http://xr08255920.github.io/</id>
  
  <author>
    <name>yejf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字证书与安全协议</title>
    <link href="http://xr08255920.github.io/2022/01/22/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
    <id>http://xr08255920.github.io/2022/01/22/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-01-22T17:07:00.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="什么是是数字证书"><a href="#什么是是数字证书" class="headerlink" title="什么是是数字证书"></a>什么是是数字证书</h3><h4 id="数字身份"><a href="#数字身份" class="headerlink" title="数字身份"></a>数字身份</h4><p>数字身份的本质是一对秘钥，分别为公钥和私钥。</p><p>把数字身份比喻成一个证件，那么数字证书就是“身份认证机构”盖在证件上的一个章（即权威机构的背书）。没有背书的数字身份是没实际意义的。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="生活中"><a href="#生活中" class="headerlink" title="生活中"></a>生活中</h4><p>一切进行数据通信的地方都有可能会用到数字证书，如</p><ul><li>电子邮件</li><li>浏览网页</li><li>手机APP</li><li>科学上网</li></ul><h4 id="开发中"><a href="#开发中" class="headerlink" title="开发中"></a>开发中</h4><ul><li>工具抓包：fiddler</li></ul><h3 id="为什么要有数字证书"><a href="#为什么要有数字证书" class="headerlink" title="为什么要有数字证书"></a>为什么要有数字证书</h3><h4 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h4><p>下面展示了网络安全通信是如何逐步衍生出数字证书的。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B1.gif"></p><p>第一阶段，双方协商好对称密钥，之后的通信都使用对称密钥对明文进行加密解密操作。但是这个阶段的缺点是双方需要提前约定好密钥，该模式无法满足临时与陌生对象通信的需求。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B2.gif"><br>第二阶段，双方使用非对称秘钥通信，其中bob有一对公私钥，通信初始他会把公钥提供给alice，alice使用该公钥来加密明文。由于密文只有bob的私钥能解密，所以在通信过程中其他人是无法解开密文的（未被篡改的情况下）。<br>该阶段的主要问题在于非对称加密明文的性能相较对称加密性能要差很多。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B3.gif"><br>第三阶段，alice使用了临时生成的<strong>对称密钥</strong>来加密明文，然后再用bob的公钥加密<strong>对称密钥</strong>，然后把<strong>被加密的明文</strong>和<strong>被加密的密钥</strong>发送给bob，由于<strong>被加密的密钥</strong>只能用bob的私钥解密，所以过程是安全的（未被篡改的情况下），同时<strong>对称密钥</strong>加密明文保证了性能。但这个过程真的没缺陷了吗？我们看看以下场景：<br><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B3-%E7%BC%BA%E9%99%B7.gif"><br>该过程中，中间人可以拦截bob发给alice的公钥，同时发送自己的公钥给alice，伪装成bob。之后的通信过程中，alice使用伪装的公钥加密出的密文，自然能被中间人破解。更有甚者中间人可以伪造一份欺骗性的报文发给bob。该过程省略了alice用自己私钥加签的过程，本质上一样是不安全的，中间人既然能伪造bob给alice的公钥，当然也能伪造alice给bob的公钥，那么这个过程中的签名自然也是可以伪造的。<br><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B4.gif"><br>上一阶段的核心问题在于bob的公钥在传输过程中被篡改了，对于alice来说bob的公钥是不可信的。那么解决了公钥的信任问题，这个过程就安全了。</p><p>第四阶段：这一阶段bob把自己的公钥封装到数字证书里。在之后的通信初始阶段bob会先把数字证书发给alice，alice去CA机构验证数字证书的合法性，若验证通过，则代表bob的数字证书是可信的，那么证书里面的公钥自然也是可信的。这样就顺利的解决了公钥的信任问题。</p><h3 id="为什么数字证书的认证过程是可信的"><a href="#为什么数字证书的认证过程是可信的" class="headerlink" title="为什么数字证书的认证过程是可信的"></a>为什么数字证书的认证过程是可信的</h3><p><img src="/images/%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E5%8F%AF%E4%BF%A1.gif"><br>在服务域名上线之前，会先用自己的公钥生成一份证书签名请求文件（certificate sign request，csr），可以理解为填了份带有公钥的申请表单，发给CA机构，然后CA机构会把这份表单里面的关键信息（包括公钥、服务域名、所属机构等）提取成摘要，用自己的私钥进行加签。然后把签名和关键信息，输出到正式的数据结构中，形成了数字证书，再把这个数字证书发送给服务方，这个过程就叫做证书的签发。</p><p>服务器得到了具有公证力的证书，上线新的域名。随后客户端就可以访问该域名对服务器发起握手，握手阶段服务器会把证书发给客户端，客户端在证书里找到它的签发机构，遂去获取签发机构的证书。此时我们注意服务器证书的签名是用CA机构的私钥加签的，理所当然可以用CA机构的公钥进行验签。如果验签成功，则说明了服务器的证书是可信的。</p><p>可是此时出现了新的问题，我们通过这个流程可以验证服务器证书的有效性，前提是CA机构的证书也是合法的，但如何保证CA证书不会被篡改呢？</p><p>同理我们的客户端可以走相同的流程，去获取CA机构的上级机构的证书，来验证CA证书的有效性，这样就形成了一个递归验证链。这个递归链是有边界的，它的边界就是<strong>根证书。</strong></p><p><img src="/images/Pasted%20image%2020220123125102.png"></p><p>由上图的信任链我们可以看出验证操作会一直递归到根证书。这里的关键就在于根证书是内置于我们操作系统本地的，那么在获取根证书的时候就不想要经过网络。若不经过网络，则就不存在被中间人攻击的风险。所以，到根证书为止，就可以证明整个信任链是可信的了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>加密技术的存在是为了保障通信信息不被第三方窃取，保证信息的安全性，该技术甚至可以追溯到3900年前的古希腊。但是随着互联网尤其是无线网络的发展，出现了一种新的场景，就是通信双方节点，通常都是需要临时交换密钥来进行安全通信。伴随着这种场景，新的攻击手段也应运而生，那就是中间人攻击，简单来说就是中间人可以伪装成你的通信对象，交换非法秘钥，以达到监听窃取、篡改信息的目的。</p><p>而<strong>数字证书</strong>就是为了解决<strong>信任危机</strong>而的产生。<br>目前大部分数字证书都采用 x509第三版数据结构<br>数字证书是实现<strong>安全协议</strong>过程的基石。</p><h2 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h2><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><h4 id="TLS属于哪层协议？"><a href="#TLS属于哪层协议？" class="headerlink" title="TLS属于哪层协议？"></a>TLS属于哪层协议？</h4><p>TLS所处的协议层如下：<br>数据帧{ IP层{ TCP层{ <strong>TLS层{</strong> 应用层{} <strong>}</strong> } } }</p><p>可见TLS介于传输层（TCP）和应用层之间。</p><p>如果把网络协议想象成一个纸团，协议之间的嵌套就像一张纸包住另一个纸团一样。最里面的一层就是应用层协议，如HTTP。而网络报文的传输过程中，任何人能够截获这个纸团，并层层剥开，但是如果没有相应的秘钥，是没法剥开TLS这一层的，也就没法看到里面的HTTP报文。<br><img src="/images/Pasted%20image%2020220123093321.png"></p><h4 id="SSL和TLS的关系"><a href="#SSL和TLS的关系" class="headerlink" title="SSL和TLS的关系"></a>SSL和TLS的关系</h4><p>SSL是网景制定的，TLS是IETF指定的。TLS1.0建立在SSL3.0基础之上，可以理解为SSL3.1。由于习惯原因，现在很多对安全层依旧沿用SSL的称呼，但实际上已经使用的是TLS的技术了。</p><p>网景是一家传说级的公司，Mozilla（火狐前身）和JavaScript都诞生于这家公司。<br>而IETF是一个开放的标准组织，网络上随处可见的RFC标准就是出自他们。</p><p><img src="/images/Pasted%20image%2020220123093824.png"></p><h4 id="TLS-的运作过程"><a href="#TLS-的运作过程" class="headerlink" title="TLS 的运作过程"></a>TLS 的运作过程</h4><p><img src="/images/Pasted%20image%2020220123121739.png"></p><h4 id="TLS的关键阶段"><a href="#TLS的关键阶段" class="headerlink" title="TLS的关键阶段"></a>TLS的关键阶段</h4><p>握手阶段是TLS的关键<br>握手过程，主要就是双方交换公共参数，生成对称密钥，用于加密通信<br>秘钥交换算法（key exchange）：</p><ul><li>RSA based key exchange</li><li>DH(Diffie-Hellman) based key exchange</li></ul><h4 id="交换秘钥过程"><a href="#交换秘钥过程" class="headerlink" title="交换秘钥过程"></a>交换秘钥过程</h4><p>HTTPS常用的密钥交换算法有两种，分别是<code>RSA</code>和<code>ECDHE</code><br>由于RSA不具备向前安全性质，现在大部分服务器不会使用它来交换秘钥<br>每个通信过程的秘钥没有关系，相互独立，才能保证 <strong>「前向安全」</strong>。<br><code>DH</code>作为<code>ECDHE</code>的基础，详细介绍参考[DH]一节<br><code>ECDHE</code>的演进路线基本是这样的：<code>DH</code>-&gt; <code>DHE</code>-&gt;<code>ECDHE</code>，</p><h4 id="向前安全性"><a href="#向前安全性" class="headerlink" title="向前安全性"></a>向前安全性</h4><p><strong>前向安全性</strong>或<strong>前向</strong>保密<strong>性</strong>（英语：Forward Secrecy，缩写：FS），有时也被称为完美<strong>前向安全</strong>（英语：Perfect Forward Secrecy，缩写：PFS），<strong>是</strong>密码学中通讯协议的<strong>安全</strong>属性，指的<strong>是</strong>长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p><h4 id="演进过程-1"><a href="#演进过程-1" class="headerlink" title="演进过程"></a>演进过程</h4><p>以下过程基于网络交换秘钥场景</p><table><thead><tr><th>技术</th><th>性能</th><th>防监听（未篡改）</th><th>防篡改</th><th>向前安全</th></tr></thead><tbody><tr><td>对称加密{原文}</td><td>√</td><td>x</td><td>x</td><td>x</td></tr><tr><td>非对称加密{原文}</td><td>x</td><td>√</td><td>x</td><td>x</td></tr><tr><td>非对称{密钥}</td><td>√</td><td>√</td><td>x</td><td>x</td></tr><tr><td>非对称{密钥}+公钥背书</td><td>√</td><td>√</td><td>√</td><td>x</td></tr><tr><td>非对称{临时DH公钥}+公钥背书</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="两种密钥交换模式"><a href="#两种密钥交换模式" class="headerlink" title="两种密钥交换模式"></a>两种密钥交换模式</h3><h4 id="RSA-Base"><a href="#RSA-Base" class="headerlink" title="RSA Base"></a>RSA Base</h4><p>流程<br>从浏览器请求HTTPS，到渲染数据的整个过程</p><ul><li>Client Hello</li><li>随机数、算法套件</li><li>Server Hello</li><li>随机数、选定算法、公钥</li><li>Certificate</li><li>验证身份的项目：</li><li>涉及证书链的有效期</li><li>涉及证书链的签名</li></ul><p> 举例子，证书验证不通过的情况<br> <img src="/images/Pasted%20image%2020220123121951.png"></p><ul><li>Server Hello Done</li><li>Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message</li><li>服务端 Change Cipher Spec, Encrypted Handshake Message</li><li>加密通信</li></ul><p>premaster key、masterKey的作用<br><img src="/images/Pasted%20image%2020220123122022.png"></p><h4 id="DH-Base"><a href="#DH-Base" class="headerlink" title="DH Base"></a>DH Base</h4><h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>DH算法的原理可以参考这一篇文章：<a href="https://bbs.huaweicloud.com/blogs/detail/273779">为了搞懂 HTTPS，我把大学的数学书拿了出来。。。)</a></p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>要注意dh算法本身并不能防范中间人攻击，中间人可以通过分别对双方进行DH密钥交换进行攻击，所以DH实际需要配合身份认证机制才能安全工作。DH两种工作方式：</p><ol><li>Fixed Diffie-Hellman：直接把DH公钥固化到服务方证书里，和RSA一样不具备向前安全性</li><li>Ephemeral Diffie-Hellman (简称为DHE)：服务方使用动态DH公钥，只是会对公钥进行签名</li></ol><p>在DH模式中，数字证书，不是用于生成通信用的秘钥，而是单纯用于双方认证身份（这个是大部分人很容易理解错的地方）</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>相关配置</p><ul><li>internet属性<br>如何查看一个网站使用的TLS版本：f12-&gt;security<br><img src="/images/Pasted%20image%2020220123122235.png"></li></ul><h4 id="证书的生命周期管理"><a href="#证书的生命周期管理" class="headerlink" title="证书的生命周期管理"></a>证书的生命周期管理</h4><p>流行的证书生命周期管理工具有两种，一个是jdk自带的keytool；一个是开源项目openSSL</p><table><thead><tr><th>生命周期</th><th>keytool相关命令</th><th>openssl相关命令</th></tr></thead><tbody><tr><td>创建密钥对</td><td>-genkeypair</td><td>genrsa</td></tr><tr><td>创建签名请求</td><td>-certreq</td><td>req</td></tr><tr><td>签发证书</td><td>-gencert</td><td>x509</td></tr><tr><td>秘钥库管理</td><td>-importcert、-list</td><td>pkcs12</td></tr><tr><td>使用证书</td><td></td><td></td></tr><tr><td>销毁证书</td><td></td><td></td></tr></tbody></table><h4 id="验证der编码和base64编码的区别"><a href="#验证der编码和base64编码的区别" class="headerlink" title="验证der编码和base64编码的区别"></a>验证der编码和base64编码的区别</h4><p>der编码           base64编码<br>直接导出证书  导出证书 -rfc<br>windows下可以点击证书复制到文件<br>相互转换：notepad++转base64</p><h4 id="Nginx引入、使用证书"><a href="#Nginx引入、使用证书" class="headerlink" title="Nginx引入、使用证书"></a>Nginx引入、使用证书</h4><p>Nginx发布https服务，需要准备两个文件：一个是pem，证书文件，代表了服务公钥；一个是key，密钥文件，代表了服务私钥；</p><p>pem可以直接使用base64编码的证书文件；<br>key则需要用openssl命令来从秘钥库导出；<br><code>openssl pkcs12 -nodes -nocerts -in -out</code></p><h4 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h4><ul><li>什么时候会进行数字证书认证</li><li>keytool -gencert -sigalg 有什么用</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="如何理解证书链"><a href="#如何理解证书链" class="headerlink" title="如何理解证书链"></a>如何理解证书链</h4><h4 id="RSA-vs-DSA"><a href="#RSA-vs-DSA" class="headerlink" title="RSA vs DSA"></a>RSA vs DSA</h4><p>这两个算法都是对称密钥算法，其中</p><ul><li>名称问题<br>RSA三位发明者的名字的缩写<br>DSA则是 Digital Signature Algorithm 的缩写</li><li>数学基础</li><li>RSA基于大数分解（两个素数的乘积）</li><li>DSA基于离散对数难题</li></ul><h4 id="数字证书的数据结构"><a href="#数字证书的数据结构" class="headerlink" title="数字证书的数据结构"></a>数字证书的数据结构</h4><p>CN(Common Name名字与姓氏)<br>OU(Organization Unit组织单位名称)<br>O(Organization组织名称)<br>L(Locality城市或区域名称)<br>ST(State州或省份名称)<br>C(Country国家名称）</p><p><img src="/images/Pasted%20image%2020220123125851.png"><br>详细参考： <a href="https://www.cem.me/20150209-cert-binaries-4.html">https://www.cem.me/20150209-cert-binaries-4.html</a></p><h4 id="秘钥、与ssh打通"><a href="#秘钥、与ssh打通" class="headerlink" title="秘钥、与ssh打通"></a>秘钥、与ssh打通</h4><h4 id="域名及CName-AAA、AAAA"><a href="#域名及CName-AAA、AAAA" class="headerlink" title="域名及CName AAA、AAAA"></a>域名及CName AAA、AAAA</h4><h4 id="PGP和GPG加签模式的区别"><a href="#PGP和GPG加签模式的区别" class="headerlink" title="PGP和GPG加签模式的区别"></a>PGP和GPG加签模式的区别</h4><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><blockquote><p>[序号]主要责任者.电子文献题名[电子文献及载体类型标识].电子文献的出版或获得地址,发表更新日期/引用日期.</p></blockquote><blockquote><p>例如：[12]王明亮.关于中国学术期刊标准化数据库系统工程的进展[EB/OL].1998-08-16/1998-10-01.</p></blockquote><blockquote><p>[8]万锦.中国大学学报文摘(1983-1993).英文版[DB/CD].北京:<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6%E5%87%BA%E7%89%88%E7%A4%BE/2267934">中国大百科全书出版社</a>,1996.</p></blockquote><ul><li><p>[1]梁栋.java加密与解密的艺术（第二版）</p></li><li><p>[2]2018-2019年中国网络可信身份服务发展蓝皮书</p></li><li><p>[3]贾铁军.网络安全技术与应用（第三版）</p></li><li><p>[4]王绍斌.云计算安全事件：从入门到精通</p></li><li><p>[5]韩立刚.深入浅出计算机网络</p></li><li><p>[6]汪德嘉.身份危机</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD">数字身份 - 维基百科，自由的百科全书 (wikipedia.org)</a></p></li><li><p><a href="http://kapsterio.github.io/test/2021/09/17/TLS.html">TLS协议分析（密码学101以及TLS协议简介） · kaspterio (kapsterio.github.io)</a></p></li><li><p><a href="https://houbb.github.io/2018/09/26/SSL-TLS">SSL/TSL | Echo Blog (houbb.github.io)</a></p></li><li><p><a href="https://www.linuxidc.com/Linux/2015-07/120230.htm">Https SSL/TLS PreMaster/Master Secret(Key)计算_服务器应用_Linux公社-Linux系统门户网站 (linuxidc.com)</a></p></li><li><p><a href="https://dev.to/wayofthepie/structure-of-an-SSL-x-509-certificate-16b">dev.to</a></p></li><li><p><a href="https://bbs.huaweicloud.com/blogs/detail/273779">为了搞懂 HTTPS，我把大学的数学书拿了出来。。。-云社区-华为云 (huaweicloud.com)</a></p></li><li><p><a href="https://www.cnblogs.com/bonelee/p/12931388.html">DSA与RSA——DSA 只能用于数字签名，而无法用于加密（某些扩展可以支持加密）；RSA 即可作为数字签名，也可以作为加密算法。在业界支持方面，RSA 具有更为广泛的部署与支持。 - bonelee - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://www.cnblogs.com/leslies2/p/7442956.html">数字证书应用综合揭秘（包括证书生成、加密、解密、签名、验签） - 风尘浪子 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://juejin.cn/post/6930446060846481416">https://juejin.cn/post/6930446060846481416</a></p></li><li><p><a href="http://3ms.huawei.com/km/blogs/details/10441927?comment=17411983">手撕非对称密码原理（一） - 欧锻灏的博客 (huawei.com)</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数字证书&quot;&gt;&lt;a href=&quot;#数字证书&quot; class=&quot;headerlink&quot; title=&quot;数字证书&quot;&gt;&lt;/a&gt;数字证书&lt;/h2&gt;&lt;h3 id=&quot;什么是是数字证书&quot;&gt;&lt;a href=&quot;#什么是是数字证书&quot; class=&quot;headerlink&quot; title=&quot;什</summary>
      
    
    
    
    <category term="密码学" scheme="http://xr08255920.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="数字证书" scheme="http://xr08255920.github.io/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
    <category term="密码学" scheme="http://xr08255920.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ZeroTier 梳理</title>
    <link href="http://xr08255920.github.io/2022/01/04/ZeroTier%E6%A2%B3%E7%90%86/"/>
    <id>http://xr08255920.github.io/2022/01/04/ZeroTier%E6%A2%B3%E7%90%86/</id>
    <published>2022-01-04T02:54:00.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>是一款 p2p vpn</p><p>p2p 的原理是什么</p><ol><li>中继（原始方案）：两个客户端主动连接公网服务器，由服务器中继通信</li><li>逆向链接（改良版）：要求其中一个客户端（假设是B）是公网ip，且有公网服务器做中继，B先通过服务器向A中继一个连接请求，然后A主动跟B建立连接。</li><li>UDP打洞（当前最优）：两个客户端都在NAT之后，有一台公网服务器，客户端A向B发送请求，同时要求服务器中继一个“B到A的连接请求”给B，此时两边都会导致NAT打开一个自身内网到对方外网的通信，之后双方内网就可以相互通信了。该模式适用于锥形NAT。如果有多级NAT，则要求NAT得支持回环传输(loopback transmission)。<br><a href="https://zhuanlan.zhihu.com/p/26796476">https://zhuanlan.zhihu.com/p/26796476</a><br><a href="https://evilpan.com/2015/10/31/p2p-over-middle-box/">https://evilpan.com/2015/10/31/p2p-over-middle-box/</a><br>vpn 是什么<br>vpn全称visual private network，最早是公司开发给员工远程连接内网用的，此处体现了第一个用处就是代理网络请求，其次它目的是防止公司信息泄漏给第三方，所以vpn被设计成能够加密通信。所以它具备以下特点：1、提高上网安全性；2、隐藏上网者身份；3、突破网站的地域限制</li></ol><p>NAT是什么<br>NAT即网络地址转换器，NAT不止检查进入数据包的头部,而且对其进行修改,从而实现同一内网中不同主机共用更少的公网IP（通常是一个）.</p><p>隧道是什么</p><p>STUN是什么</p><p>STUN和TUN的区别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;是一款 p2p vpn&lt;/p&gt;
&lt;p&gt;p2p 的原理是什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中继（原始方案）：两个客户端主动连接公网服务器，由服务器中继通信&lt;/li&gt;
&lt;li&gt;逆向链接（改良版）：要求其中一个客户端（假设是B）是公网ip，且有公网服务器做中继，B先通过服务器向A中</summary>
      
    
    
    
    
    <category term="vpn" scheme="http://xr08255920.github.io/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>mysql，GROUP_CONCAT，341长度疑案</title>
    <link href="http://xr08255920.github.io/2021/12/15/mysql%EF%BC%8CGROUP_CONCAT%EF%BC%8C341%E9%95%BF%E5%BA%A6%E7%96%91%E6%A1%88/"/>
    <id>http://xr08255920.github.io/2021/12/15/mysql%EF%BC%8CGROUP_CONCAT%EF%BC%8C341%E9%95%BF%E5%BA%A6%E7%96%91%E6%A1%88/</id>
    <published>2021-12-15T23:33:00.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天被同事找来讨论一个数据库问题，一个select语句带有聚合函数<code>GROUP_CONCAT(countryCode)</code>，countryCode是纯数字，所以这一列出来的结果应该是这样的：<code>24,25,1003,1004,1025,......</code>，但是实际上结果被截断了，把结果copy出来到notepad++，发现每一条记录的长度都是<code>341</code>。</p><p>经过一番查询，发现mysql对这个函数有个配置：<code>group_concat_max_len</code>，指的是对<code>GROUP_CONCAT()</code>函数的结果进行截断。比如<code>group_concat_max_len=1024</code>，那么mysql会对该函数的结果截取前1024个字节(Byte)。看起来就是它了。</p><p>通过以下命令，可以查看该库对应的配置：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;group_concat_max_len&#x27;</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1024</span></code></pre><p>可见我们的库也是1024，那为啥实际结果长度只有<code>341</code>呢。据回答的小哥说：当<code>GROUP_CONCAT()</code> 和 <code>Order By</code>一起使用的时候，结果就会进一步裁剪到1/3，如果去掉<code>Order By</code>条件，结果长度会是<code>1024</code>。但是这个规律是实践出来的，具体为啥会这样，官方手册里并没有说。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了验证思路，可参考以下sql进行配置</p><pre><code class="hljs sql"># SESSION 表示变动只影响当前会话<span class="hljs-keyword">SET</span> SESSION group_concat_max_len<span class="hljs-operator">=</span><span class="hljs-number">102400</span>;</code></pre><p>配置后验证结果长度确实不会被截断了。</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>由于我们只在某一个环境中才复现了这个问题，别的环境都没问题，所以思路就是参考别的环境的配置，经查询发现其他环境的值都是<code>group_concat_max_len=8192</code>，所以其他环境没有这个问题，遂对齐配置即可。</p><pre><code class="hljs sql"># <span class="hljs-keyword">GLOBAL</span> 表示变动影响全局<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> group_concat_max_len<span class="hljs-operator">=</span>your_value_here;</code></pre><p>如果严谨一点，应该需要排查项目里所有用到<code>GROUP_CONCAT()</code>的地方，然后结合业务评估一下合理的大小，再找DBA协商进行变更。所幸我们生产环境配的是<code>102400</code>，足够大了，也就没这种顾虑了。</p><hr><p>参考:</p><ul><li><a href="https://stackoverflow.com/questions/12001919/mysql-truncates-concatenated-result-of-a-group-concat-function">https://stackoverflow.com/questions/12001919/mysql-truncates-concatenated-result-of-a-group-concat-function</a></li><li><a href="https://stackoverflow.com/questions/4469474/mysql-truncating-of-result-when-using-group-concat-and-concat/37979180#37979180">https://stackoverflow.com/questions/4469474/mysql-truncating-of-result-when-using-group-concat-and-concat/37979180#37979180</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;今天被同事找来讨论一个数据库问题，一个select语句带有聚合函数&lt;code&gt;GROUP_CONCAT(countryCode)&lt;/code</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://xr08255920.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>阅读文章自动生成大纲浏览器插件</title>
    <link href="http://xr08255920.github.io/2021/12/12/%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A4%A7%E7%BA%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://xr08255920.github.io/2021/12/12/%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A4%A7%E7%BA%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2021-12-12T11:06:00.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间读文章发现没有大纲，阅读不顺畅，针对那些没有大纲的页面，手撸了一个自动生成大纲的浏览器脚本。基本上实现了大部分想要的功能，在此记录分享。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>可以导入油猴里，打开脚本开关即可生效。</li><li>使用浏览器的dev-tools来跑。</li></ol><p><i class="fa fa-file-code-o" aria-hidden="true"></i><a href="/data/outlineTool.user.js">文章大纲生成插件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有段时间读文章发现没有大纲，阅读不顺畅，针对那些没有大纲的页面，手撸了一个自动生成大纲的浏览器脚本。基本上实现了大部分想要的功能，在此记录分享。&lt;/p&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://xr08255920.github.io/tags/javascript/"/>
    
    <category term="效率工具" scheme="http://xr08255920.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="原创" scheme="http://xr08255920.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>js模块化简述</title>
    <link href="http://xr08255920.github.io/2021/12/09/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E8%BF%B0/"/>
    <id>http://xr08255920.github.io/2021/12/09/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E8%BF%B0/</id>
    <published>2021-12-09T02:05:00.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>本文是阅读《mastering-modular-javascript》的心得笔记，该书成书于2018年，对当前JS技术的描述有较新的时效性。同时其模块化思想比较实用，可以应用到任何语言</p><h2 id="历史简述"><a href="#历史简述" class="headerlink" title="历史简述"></a>历史简述</h2><h3 id="scriptTag和闭包"><a href="#scriptTag和闭包" class="headerlink" title="scriptTag和闭包"></a>scriptTag和闭包</h3><p>原生js提供使用<code>&lt;script&gt;</code>tag的方式引入，这样一个页面会看到一大坨的第三方库以<code>&lt;script&gt;</code>的方式引入。但是这种引入天生是有缺陷的，引入的函数和变量都会挂载到window下成为全局对象。这样导致一个长期存在的毛病就是各个包之间定义的变量会相互覆盖，稍有差池就会让页面渲染失败。</p><p>之后官方推出了IIFE的特性（也就是闭包），各个库的代码以闭包的方式包裹，这样它们各自定义的变量的作用域都是在闭包范围之内的，也就解决了全部暴露到全局的问题。</p><p>但是这种方式弊病在于它不会显式的声明依赖的库，这样就需要手动精细调整各个<code>&lt;script&gt;</code>的顺序，以达到被依赖的库优先被引入的问题，</p><p>闭包的几种写法：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE using parenthesis&#x27;</span>)&#125;)()~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE using a bitwise operator&#x27;</span>)&#125;()<span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE using the void operator&#x27;</span>)&#125;()</code></pre><blockquote><p>&lt;mastering-modular-javascript&gt; chapter1</p></blockquote><h3 id="RequireJs，AngularJs，和依赖注入"><a href="#RequireJs，AngularJs，和依赖注入" class="headerlink" title="RequireJs，AngularJs，和依赖注入"></a>RequireJs，AngularJs，和依赖注入</h3><p>上节描述的问题一直都是让前端开发人员头疼的问题，直到模块化框架RequireJs以及AngularJS中依赖注入机制的降临。</p><h4 id="RequireJs"><a href="#RequireJs" class="headerlink" title="RequireJs"></a>RequireJs</h4><p>通过如下方式暴露接口，define()是RequireJs框架暴露到全局的函数<br>第一个参数的数组元素声明了该模块的路径，第二个参数意思是通过把函数传入回调接口，返回该路径对应的接口</p><pre><code class="hljs javascript">define([<span class="hljs-string">&#x27;mathlib/sum&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sum</span>) </span>&#123;  <span class="hljs-keyword">return</span> &#123; sum &#125;&#125;)</code></pre><p>通过如下方式调用依赖项，require()跟define()一样，<br>第一个参数声明了需要引入的依赖路径，可以引入多个依赖<br>这些依赖会按顺序放到第二个回调函数的参数中，提供使用。</p><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;mathlib&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mathlib</span>) </span>&#123;  mathlib.sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment">// &lt;- 6</span>&#125;)</code></pre><p>requireJS也有它的问题，首先整个模式围绕着它的异步请求能力，这导致了每个引用点都要发起网络请求获取对应的模块，这会导致一个页面发起瀑布式的上百个加载模块的网络请求，这无疑是性能很差的一件事。为此，需要引入一个构建工具，把所有模块整合成一个脚本，包含冗长的依赖链、require函数、和回调参数</p><h4 id="AngularJS"><a href="#AngularJS" class="headerlink" title="AngularJS"></a>AngularJS</h4><p>AngularJS中的依赖注入系统也遇到了许多相同的问题。它通过解析参数名来解决依赖问题。但是这导致了进行代码混淆时，参数名被改变而依赖失败的问题。在AngularJS v1后期，引入了一个构建任务来解决这个问题，它会进行如下的代码转换：</p><pre><code class="hljs javascript"><span class="hljs-comment">//转换前</span><span class="hljs-built_in">module</span>.factory(<span class="hljs-string">&#x27;calculator&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mathlib【&lt;-通过该参数名来引入依赖】</span>) </span>&#123;  <span class="hljs-comment">// …</span>&#125;)</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//转换后</span><span class="hljs-built_in">module</span>.factory(<span class="hljs-string">&#x27;calculator&#x27;</span>, [<span class="hljs-string">&#x27;mathlib&#x27;</span>【&lt;-显式的指明了依赖的模块名称，像RequireJs一样】, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mathlib</span>) </span>&#123;  <span class="hljs-comment">// …</span>&#125;])</code></pre><blockquote><p>不用说，引入这个鲜为人知的构建工具的延迟，加上过度设计的方面，有一个额外的构建步骤来解开不应该被破坏的东西，我无论如何都不鼓励使用一种能带来如此微不足道的好处的模式。开发人员大多选择坚持使用熟悉的类似RequireJS的硬编码依赖数组格式。——&lt;mastering-modular-javascript&gt;</p></blockquote><h3 id="Node-js和CommonJS的降临和Browserify"><a href="#Node-js和CommonJS的降临和Browserify" class="headerlink" title="Node.js和CommonJS的降临和Browserify"></a>Node.js和CommonJS的降临和Browserify</h3><p>在Node.js被称赞的众多创新中，一个是CommonJS模块系统——简称CJS。利用Node.js程序可以访问文件系统的能力，CommonJS标准更符合传统的模块加载机制。在CommonJS中，每个文件都是一个具有自己作用域和上下文的模块。依赖关系是使用同步<code>require</code>函数加载的，该函数可以在模块生命周期中的任何时候动态调用，如下一个代码段所示。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mathlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./mathlib&#x27;</span>)</code></pre><p>可见，与RequireJs、AngularJS一样，都是使用路径来指定模块，而不同之处在于曾经的样板函数、依赖数组已经不复存在。像前两者，它们可以在一个文件里定义多个模块的接口，但是CJS相对比较严格，它约定一个模块就是一个文件，通过<code>module.exports</code>就能暴露该模块的接口。其实这样的好处也显而易见，这样可以让开发者更加清晰的了解CJS模块的层次结构，也便于IDE去解析。</p><p>由于CJS是提供给NodeJs用的，浏览器引擎并没有能力去引入依赖，这个时候就要靠<code>Browserify</code>，来把所有的依赖打包到供浏览器使用的捆绑包中。</p><h3 id="ES6-import-Babel-and-Webpack"><a href="#ES6-import-Babel-and-Webpack" class="headerlink" title="ES6, import, Babel, and Webpack"></a>ES6, <code>import</code>, Babel, and Webpack</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>ECMA标准组织一直都在持续的采纳和计划新的语法标准。很多时候一些很实用的语法已经提上议程，但是待各大浏览器对标准进行实现，开发者还是得苦苦的等待一段漫长的事间。Babel的出现就是为了解决这个问题，它是一个语法转换工具，能够把ES6语法的代码，转换成当前浏览器都能兼容的ES5语法，解决了很多开发想要尝试新的语法特性的燃眉之急</p><p>随着ES6在2015年6月标准化，以及Babel在那之前很久就一直有将ES6转换为ES5，一场新的革命正在迅速临近。ES6规范包括JavaScript原生的模块语法，通常被称为ECMAScript模块（ESM）。</p><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><p>ESM在很大程度上受到CJS及其前身的影响，提供了静态声明性API以及基于承诺的动态可编程API，如下所示。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> mathlib <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mathlib&#x27;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./mathlib&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">mathlib</span> =&gt;</span> &#123;  <span class="hljs-comment">// …</span>&#125;)</code></pre><p>同CJS一样，ESM约定一个文件就是一个模块。而优秀于CJS的地方是ESM能引用静态依赖，静态依赖意味着可以无需运行代码就能被工具检测出相关的依赖，我猜应该是能够便于编辑工具进行依赖解析吧，对书本原文说的“内省”不是很理解。（参考：<a href="https://stackoverflow.com/questions/52965907/what-is-the-meaning-of-static-import-in-es6">javascript - what is the meaning of static import in ES6? - Stack Overflow</a>）。</p><blockquote><p>Static imports vastly improve the introspection capabilities of module systems, given they can be analyzed statically and lexically extracted from the abstract syntax tree (AST) of each module in the system.    ——&lt;mastering-modular-javascript&gt;</p></blockquote><p>另外ESM比CJS更强的一个地方在于它可以指定加载模块的异步完成事件（<code>.then()</code>）。这让模块加载的动作变得更加灵活和更多可能性。</p><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>Webpack是browserify的接班人。</p><hr><p>综上所述，由于ESM纯正血统以及优异表现，毫无疑问ESM将在未来的几年内，将会接管整个JS模块化生态。</p><p>参考文献：<a href="https://github.com/mjavascript/mastering-modular-javascript">GitHub - mjavascript/mastering-modular-javascript: 📦 Module thinking, principles, design patterns and best practices.</a></p><h2 id="模块化原则"><a href="#模块化原则" class="headerlink" title="模块化原则"></a>模块化原则</h2><h3 id="模块化精要"><a href="#模块化精要" class="headerlink" title="模块化精要"></a>模块化精要</h3><ol><li>单一职责原则</li><li>API优先原则</li><li>不暴露非必要的方法或变量（public 要有度，能private的尽量private）<ol><li>从使用者角度去考虑暴露的粒度</li></ol></li><li>找到合适的抽象（最好就是在第二次出现重复的时候进行重构）</li><li>状态管理<ol><li>模块化设计的一个目标就是让状态最小化，不要让功能内部存在太多可能性</li><li>把状态树砍成更好管理的状态树分支，每个分支都是状态树的一个子集</li><li>纯粹的函数不应该对其它地方有影响，下面是例子 <pre><code class="hljs javascript"><span class="hljs-comment">// 纯粹函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">numbers</span>) </span>&#123;<span class="hljs-keyword">return</span> numbers.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>)&#125;<span class="hljs-comment">// 非纯粹函数，每次调用的结果可能被其他调用影响</span><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><span class="hljs-keyword">const</span> increment = <span class="hljs-function">() =&gt;</span> count++<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> increment</code></pre></li><li>可以通过工厂来封装可能暴露给外部的状态，来减少状态的熵值 <pre><code class="hljs javascript"><span class="hljs-keyword">const</span> factory = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> increment = <span class="hljs-function">() =&gt;</span> count++  <span class="hljs-keyword">return</span> increment&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> factory</code></pre></li></ol></li></ol><h3 id="CRUST-Consistent-Resilient-Unambiguous-Simple-and-Tiny"><a href="#CRUST-Consistent-Resilient-Unambiguous-Simple-and-Tiny" class="headerlink" title="CRUST: Consistent, Resilient, Unambiguous, Simple and Tiny"></a>CRUST: Consistent, Resilient, Unambiguous, Simple and Tiny</h3><ol><li>Consistent：一个接口只要输入一样，无论执行多少次，输出都应该一样</li><li>Resilient：接口应能够灵活的指定参数，包括可选参数和重载</li><li>Unambiguous：接口应该是明确的，不存在多种用法、多套不同业务意义的入参、多套不同解释的返回值</li><li>Simple：接口应该保持简单，它可以以少配置甚至无配置，执行常规的用例，同时也能允许用户通过传递自定义配置执行更高级的用例</li><li>Tiny：它应该是精简的，保持高扩展性</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是阅读《mastering-modular-javascript》的心得笔记，该书成书于2018年，对当前JS技术的描述有较新的时效性。同时其模块化思想比较实用，可以应用到任何语言&lt;/p&gt;
&lt;h2 id=&quot;历史简述&quot;&gt;&lt;a href=&quot;#历史简述&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="js系列" scheme="http://xr08255920.github.io/categories/js%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="javascript" scheme="http://xr08255920.github.io/tags/javascript/"/>
    
    <category term="modular" scheme="http://xr08255920.github.io/tags/modular/"/>
    
    <category term="模块化" scheme="http://xr08255920.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>DDD——驱动领域设计</title>
    <link href="http://xr08255920.github.io/2021/11/26/DDD%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xr08255920.github.io/2021/11/26/DDD%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="如何应对复杂软件开发？以unix为例"><a href="#如何应对复杂软件开发？以unix为例" class="headerlink" title="如何应对复杂软件开发？以unix为例"></a>如何应对复杂软件开发？以unix为例</h3><ol><li>封装与抽象</li><li>分层与模块化</li><li>基于接口通信</li><li>为扩展而设计</li></ol><blockquote><p>linux运作漫画图）理论太干，辅以图片说明，同时让听众思考buffer</p></blockquote><h3 id="DDD介绍"><a href="#DDD介绍" class="headerlink" title="DDD介绍"></a>DDD介绍</h3><ul><li>历史</li><li>简介<ul><li>   一种思维模式</li><li>   本质是方法论</li><li>   by experience</li></ul></li></ul><h4 id="由数据模型驱动设计-引入"><a href="#由数据模型驱动设计-引入" class="headerlink" title="由数据模型驱动设计 引入"></a>由数据模型驱动设计 引入</h4><p>一门语言的基本语法和编程技巧、一个ORM框架的使用方法及基本的sql编写能力——就这三板斧，足以！</p><p>这种设计方式的弊端：mvc模式</p><ul><li>缺乏边界</li><li>贫血模型，transactional scripts</li><li>由贫血症导致的失忆症（即业务代码意图不明</li><li>跟数据库表定义强耦合</li><li>缺乏对领域模型的思考和建模</li></ul><h3 id="正式引入DDD"><a href="#正式引入DDD" class="headerlink" title="正式引入DDD"></a>正式引入DDD</h3><h4 id="怎么玩？"><a href="#怎么玩？" class="headerlink" title="怎么玩？"></a>怎么玩？</h4><ol><li>团队+领域专家讨论，统一语言</li><li>战略设计：划分界限上下文</li><li>战术设计：界限上下文落地</li><li>根据实际情况迭代、重构界限上下文，往复循环</li></ol><h4 id="对比数据模型驱动模式"><a href="#对比数据模型驱动模式" class="headerlink" title="对比数据模型驱动模式"></a>对比数据模型驱动模式</h4><p>虚拟钱包案例</p><p><strong>mvc模型</strong></p><ul><li>贫血模型，不够面向对象</li><li>业务类命名太泛，缺乏边界，职责模糊，后续很容易被腐化</li><li>数据库表模型散落到业务层，灵活性差</li></ul><p><strong>ddd建模</strong></p><ul><li>充血模型，更加面向对象</li><li>使用门面模式，屏蔽数据库操作细节</li><li>service层变逻辑变简单，领域逻辑交给领域层做，service层只负责编排</li></ul><h4 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h4><ul><li>ddd非银弹，不应滥用</li><li>设计系统时，多考虑墨菲定律</li><li>划分系统时，多考虑康威定律</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>数据驱动设计有诸多弊端</li><li>DDD天生为控制大型软件的复杂度而生</li></ul><h3 id="领域建模流程"><a href="#领域建模流程" class="headerlink" title="领域建模流程"></a>领域建模流程</h3><ol><li>事件风暴。一起头脑风暴，完善用例图</li><li>抽象。提炼出系统的主要行为</li><li>划分界限上下文。主要区分好核心域、支撑域、公共域</li><li>界限上下文映射。主要区分好各个上下文的上下游关系</li><li>翻译为代码。一个上下文一个module</li></ol><h3 id="DDD的基本概念"><a href="#DDD的基本概念" class="headerlink" title="DDD的基本概念"></a>DDD的基本概念</h3><ul><li>领域、子域</li><li>界限上下文、界限上下文映射</li><li>实体、值对象</li><li>聚合、聚合根</li><li>领域服务</li><li>领域事件</li><li>工厂</li><li>资源库</li></ul><h4 id="领域、子域"><a href="#领域、子域" class="headerlink" title="领域、子域"></a>领域、子域</h4><p>在领域部不断划分的过程中，领域会细分成不同的子域：核心域、通用域、支撑域</p><p>核心域如何区分？桃树例子。<strong>界限上下文关心的就是核心域</strong></p><h4 id="界限上下文"><a href="#界限上下文" class="headerlink" title="界限上下文"></a>界限上下文</h4><p>什么是界限上下文？<br>例子：我有 kuai di<br>①我有块地，<strong>祖上留下来的</strong><br>②我有快递，<strong>顺丰的</strong></p><p>帮助我们理解对话含义的语气和语境就是<strong>上下文</strong></p><p>例子：</p><ol><li>引用 Eric Evans 对界限上下文的解释（细胞-上下文，细胞膜-边界</li><li>我—&gt;业务流程：乘客 | 宾客 | 支付者 | 咨询师</li></ol><p>领域是问题域（即问题空间），界限上下文是问题的解决空间<br>界限上下文是直译术语，晦涩难懂，理解成本高。应该叫<strong>上下文边界</strong></p><h4 id="上下文映射（Context-Map）"><a href="#上下文映射（Context-Map）" class="headerlink" title="上下文映射（Context Map）"></a>上下文映射（Context Map）</h4><p>应该译为<strong>上下文图</strong>，是描述各个<strong>上下文之间的关系</strong>的总体视图。分别是：</p><ul><li>合作关系</li><li>共享内核（如：多个服务共享jar包，或者公共基础服务</li><li>客户/供应商（如：服务间相互约定模型，由供应方维护</li><li>追随者（如：调用支付宝接口，无法约定，只能按照他们协议走</li><li>防腐层（如：上游系统模型太烂，下游可以用防腐层来将其转换成理想模型，<strong>目的是将上游系统的影响降到最低</strong></li><li>公开主机服务（如：对外发布公共服务及接口文档</li><li>发布语言</li><li>各行其道</li><li>大泥球（ 毫无设计可言</li></ul><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>有唯一标识（可理解为其id），实现了领域行为（充血模型），对象的延续性和标识会跨越甚至超出软件的生命周期。</p><p>一个典型的实体应具备三要素：</p><ul><li>身份标识</li><li>属性</li><li>领域行为</li></ul><h4 id="值对象（-值-对象）"><a href="#值对象（-值-对象）" class="headerlink" title="值对象（= 值 + 对象）"></a>值对象（= 值 + 对象）</h4><p>是否拥有<strong>唯一标识</strong>，是实体和值对象的<strong>根本区别</strong>。<br>值对象特征：</p><ul><li>不可变，只读，安全</li><li>将不同的相关属性组合成了一个概念整体</li><li>可以和其他值对象进行相等性比较</li><li>行为不会对属性产生副作用</li></ul><h4 id="实体和值对象的区别"><a href="#实体和值对象的区别" class="headerlink" title="实体和值对象的区别"></a>实体和值对象的区别</h4><p>在实践中，实体和值对象是一起使用的，值对象作为实体的附属属性。如：领域模型中的人员是实体    （有唯一身份标识），而地址对象被人员实体引用。</p><p>值对象可以在不同的场景中被不同的实体引用。如在电商系统中，地址对象作为收货地址；在员工系统中，地址对象作为家庭地址。</p><p>此外，在某些场景中，地址会占据领域的主导地位，如行政区划中的地址信息维护，这时应该设计为实体。</p><table><thead><tr><th>实体</th><th>值对象</th></tr></thead><tbody><tr><td>具有生命周期</td><td>起描述作用</td></tr><tr><td>有唯一标识</td><td>无</td></tr><tr><td>通过id判断相等性</td><td>实现equals方法</td></tr><tr><td>增删改查/持久化</td><td>即时创建用完就扔</td></tr><tr><td>可变</td><td>不可变</td></tr><tr><td>如 Order/Car</td><td>Address/Color</td></tr></tbody></table><h4 id="聚合、聚合根"><a href="#聚合、聚合根" class="headerlink" title="聚合、聚合根"></a>聚合、聚合根</h4><p>在DDD中，实体、值对象是基础的领域对象，表现出的是个体的能力。<br>而让实体、值对象协同工作的组织，就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性</p><p>聚合定义了一组具有<strong>内聚关系</strong>的相关对象的<strong>集合</strong>。可以把聚合看做是一个修改数据的单元。</p><p>如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么需要思考聚合内哪个对象有独立存在的意义，并且可以和外部直接进行交互，以其为聚合根</p><p>聚合根是与其他聚合交互的唯一接口。</p><p>聚合设计原则：</p><ul><li>设计小聚合，79%的聚合通常只有一个实体，即聚合根</li><li>聚合之间通过Id关联，而不是对象引用</li><li>一个事务只能创建或更新一个聚合。这是理想情况，遵循最终一致性。大多数情况我们需要的是事务一致性。</li></ul><p>可打破原则的理由：</p><ul><li>方便用户界面</li><li>缺乏技术支持</li><li>全局事务</li><li>查询性能</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;h3 id=&quot;如何应对复杂软件开发？以unix为例&quot;&gt;&lt;a href=&quot;#如何应对复杂软件开发？以unix为例&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Graphviz实践手册</title>
    <link href="http://xr08255920.github.io/2021/11/26/Graphviz%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/"/>
    <id>http://xr08255920.github.io/2021/11/26/Graphviz%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dot语言"><a href="#dot语言" class="headerlink" title="dot语言"></a>dot语言</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code class="hljs clojure">[ strict ] (<span class="hljs-name">graph</span> | digraph) [ ID ] &#123;rankdir =  //布局方向，只有一个生效 <span class="hljs-string">&quot;TB&quot;</span>, <span class="hljs-string">&quot;LR&quot;</span>, <span class="hljs-string">&quot;BT&quot;</span>, <span class="hljs-string">&quot;RL&quot;</span>// 设置公共属性(<span class="hljs-name">graph</span> | node | edge) [ID = ID, ID2 = ID2, ...]<span class="hljs-comment">;</span>...// 声明节点NODEID [ port ] [ID = ID, ID2 = ID2, ...]<span class="hljs-comment">;</span>...// 节点链(<span class="hljs-name">NODEID</span> [ port ] | subgraph) edgeop (<span class="hljs-name">node_id</span> | subgraph) [ID = ID, ID2 = ID2, ...]<span class="hljs-comment">;</span>...&#125;</code></pre><h2 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h2><p><code>dot -Tpng *.dot -o *.png</code></p><h2 id="画Label格子技巧"><a href="#画Label格子技巧" class="headerlink" title="画Label格子技巧"></a>画Label格子技巧</h2><ol><li>先整理1级分类，如A|B|C</li><li>整理某分类的二级分类，如B的二级分类：{B1|B2|B3}</li><li>把二级分类挂到一级分类下边，得：A|{B|{B1|B2|B3}|C</li><li>以此类推</li><li>得到的结果方label里，如<code>nodeName [label=&quot;A|&#123;B|&#123;B1|B2|B3&#125;|C&quot;]</code></li></ol><h2 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h2><p><img src="/images/Pasted%20image%2020201218173054.png"></p><h2 id="子图边框样式"><a href="#子图边框样式" class="headerlink" title="子图边框样式"></a>子图边框样式</h2><pre><code class="hljs abnf">subgraph&#123;style = dotted<span class="hljs-comment">;</span>&#125;</code></pre><p>可选样式：<br><img src="/images/Pasted%20image%2020201222153845.png"></p><h2 id="允许子图边界可以被指定"><a href="#允许子图边界可以被指定" class="headerlink" title="允许子图边界可以被指定"></a>允许子图边界可以被指定</h2><pre><code class="hljs actionscript">digraph &#123;<span class="hljs-comment">//设置该选项开启</span>compound=<span class="hljs-literal">true</span> &#125;</code></pre><p>指定子图边界：</p><pre><code class="hljs routeros">CacheUtil -&gt; Ehcache [<span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;findCache()&quot;</span>,ltail = cluster_CatcherManager]</code></pre><h2 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h2><p>指定 <code>edge [fontname=&quot;MicroSoft YaHei&quot;]</code></p><h2 id="subgraphs-和-clusters-的区别"><a href="#subgraphs-和-clusters-的区别" class="headerlink" title="subgraphs 和 clusters 的区别"></a>subgraphs 和 clusters 的区别</h2><p>subgraph有以下几个作用：</p><ul><li>负责抽象多个节点的公共属性</li><li>给组件分组（单纯是语义上的分组，不可见）</li></ul><p>cluster继承subgraph的特性，并额外提供可视化的边界，cluster的定义方法就是给子图的名字加前缀<code>cluster_</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dot语言&quot;&gt;&lt;a href=&quot;#dot语言&quot; class=&quot;headerlink&quot; title=&quot;dot语言&quot;&gt;&lt;/a&gt;dot语言&lt;/h1&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring data</title>
    <link href="http://xr08255920.github.io/2021/11/26/Spring%20data/"/>
    <id>http://xr08255920.github.io/2021/11/26/Spring%20data/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>Spring repository（Spring data common） 负责定义应用和数据库服务之间的抽象API接口。<br>Spring repository 从对接的数据库类型上看有多种实现，关系型数据库、nosql、内存数据库、云数据库等等。</p><p>Spring repository 对关系型数据库的实现，最主流的有 Spring Data JPA，底层使用Hibernate 这种ORM框架，此外原生一点的实现有 Spring Data JDBC。</p><p>不同的实现，需要接入不同的数据源，不同的数据源由统一的公共API操作。各数据源需要单独配置，配置相应的连接参数，如使用jdbc-Mysql作为数据源，则要为DataSource配置相应的连接串、账号、密码等等。</p><p>小结<br>Spring repository  –&gt; Spring Data JPA/JDBC/MongoDB…. –&gt; mysql/oracle/h2/… </p><h2 id="Spring-JPA"><a href="#Spring-JPA" class="headerlink" title="Spring JPA"></a>Spring JPA</h2><h3 id="引入步骤"><a href="#引入步骤" class="headerlink" title="引入步骤"></a>引入步骤</h3><p>要使用Spring Data，有一下步骤</p><ol><li>pom 引入 spring-boot-starter-data-jpa<ol><li><blockquote><p>自动依赖 spring Data common</p></blockquote></li></ol></li><li>pom 引入DataSource需要的引擎，如Driven等</li><li>自行在 Configuration 中配置 DataSource</li><li>编写model的interface，继承对应的repository，如JPA实现则继承JPArepository。Spring Data 将会自动的扫描所有 Repository，并通过动态代理来实现它。</li><li>在Configuration 中设置 @EnableJpaRepositories 使Spring Data生效</li></ol><p>####设置</p><pre><code class="hljs java"><span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;com.baeldung.spring.data.persistence.repository&quot;)</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersistenceConfig</span> </span>&#123;     ...&#125;</code></pre><h3 id="自定义DB操作"><a href="#自定义DB操作" class="headerlink" title="自定义DB操作"></a>自定义DB操作</h3><p>Spring Data 默认已经对Repository 生成好基本的db操作了。但难免有时还是无法满足需求，此时需要自定义DB操作，有如下方式可选：</p><ol><li>命名规则自定义查询</li><li>手动sql自定义查询</li></ol><h4 id="命名规则自定义查询"><a href="#命名规则自定义查询" class="headerlink" title="命名规则自定义查询"></a>命名规则自定义查询</h4><p>在 Repository 接口中定义新方法，如果Entity中有name字段，不妨可以在Repository 接口中新增 findBy<strong>Name</strong>方法，这样Spring Data会自动生成对应的实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFooDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Foo</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;    <span class="hljs-function">Foo <span class="hljs-title">findByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre><p>更多自动化关键字可以查阅：<a href="https://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/#jpa.query-methods.query-creation">https://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/#jpa.query-methods.query-creation</a> </p><h4 id="手动sql自定义查询"><a href="#手动sql自定义查询" class="headerlink" title="手动sql自定义查询"></a>手动sql自定义查询</h4><p>示例</p><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;SELECT f FROM Foo f WHERE LOWER(f.name) = LOWER(:name)&quot;)</span><span class="hljs-function">Foo <span class="hljs-title">retrieveByName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</code></pre><h2 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a>未分类</h2><h3 id="Modifying"><a href="#Modifying" class="headerlink" title="@Modifying"></a>@Modifying</h3><p>可在@Query上使用@Modifying注释，此时@Query可以执行查询以外的sql，如增、删、改。</p><h3 id="Modifying-和-命名方法-操作的区别"><a href="#Modifying-和-命名方法-操作的区别" class="headerlink" title="@Modifying 和 命名方法 操作的区别"></a>@Modifying 和 命名方法 操作的区别</h3><p>后者会先把DB的数据全查出来，然后逐个做操作，这样可以通过AOP对每条数据设置前置操作。而前者会直接把操作语句扔到DB执行。</p><h3 id="Modifying-与持久化容器的过期数据"><a href="#Modifying-与持久化容器的过期数据" class="headerlink" title="@Modifying 与持久化容器的过期数据"></a>@Modifying 与持久化容器的过期数据</h3><p>通过 @Modifying 执行的操作，不会同步给持久化容器，此时持久化容器的数据处于过期状态。一个方法是通过手动清空持久化容器。但也可以通过以下方式让其自动清空。</p><pre><code class="hljs java"><span class="hljs-meta">@Modifying(clearAutomatically = true)</span></code></pre><p>但如果清空持久化容器，则会导致未flush的数据也被清除，导致未保存的更改被丢弃。可以通过以下属性来在清空前flush。</p><pre><code class="hljs java"><span class="hljs-meta">@Modifying(flushAutomatically = true)</span></code></pre><h3 id="Query"><a href="#Query" class="headerlink" title="@Query"></a>@Query</h3><p>@Query的优先度优先于按方法名查询。</p><p>@Query 优先使用JPQL语法，如果要使用原生SQL语法，需要指定native=ture。</p><pre><code class="hljs java"><span class="hljs-comment">//JPQL语法</span><span class="hljs-meta">@Query(&quot;SELECT u FROM User u WHERE u.status = 1&quot;)</span><span class="hljs-function">Collection&lt;User&gt; <span class="hljs-title">findAllActiveUsers</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//原生SQL</span><span class="hljs-meta">@Query(</span><span class="hljs-meta">  value = &quot;SELECT * FROM USERS u WHERE u.status = 1&quot;, </span><span class="hljs-meta">  nativeQuery = true)</span><span class="hljs-function">Collection&lt;User&gt; <span class="hljs-title">findAllActiveUsersNative</span><span class="hljs-params">()</span></span>;</code></pre><h3 id="连接持久层"><a href="#连接持久层" class="headerlink" title="连接持久层"></a>连接持久层</h3><p>至少需要：</p><ol><li>datasource，涉及和维护driver、username、password</li><li>SqlSessionFactory，用来连接服务器，创建sqlSession</li><li>mapper，定义相关的Query（在JPA中，一个方法就是一个mapper）</li></ol><p>图示：<br><img src="/images/Pasted%20image%2020201222154530.png"></p><h4 id="JPA需要准备环境"><a href="#JPA需要准备环境" class="headerlink" title="JPA需要准备环境"></a>JPA需要准备环境</h4><p>对于JPA，是一回事。</p><ol><li>DataSource</li><li>EntityManager —— 相当于SqlSessionFactory</li><li>Entity Repository —— 相当于Mapper</li></ol><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><p>需要注册Bean org.mybatis.spring.mapper.MapperScannerConfigurer 或者 注解 @MapperScanner，来生效mybatis。该bean负责整合上述的组件到DAO的代理类中，开发者就可以通过dao接口来操作db了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring repository（Spring data common） 负责定义应用和数据库服务之间的抽象API接口。&lt;br&gt;Spring repository 从对接的数据库类型上看有多种实现，关系型数据库、nosql、内存数据库、云数据库等等。&lt;/p&gt;
&lt;p&gt;Spr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>aop实践手册</title>
    <link href="http://xr08255920.github.io/2021/11/26/aop%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/"/>
    <id>http://xr08255920.github.io/2021/11/26/aop%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="aspect语法"><a href="#aspect语法" class="headerlink" title="aspect语法"></a>aspect语法</h3><h4 id="call和execution的区别"><a href="#call和execution的区别" class="headerlink" title="call和execution的区别"></a>call和execution的区别</h4><p>结合这篇<a href="https://stackoverflow.com/questions/28251596/difference-between-call-and-execution-pointcuts-in-php/28252742#28252742">java - Difference between call and execution pointcuts in PHP? - Stack Overflow</a>食用<br><img src="/images/Pasted%20image%2020210820103450.png"></p><p>重点：But wait a minute, it still makes a difference: <code>execution</code> is just woven in one place while <code>call</code> it woven into potentially many places, so the amount of code generated is smaller for <code>execution</code>.</p><p>搞清楚 @target、@withIn 的区别<br>参考<a href="https://blog.csdn.net/jinnianshilongnian/article/details/84156354?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">»Spring 之AOP AspectJ切入点语法详解（最全了，不需要再去其他地找了）_jinnianshilongnian的专栏-CSDN博客</a></p><h4 id="语法表"><a href="#语法表" class="headerlink" title="语法表"></a>语法表</h4><p>execution(annotation scope return package.Class.method( params ) )</p><ul><li>可省略：annotation、scope</li><li>任意 return、包、方法：*</li><li>任意参数：（..）</li><li>任意多个包：..</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;aspect语法&quot;&gt;&lt;a href=&quot;#aspect语法&quot; class=&quot;headerlink&quot; title=&quot;aspect语法&quot;&gt;&lt;/a&gt;aspect语法&lt;/h3&gt;&lt;h4 id=&quot;call和execution的区别&quot;&gt;&lt;a href=&quot;#call和executi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cdn</title>
    <link href="http://xr08255920.github.io/2021/11/26/cdn/"/>
    <id>http://xr08255920.github.io/2021/11/26/cdn/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得cdn是反向代理的延伸，反向代理初期被用来解决服务器压力和响应速度的问题，大规模部署反向代理时，如果都部署在一起，那么带宽和距离仍然是瓶颈，而异地部署则要考虑负载均衡的问题，解决了这些问题也就基本部署成CDN了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我觉得cdn是反向代理的延伸，反向代理初期被用来解决服务器压力和响应速度的问题，大规模部署反向代理时，如果都部署在一起，那么带宽和距离仍然是瓶颈，而异地部署则要考虑负载均衡的问题，解决了这些问题也就基本部署成CDN了。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp概念整理</title>
    <link href="http://xr08255920.github.io/2021/11/26/cpp%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
    <id>http://xr08255920.github.io/2021/11/26/cpp%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Include"><a href="#Include" class="headerlink" title="Include"></a>Include</h3><p><code>#include</code> 明显是预编译命令，作用是把真正的代码段替换掉命令所在位置。<br><code>#include &lt;&gt;</code>引入类库路径里的头文件，<code>#include &quot;&quot;</code>引入的是程序目录路径里的头文件。</p><h3 id="函数-const"><a href="#函数-const" class="headerlink" title="函数+const"></a>函数+const</h3><p><code>返回值 函数名(参数) const</code><br>像上面这种函数后加const标识符的函数，表示它不会修改入参</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>类似java的重写toString()<br>形式：<code>返回值 operator+(入参1, 入参2...)</code></p><ul><li>这个“+”可以替换为其他运算符</li><li>运算符一般从左往右解析，如：<code>cout &lt;&lt; a &lt;&lt; b 等价于 (cout &lt;&lt; a) &lt;&lt; b</code></li></ul><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>定义：友元 修饰 函数，如友元函数，表示该函数可以访问这个（定义友元函数的）类的实例的私有变量<br>形式：<code>friend 函数声明</code><br>只能用在函数声明中</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>使一个自定义的类可以以如下形式输出到cout（类似java的toString）:</p><pre><code class="hljs c++">cout &lt;&lt; anClassObj</code></pre><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><h4 id="转换函数的原型声明"><a href="#转换函数的原型声明" class="headerlink" title="转换函数的原型声明"></a>转换函数的原型声明</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">typeName</span><span class="hljs-params">()</span></span>;</code></pre><h4 id="“类”-与-“基本类型”的转换"><a href="#“类”-与-“基本类型”的转换" class="headerlink" title="“类” 与 “基本类型”的转换"></a>“类” 与 “基本类型”的转换</h4><p>类可以定义单一参数的构造函数，来与基本类型进行转换，如：</p><pre><code class="hljs c++"><span class="hljs-comment">// 类定义:</span><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">// 隐式转换：</span>aClass a = <span class="hljs-number">3</span>;<span class="hljs-comment">// 等价于显式声明</span>aClass a = <span class="hljs-built_in">aClass</span>(<span class="hljs-number">3</span>);</code></pre><p>如果在类的构造函数声明前加上<strong>explicit</strong>，则构造函数只能用于显式声明</p><pre><code class="hljs c++"><span class="hljs-comment">// 声明为显式转换</span><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">typeName</span><span class="hljs-params">()</span></span>;</code></pre><h3 id="变量-amp-指针"><a href="#变量-amp-指针" class="headerlink" title="变量&amp;指针"></a>变量&amp;指针</h3><p>变量是编译时分配的有名称的内存<br>指针主要作用于运行时，为其分配未命名的内存以存储值</p><pre><code class="hljs c++"><span class="hljs-comment">// 模式1</span><span class="hljs-keyword">int</span> num = <span class="hljs-number">3</span>;<span class="hljs-keyword">int</span> * ptr = &amp;num;<span class="hljs-comment">// 模式2</span><span class="hljs-keyword">int</span> * ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">3</span>);</code></pre><p>如上述代码，模式1 和 模式2 的本质是一样的，都是指针ptr指向了一个3，但是前者有变量名num，后者没有变量名</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>赋值时它标记内容所在地址，使用时它是地址内的内容</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Include&quot;&gt;&lt;a href=&quot;#Include&quot; class=&quot;headerlink&quot; title=&quot;Include&quot;&gt;&lt;/a&gt;Include&lt;/h3&gt;&lt;p&gt;&lt;code&gt;#include&lt;/code&gt; 明显是预编译命令，作用是把真正的代码段替换掉命令所在位置</summary>
      
    
    
    
    
    <category term="c++" scheme="http://xr08255920.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>db锁</title>
    <link href="http://xr08255920.github.io/2021/11/26/db%E9%94%81/"/>
    <id>http://xr08255920.github.io/2021/11/26/db%E9%94%81/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>仅针对已被操作的数据</p><p>读锁<br>写锁<br>    行级锁<br>    表级锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅针对已被操作的数据&lt;/p&gt;
&lt;p&gt;读锁&lt;br&gt;写锁&lt;br&gt;    行级锁&lt;br&gt;    表级锁&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>disruptor学习记录</title>
    <link href="http://xr08255920.github.io/2021/11/26/disruptor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://xr08255920.github.io/2021/11/26/disruptor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="术语概念"><a href="#术语概念" class="headerlink" title="术语概念"></a>术语概念</h2><p><a href="https://github.com/LMAX-Exchange/disruptor/wiki/Introduction#core-concepts">参考地址</a></p><p>RingBuffer——Disruptor底层数据结构实现，核心类，是线程间交换数据的中转地；</p><p>Sequencer——序号管理器，生产同步的实现者，负责消费者/生产者各自序号、序号栅栏的管理和协调,Sequencer有单生产者,多生产者两种不同的模式,里面实现了各种同步的算法；</p><p>Sequence——序号，声明一个序号，用于跟踪ringbuffer中任务的变化和消费者的消费情况，disruptor里面大部分的并发代码都是通过对Sequence的值同步修改实现的,而非锁,这是disruptor高性能的一个主要原因；</p><p>SequenceBarrier——序号栅栏，管理和协调生产者的游标序号和各个消费者的序号，确保生产者不会覆盖消费者未来得及处理的消息，确保存在依赖的消费者之间能够按照正确的顺序处理</p><p>EventProcessor——事件处理器，监听RingBuffer的事件，并消费可用事件，从RingBuffer读取的事件会交由实际的生产者实现类来消费；它会一直侦听下一个可用的序号，直到该序号对应的事件已经准备好。</p><p>EventHandler——业务处理器，是实际消费者的接口，完成具体的业务逻辑实现，第三方实现该接口；代表着消费者。</p><p>Producer——生产者接口，第三方线程充当该角色，producer向RingBuffer写入事件。</p><p>Wait Strategy：Wait Strategy决定了一个消费者怎么等待生产者将事件（Event）放入Disruptor中。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgEventMain</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;          Disruptor disruptor = <span class="hljs-keyword">new</span> Disruptor(<span class="hljs-keyword">new</span> MsgEventFactory(), <span class="hljs-number">1024</span>, Executors.defaultThreadFactory()                  , ProducerType.SINGLE, <span class="hljs-keyword">new</span> BlockingWaitStrategy());  <span class="hljs-comment">// ①</span>        disruptor.handleEventsWith(<span class="hljs-keyword">new</span> MsgEventHandler());  <span class="hljs-comment">//②</span>        disruptor.start();  <span class="hljs-comment">//③</span>        RingBuffer ringBuffer = disruptor.getRingBuffer();  <span class="hljs-comment">//④</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;              <span class="hljs-keyword">int</span> finalI = i;              EventTranslator&lt;MsgEvent&gt; eventTranslator = (event, sequence) -&gt; &#123;                  event.setMsg(<span class="hljs-string">&quot;business msg:&quot;</span> + finalI);              &#125;;              ringBuffer.publishEvent(eventTranslator);  <span class="hljs-comment">//⑤</span>            Thread.sleep(<span class="hljs-number">300</span>);          &#125;          disruptor.shutdown();      &#125;  &#125;</code></pre><p>核心分为五步：</p><ol><li>创建一个disruptor<blockquote><p>（构造涉及 1. Event工厂；    2. 线程工厂;    3. 生产策略：多线程、单线程    4. 消费等待策略）</p></blockquote></li><li>指定消费者</li><li>启动disruptor</li><li>从disruptor中获取 ringbuffer</li><li>生产者调用 <code>ringBuffer.publishEvent</code> 发消息<blockquote><p>此处需要一个eventTranslator，来填充消息内容）</p></blockquote></li></ol><h3 id="官方实践"><a href="#官方实践" class="headerlink" title="官方实践"></a>官方实践</h3><ol><li>每个productor维护自己的 translator 的静态实例作为成员变量，且注入ringBuffer，用于生产消息</li></ol><h3 id="可调优项"><a href="#可调优项" class="headerlink" title="可调优项"></a>可调优项</h3><p>核心5步可以覆盖大多数生产场景使用，但是有些可调参数可以用于促进性能，分别是</p><ol><li>生产策略：多线程、单线程</li><li>消费等待策略</li></ol><h4 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h4><p><strong>「BlockingWaitStrategy」</strong></p><p>Disruptor的默认策略是BlockingWaitStrategy。在BlockingWaitStrategy内部是使用锁和condition来控制线程的唤醒。BlockingWaitStrategy是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。</p><p><strong>「SleepingWaitStrategy」</strong></p><p>SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，通过使用<code>LockSupport.parkNanos(1)</code>来实现循环等待。</p><p><strong>「YieldingWaitStrategy」</strong></p><p>YieldingWaitStrategy是可以使用在低延迟系统的策略之一。YieldingWaitStrategy将自旋以等待序列增加到适当的值。在循环体内，将调用<code>Thread.yield()</code>以允许其他排队的线程运行。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p><p><strong>「BusySpinWaitStrategy」</strong></p><p>性能最好，适合用于低延迟的系统。在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p><p><strong>「PhasedBackoffWaitStrategy」</strong></p><p>自旋 + yield + 自定义策略，CPU资源紧缺，吞吐量和延迟并不重要的场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;术语概念&quot;&gt;&lt;a href=&quot;#术语概念&quot; class=&quot;headerlink&quot; title=&quot;术语概念&quot;&gt;&lt;/a&gt;术语概念&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/LMAX-Exchange/disruptor/wiki/Intro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>guice实践手册</title>
    <link href="http://xr08255920.github.io/2021/11/26/guice%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/"/>
    <id>http://xr08255920.github.io/2021/11/26/guice%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>主要由 <code>key</code> 和 <code>provider</code> 来构成容器，所以容器本质上是个map</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>分两个步骤</p><ol><li>配置</li><li>注入</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>有两种方式</p><ol><li>注解</li><li>用DSL（Domain specify language）</li></ol><p>一个Module就是一个配置单元，bean的配置都在module里完成，类比Spring的@Configuration类</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p><code>@Provides</code>，用法如下：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractModule</span> </span>&#123;  <span class="hljs-meta">@Provides</span>  <span class="hljs-meta">@Count</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> Integer <span class="hljs-title">provideCount</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;  &#125;  <span class="hljs-meta">@Provides</span>  <span class="hljs-meta">@Message</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">provideMessage</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;  &#125;&#125;</code></pre><h4 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h4><table><thead><tr><th>Guice DSL syntax</th><th>Mental model</th></tr></thead><tbody><tr><td>bind(key).toInstance(value)</td><td>map.put(key, () -&gt; value)(instance binding)</td></tr><tr><td>bind(key).toProvider(provider)</td><td>map.put(key, provider)(provider binding)</td></tr><tr><td>bind(key).to(anotherKey)</td><td>map.put(key, map.get(anotherKey))(linked binding)</td></tr><tr><td>@Provides Foo provideFoo() {…}</td><td>map.put(Key.get(Foo.class), module::provideFoo)(provider method binding)</td></tr></tbody></table><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p><code>@Inject</code>，用在构造方法、set方法、成员变量，可以对参数进行注入</p><p>示例1</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;  <span class="hljs-keyword">private</span> Database database;  <span class="hljs-meta">@Inject</span>  Foo(Database database) &#123;  <span class="hljs-comment">// We need a database, from somewhere</span>    <span class="hljs-keyword">this</span>.database = database;  &#125;&#125;</code></pre><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebServer</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;    ...  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// Creates an injector that has all the necessary dependencies needed to</span>    <span class="hljs-comment">// build a functional server.</span>    Injector injector = Guice.createInjector(        <span class="hljs-keyword">new</span> RequestLoggingModule(),        <span class="hljs-keyword">new</span> RequestHandlerModule(),        <span class="hljs-keyword">new</span> AuthenticationModule(),        <span class="hljs-keyword">new</span> DatabaseModule(),        ...);    <span class="hljs-comment">// Bootstrap the application by creating an instance of the server then</span>    <span class="hljs-comment">// start the server to handle incoming requests.</span>    injector.getInstance(MyWebServer.class)        .start();  &#125;&#125;</code></pre><h2 id="Multibindings"><a href="#Multibindings" class="headerlink" title="Multibindings"></a>Multibindings</h2><p>Multibindings属于绑定模式里的一种，适用于插件架构。说白了就是把多个同类型的bean注入到一个列表中。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>通过 <code>Multibinder.newSetBinder</code> 生成一个指定接口类型的binder</li><li>调用1里生成的 <code>binder.addBinding()</code> 来追加插件（不是覆盖）</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlickrPluginModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractModule</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> </span>&#123;    Multibinder&lt;UriSummarizer&gt; uriBinder = Multibinder.newSetBinder(binder(), UriSummarizer.class);    uriBinder.addBinding().to(FlickrPhotoSummarizer.class);    ... <span class="hljs-comment">// bind plugin dependencies, such as our Flickr API key</span>  &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h2&gt;&lt;p&gt;主要由 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;provider&lt;/code&gt; 来构成容器，所以容器本质上是个map&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java探针技术</title>
    <link href="http://xr08255920.github.io/2021/11/26/java%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF/"/>
    <id>http://xr08255920.github.io/2021/11/26/java%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vm参数"><a href="#vm参数" class="headerlink" title="vm参数"></a>vm参数</h3><ul><li>-javaagent:<pathname>[=&lt;选项&gt;]<br>  加载本机代理库 <libname>, 例如 -agentlib:hprof</li><li>-agentlib:<libname>[=&lt;选项&gt;]<br>  按完整路径名加载本机代理库</li><li>-agentpath:<pathname>[=&lt;选项&gt;]<br>  加载 Java 编程语言代理, 请参阅 java.lang.instrument</li></ul><h3 id="相关基础包"><a href="#相关基础包" class="headerlink" title="相关基础包"></a>相关基础包</h3><p> java.lang.instrument</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/CLAYJJ/p/7992064.html">https://www.cnblogs.com/CLAYJJ/p/7992064.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vm参数&quot;&gt;&lt;a href=&quot;#vm参数&quot; class=&quot;headerlink&quot; title=&quot;vm参数&quot;&gt;&lt;/a&gt;vm参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;-javaagent:&lt;pathname&gt;[=&amp;lt;选项&amp;gt;]&lt;br&gt;  加载本机代理库 &lt;libname</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java类加载机制&amp;实践案例分析</title>
    <link href="http://xr08255920.github.io/2021/11/26/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&amp;%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://xr08255920.github.io/2021/11/26/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&amp;%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>定义<br>所有的代码，都是用来描述数据结构和算法逻辑的<br>运行代码时，需要把陈述性的逻辑转换成物理性的数据结构，然后照着逻辑描述的算法去操作这些数据结构。</p><p>java程序跑起来，需要哪几步？</p><ol><li>获取描述性的文本</li><li>按照特定语法，把文本转成物理结构，即一堆二进制。</li><li>按照特定语法，遵循着文本描述的逻辑去操作这些数据结构，如果在此时又遇到了其它描述性文本的名字（类名），也要走第1步把它获取到。</li></ol><p>发生在第1、3步的获取动作，就是类的加载</p><p>类加载的机制有以下描述：</p><ol><li>不同的类加载器，可以从不同的地方加载类文本，各司其职</li><li>A类中用到了B类，B类由A的类加载器加载</li><li>所有的类，优先由顶层类加载器自顶向下加载</li><li>Thread中可以自行设置类加载器供程序获取（默认是系统类加载器）</li></ol><p>通过以上描述，可以得知以下几个特性：</p><ol><li>在程序进行到某个节点时，能加载哪些类，取决于当前可以取得哪些classLoader，1. 加载类的caller的classloader；2. Thread中设置的classLoader</li><li>就算当前能获得<strong>预期的ClassLoader</strong>，还要父辈 类加载器 找不到类，<strong>它们</strong>才能派上用场</li></ol><p>案例<br>一、tomcat<br>一个Tomcat容器，即为一个JVM容器。</p><p>下面可以有多个Web应用（可理解为一个war包为一个应用），相当于多个web应用可以同时跑在一个tomcat容器下</p><p>不同的web应用会使用到不同版本的依赖包。都会加载到同一个jvm容器中。可以理解为：同一个类名存在 v1.0、v2.0 … 等多个版本，都被加载到同一个jvm的元数据区。</p><p>如何保证多个相同全限定名的类互相不冲突？</p><p>每个web应用下的所有类(web-inf/classes，web-info/lib），都由一个新的WebAppClassLoader来加载。这样，它们新引入的类，也都会由这个loader来加载。各个web应用的loader，都只能加载各自范围内的类，这样就能保证各个web应用的类相互隔离。</p><p>如何保证Jsp能热加载</p><p>jsp本质也是一个描述逻辑的文本，也就是class，所以也需要被类加载器加载。当jsp被修改，为了不让程序去元数据区取已经加载过的类，要给这个类指定一个新的类加载器，来重新加载类文本。每个jsp类都由一个属于自己的类加载器。</p><p>二、spring<br>沿用上面描述的场景，一个tomcat容器下有多个web应用。但是spring框架包放在公共类库中，多个web应用都可以通过同一个祖先类加载器共享spring类。此时再通过spring类来创建各个web应用的bean，是不可能的，因为祖先类加载器无法加载不在其负责范围的类。</p><p>spring通过把每个web应用各自的WebAppClassLoader设置到线程中，在spring容器加载类时，直接用线程中的loader来加载。</p><p>此时，在一个JVM容器的元数据区中，spring类是独一份的，而各个web应用的类由它们自己的loader加载。spring获取线程loader的核心代码在 DefaultResourceLoader 中</p><p>三、arthas<br>使用arthas的ognl命令，可以实时的调用jvm容器里的类的方法，或者获取类的属性。然而在实践中，通常会出现ClassNotFound异常。原因在于arthas使用的类加载器独立于系统类加载器，直接使用ognl命令会使用arthas的类加载器来加载类，导致找不到类。通过加上参数，指定使用具体的web应用类加载器，即可正常调用类方法了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定义&lt;br&gt;所有的代码，都是用来描述数据结构和算法逻辑的&lt;br&gt;运行代码时，需要把陈述性的逻辑转换成物理性的数据结构，然后照着逻辑描述的算法去操作这些数据结构。&lt;/p&gt;
&lt;p&gt;java程序跑起来，需要哪几步？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取描述性的文本&lt;/li&gt;
&lt;li&gt;按</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux系统目录层级标准——/bin、/usr/bin、/usr/local/bin、/opt的区别</title>
    <link href="http://xr08255920.github.io/2021/11/26/linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7%E6%A0%87%E5%87%86/"/>
    <id>http://xr08255920.github.io/2021/11/26/linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7%E6%A0%87%E5%87%86/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bin-VS-usr-bin-VS-usr-local-bin-VS-opt"><a href="#bin-VS-usr-bin-VS-usr-local-bin-VS-opt" class="headerlink" title="/bin VS /usr/bin/ VS /usr/local/bin VS /opt"></a>/bin VS /usr/bin/ VS /usr/local/bin VS /opt</h2><h3 id="当前标准"><a href="#当前标准" class="headerlink" title="当前标准"></a>当前标准</h3><p>wiki上搜索 FileSystem hierarchy standard，有对这些目录用途的一个官方标准的解析，但是对于 /usr/local 的解析，依然是模棱两可，所以要完全了解它们的本质，还是得纵观一下发展历史。</p><h3 id="历史趣闻"><a href="#历史趣闻" class="headerlink" title="历史趣闻"></a>历史趣闻</h3><p><a href="http://lists.busybox.net/pipermail/busybox/2010-December/074114.html">Understanding the bin, sbin, usr/bin , usr/sbin split (busybox.net)</a></p><p>据<strong>Rob Landley</strong>这位老哥的说法，/bin 和 /usr/bin 的分裂，属于历史产物，本质上没有区别。</p><p>参考<strong>Rob Landley</strong>的说法，再结合社区的讨论《<a href="https://unix.stackexchange.com/questions/11544/what-is-the-difference-between-opt-and-usr-local">What is the difference between /opt and /usr/local?</a>》，可知，/usr/local 源于BSD，要不就是用于编译自己编写的源码，或者用于存放第三方包源码（未安装），其构建结果就放在 /usr/local/bin 。一些人认为已打包好的第三方binary包不适合放在 /usr/local ，于是 /opt 出现了。</p><blockquote><p>Rob Landley：<br>and<br>/usr/local was for your specific installation’s files.  Then somebody decided<br>/usr/local wasn’t a good place to install new packages, so let’s add /opt!<br>I’m still waiting for /opt/local to show up…</p></blockquote><blockquote><p>《What is the difference between /opt and /usr/local?》：<br><code>/usr/local</code> is a place to install files built by the administrator<br><code>/usr/local</code> is a legacy from the original BSD.</p></blockquote><p>这一篇讨论 <a href="https://unix.stackexchange.com/questions/332764/role-of-the-usr-local-directory-in-freebsd">Role of the /usr/local directory in FreeBSD</a> 可以进一步了解BSD的 /usr/local</p><h3 id="usr的含义"><a href="#usr的含义" class="headerlink" title="usr的含义"></a>usr的含义</h3><p>有两种说法</p><ol><li>unix system resource</li><li>user 的缩写</li></ol><p>根据上面的文章，<a href="https://twitter.com/linuxtoy/status/1228572721597964288">还有推特的讨论</a>，个人更倾向于 usr 就是user的缩写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bin-VS-usr-bin-VS-usr-local-bin-VS-opt&quot;&gt;&lt;a href=&quot;#bin-VS-usr-bin-VS-usr-local-bin-VS-opt&quot; class=&quot;headerlink&quot; title=&quot;/bin VS /usr/bin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mermaid语法</title>
    <link href="http://xr08255920.github.io/2021/11/26/mermaid%E8%AF%AD%E6%B3%95/"/>
    <id>http://xr08255920.github.io/2021/11/26/mermaid%E8%AF%AD%E6%B3%95/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>Mermaid是一种基于Javascript的绘图工具</p><p>示例：</p><p>时序图</p><pre><code class="hljs mermaid">sequenceDiagrama -&gt;&gt; b:asdb --&gt;&gt; a:asd</code></pre><p>类图</p><pre><code class="hljs mermaid">classDiagramClass01 &lt;|-- AveryLongClass: CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2: Where am i?Class09 --* C3Class09 --|&gt; Class07Class07: equals()Class07: Object[] elemeentDataClass01: size()Class01: int chimpClass01: int gorillaClass08 &lt;--&gt; C2: Cool label</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mermaid是一种基于Javascript的绘图工具&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;时序图&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs mermaid&quot;&gt;sequenceDiagram
a -&amp;gt;&amp;gt; b:asd
b --&amp;gt;&amp;gt; a:as</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>visual studio 2019实践整理</title>
    <link href="http://xr08255920.github.io/2021/11/26/visual%20studio%202019%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/"/>
    <id>http://xr08255920.github.io/2021/11/26/visual%20studio%202019%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>简介<br>c、c++([[cpp]])以及.net框架(c#、vb等)的通用开发ide</p><p>经验整理</p><p>找不到 Windows SDK<br>在项目上右击选择重定目标解决方案，将windosSdk的版本号选择成合适的</p><p>为何c#不需要include头文件<br>c#中用using namespace完成了java中import packages的能力。前提是项目引用中需要指定了相应的dll，然后using就可以了。</p><p>MSB8040    此项目需要缓解了 Spectre 漏洞的库。<br>打开安装器，选择<strong>修改</strong> -&gt;  <strong>单个组件</strong>，搜索MSVC查看版本（如：v14.28），然后安装相应的MSVC缓解库</p><p>E1696    cannot open source file<br>删掉依赖包重新nuget下载</p><p>LINK : fatal error LNK1104: cannot open file ‘atls.lib’ 问题<br>安装atl、mfc缓解库</p><p>powershell 执行 ps脚本，报 PSSecurityException<br>解除文件锁定，<code>Get-ChildItem -r|Unblock-File</code></p><p>c++项目没有设置output directory<br>一般是通过以下配置设置了：<br><code>&lt;Import Project=&quot;$(VCTargetsPath)\Microsoft.cpp.Default.props&quot; /&gt;</code></p><p>/obj 是什么文件夹<br>c++的中间产物存放处</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简介&lt;br&gt;c、c++([[cpp]])以及.net框架(c#、vb等)的通用开发ide&lt;/p&gt;
&lt;p&gt;经验整理&lt;/p&gt;
&lt;p&gt;找不到 Windows SDK&lt;br&gt;在项目上右击选择重定目标解决方案，将windosSdk的版本号选择成合适的&lt;/p&gt;
&lt;p&gt;为何c#不需要in</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>事务隔离级别</title>
    <link href="http://xr08255920.github.io/2021/11/26/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://xr08255920.github.io/2021/11/26/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-01-30T11:26:49.707Z</updated>
    
    <content type="html"><![CDATA[<p>read uncommited<br>read commited<br>repeatable read<br>serializable</p><p>关注事务过程中<strong>可读数据</strong>的表现</p><ol><li>未提交也可读</li><li>提交后才可读，同一条数据会读存储系统（脏读</li><li>同一条数据从缓存取，新读取的数据从存储系统取（幻读</li><li>串行化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;read uncommited&lt;br&gt;read commited&lt;br&gt;repeatable read&lt;br&gt;serializable&lt;/p&gt;
&lt;p&gt;关注事务过程中&lt;strong&gt;可读数据&lt;/strong&gt;的表现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;未提交也可读&lt;/li&gt;
&lt;li&gt;提</summary>
      
    
    
    
    
  </entry>
  
</feed>
