<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeJF的篝火</title>
  
  <subtitle>回血、存档、再出发</subtitle>
  <link href="http://donnieyeh.github.io/atom.xml" rel="self"/>
  
  <link href="http://donnieyeh.github.io/"/>
  <updated>2022-09-17T09:51:31.026Z</updated>
  <id>http://donnieyeh.github.io/</id>
  
  <author>
    <name>yejf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MQ思考总结</title>
    <link href="http://donnieyeh.github.io/2022/08/24/MQ%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    <id>http://donnieyeh.github.io/2022/08/24/MQ%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-24T16:03:00.000Z</published>
    <updated>2022-09-17T09:51:31.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据从一端到另一端，中途的所有链路和节点都可能丢失数据"><a href="#数据从一端到另一端，中途的所有链路和节点都可能丢失数据" class="headerlink" title="数据从一端到另一端，中途的所有链路和节点都可能丢失数据"></a>数据从一端到另一端，中途的所有链路和节点都可能丢失数据</h2><p>假设两端需要传输数据，则数据可能会在中途丢失<br>P -&gt; C</p><p>若增加一台broker来中转数据，则broker前后的链路传输途中可能丢失数据，broker自身也可能丢失数据<br>P -&gt; B -&gt; C</p><h2 id="解决数据丢失问题"><a href="#解决数据丢失问题" class="headerlink" title="解决数据丢失问题"></a>解决数据丢失问题</h2><p>1、防止P -&gt; B丢失，使用同步机制，或者异步+回调+本地消息表<br>2、防止B自身丢失，可使用定时持久化消息，使用分布式节点+冗余数据<br>3、防止B -&gt; C丢失，<del>可以使用同步机制</del>，或者异步+回调+本地消息表</p><p>其中，3的同步机制，即C每次Poll后，直到业务处理完，再commit消息。连接需要等待漫长的业务处理完后才能释放，明显不合理，很少使用<br>而3的异步+回调+本地消息表，则是C每次Poll完后直接释放连接，等待业务完成消息后，再回调broker commit消息，是大多MQ默认的手段</p><p>注意：消费端收到消息，要保证走完全流程处理才Commit消息，且只要走完业务全流程，哪怕处理失败，也应该commit。只有在处理消息过程中宕机这种极端情况，才需要重新消费</p><h2 id="提升数据传输过程吞吐量的思路，是减少端到端的网络通信次数"><a href="#提升数据传输过程吞吐量的思路，是减少端到端的网络通信次数" class="headerlink" title="提升数据传输过程吞吐量的思路，是减少端到端的网络通信次数"></a>提升数据传输过程吞吐量的思路，是减少端到端的网络通信次数</h2><p>1、P -&gt; B，可以在P设置缓冲区，定时或定量 批量传输消息，从“N条消息N次连接”优化为“N条消息1次连接”（同步机制）<br>2、B -&gt; C，C端批量Poll消息，定时 批量提交Commit请求，从“N条消息N次连接”优化为“N条消息2次连接”（异步+回调）</p><h2 id="MQ产品的特殊情况"><a href="#MQ产品的特殊情况" class="headerlink" title="MQ产品的特殊情况"></a>MQ产品的特殊情况</h2><p>Kafka，使用Offset作为B -&gt; C端的同步机制，只有当某个offset之前的所有消息都被消费了，这个offset才能更新到B端。这就导致了如果一个早期的消息一直得不到commit，offset无法被更新，则早期的消息会不断的被重发。这个问题可以通过阈值到期加入死信队列来解决</p><p>RocketMQ，为什么不使用Zookeeper作为注册中心，<strong>待调研</strong>,参考：<br>    - <a href="https://zhuanlan.zhihu.com/p/368773517">面试题系列：MQ 夺命连环11问 - 知乎 (zhihu.com)</a></p><h2 id="容错性优化"><a href="#容错性优化" class="headerlink" title="容错性优化"></a>容错性优化</h2><ol><li>B端不可靠的场景，在P端增加一个自消费的topic和机器，增加容错性</li><li>C端不可靠场景，增加一个临时Consumer端，吸收积压消息，转发到一个新的topic机器中做缓冲</li></ol><p>总结：针对节点不可靠场景，可以临时增加（或预设）机器模拟该节点，来消化和缓冲临时数据</p><h2 id="分布式节点-冗余数据的技术关键"><a href="#分布式节点-冗余数据的技术关键" class="headerlink" title="分布式节点+冗余数据的技术关键"></a>分布式节点+冗余数据的技术关键</h2><ol><li>需要多台机器能够自治<ol><li>心跳机制，保证节点健康监测的基础</li><li>选举机制，保证节点健康监测的可靠性</li></ol></li><li>需要保证多台机器的数据一致性<ol><li> raft协议</li></ol></li><li>提供多台Broker的发现机制：使用注册中心处理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据从一端到另一端，中途的所有链路和节点都可能丢失数据&quot;&gt;&lt;a href=&quot;#数据从一端到另一端，中途的所有链路和节点都可能丢失数据&quot; class=&quot;headerlink&quot; title=&quot;数据从一端到另一端，中途的所有链路和节点都可能丢失数据&quot;&gt;&lt;/a&gt;数据从一端</summary>
      
    
    
    
    
    <category term="MQ" scheme="http://donnieyeh.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>java请求https证书问题，`unable to find valid certification path to requested target`</title>
    <link href="http://donnieyeh.github.io/2022/08/24/java%E8%AF%B7%E6%B1%82https%E8%AF%81%E4%B9%A6%E9%97%AE%E9%A2%98/"/>
    <id>http://donnieyeh.github.io/2022/08/24/java%E8%AF%B7%E6%B1%82https%E8%AF%81%E4%B9%A6%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-24T16:03:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用okHttp请求某https服务（<a href="https://api.github.com/">https://api.github.com</a>），然而却报证书相关的错误：<code>unable to find valid certification path to requested target</code>，问题是如果直接用浏览器访问该地址，却是安全的。</p><h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><p>在未跟进源码之前，个人理解JAVA默认使用的是系统自带的CA证书，那么浏览器访问该HTTPS没问题，说明该服务是能够被系统内置的CA证书认证的，按理说JAVA访问也应该没问题才对。重点就在于为什么JAVA的和浏览器的表现不一致。</p><p>搜索引擎出来的全部都是教你如何绕过安全校验、信任所有HTTPS网站，这固然能临时解决问题，但根本就是因噎废食，这种解决是建立在牺牲安全性之上的！</p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>断点跟进源码，发现okhttp底层使用的是JDK原生工具库<code>sun.security.ssl</code>。再跟了几层，发现ssl库使用的信任证书库是指定路径下的<code>..\jdk1.8.0_292\jre\lib\security\cacerts</code>文件。</p><blockquote><p>读取配置代码：TrustStoreManager.TrustStoreDescriptor.createInstance()<br>信任库优先读取顺序：javax.net.ssl.trustStore（环境变量） &gt; cacerts文件（默认）</p></blockquote><p>通过<code>keytool</code>命令打印jdk的信任证书库。</p><pre><code class="hljs bash">keytool -list -keystore cacerts -rfc</code></pre><p>再在浏览器下载验证通过的根证书，存为base64格式。</p><p>对比二者，发现jdk的信任证书库并不包含该根证书。可见jdk的信任证书库与系统证书库不一致，导致了上文提到的表现上的差异。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>cd到<code>\jre\lib\security</code>目录下，然后导入缺少的那个根证书</p><pre><code class="hljs bash"><span class="hljs-comment"># 注意查看的时候不要求口令，但是修改的时候是要求口令的，而默认的口令就是 changeit</span>keytool -importcert -file target.cer -keystore cacerts -storepass changeit -storetype jks</code></pre><p>然后再重新跑一遍程序，很好，能正常请求https获取响应了</p><p>相关关键词：</p><ul><li>unable to find valid certification path to requested target</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;使用okHttp请求某https服务（&lt;a href=&quot;https://api.github.com/&quot;&gt;https://api.githu</summary>
      
    
    
    
    
    <category term="https" scheme="http://donnieyeh.github.io/tags/https/"/>
    
    <category term="证书" scheme="http://donnieyeh.github.io/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>maven repository mirror优先级</title>
    <link href="http://donnieyeh.github.io/2022/08/24/maven%20repository%20mirror%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://donnieyeh.github.io/2022/08/24/maven%20repository%20mirror%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2022-08-24T16:03:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<ul><li>依赖的下载只会从repository中挑选仓库下载</li><li>  挑选仓库的顺序是从上到下</li><li>  如果下载依赖过程中出现问题（比如https证书校验失败），则会报错最上面第一个仓库找不到依赖</li><li>  mirror只会改变仓库地址的映射，不会影响加载顺序，通过 mirrorOf 与 repository的Id 绑定</li><li>  中心仓在超级pom中有配置，默认id=central，由于加载太慢，可以覆写中心仓的地址</li><li>  中心仓放在最后兜底查询</li><li>  mirror的mirrorOf * 配置，可以充当repository，作为终极兜底</li><li>  实践理解： mvn clean compile -X</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;依赖的下载只会从repository中挑选仓库下载&lt;/li&gt;
&lt;li&gt;  挑选仓库的顺序是从上到下&lt;/li&gt;
&lt;li&gt;  如果下载依赖过程中出现问题（比如https证书校验失败），则会报错最上面第一个仓库找不到依赖&lt;/li&gt;
&lt;li&gt;  mirror只会改变仓库</summary>
      
    
    
    
    
    <category term="maven" scheme="http://donnieyeh.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>checked exception VS unchecked exception</title>
    <link href="http://donnieyeh.github.io/2022/08/24/checked%20exception%20VS%20unchecked%20exception/"/>
    <id>http://donnieyeh.github.io/2022/08/24/checked%20exception%20VS%20unchecked%20exception/</id>
    <published>2022-08-24T15:57:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<p>checked exception 即你在方法里某个逻辑抛出了这个异常，且在方法签名显式声明会抛出这个异常。<br>unchecked exception 即你在方法里某个逻辑抛出了这个异常，但是不会在方法签名显式声明抛出这个异常。</p><p>一个是抛了且要求调用层处理，一个是只抛不强制要求调用层处理。</p><p>其中一种声音是，是否声明checked异常取决于你判断caller是否关心这个异常。</p><blockquote><p>This is the philosophy used by many frameworks. Spring and hibernate, in particularly, come to mind - they convert known checked exception to unchecked exception precisely because checked exceptions are overused in Java. One example that I can think of is the JSONException from json.org, which is a checked exception and is mostly annoying - it should be unchecked, but the developer simply haven’t thought it through.</p></blockquote><p>异常可以从以下维度去理解，1、是否可预见的，2、是否可预防的，3、是否可恢复的（通过兜底、降级等手段）。针对以上维度，我们可以整理出如下的对策</p><ul><li>不可预见的：我们没有任何手段去阻止，通常只能尝试（try）去监测（catch），然后打印下日志，等待开发来修改BUG代码</li><li>可预见的<ul><li>可预防的：直接就在代码里预判且处理妥当了，比如常见的<code>StringUtils.isEmpty()</code></li><li>不可预防的：<ul><li>可恢复的：不可预防可以理解为，我们知道这事可能发生，但是我们没法阻止异常的发生，比如在”检查文件是否存在”和”读取文件内容”两个操作之间，文件被人删除了。这种异常我们无法通过写代码来阻止另外一个用户把文件删除，但是也不能置之不理，所以此时就要在方法签名中明确声明一个异常，调用层被迫要对该异常进行处理，可以是兜底、降级，当然调用层可以继续往外抛。</li><li>不可恢复的：如果预见一个不可预防的异常，且无法通过兜底、降级的手段解决，则提前声明checked exception也没意义，此时可采取的手段就跟“不可预见”异常一样了。</li></ul></li></ul></li></ul><p>以一个表格来进行小结：</p><table><thead><tr><th>可预见</th><th>可预防</th><th>可恢复</th><th>所属异常类型</th><th>可采取手段</th></tr></thead><tbody><tr><td>×</td><td>-</td><td>-</td><td>uncheck exception</td><td>try catch</td></tr><tr><td>√</td><td>√</td><td>-</td><td>not exception</td><td>代码规避</td></tr><tr><td>√</td><td>×</td><td>×</td><td>uncheck exception</td><td>try catch</td></tr><tr><td>√</td><td>×</td><td>√</td><td>checked exception</td><td>方法签名声明异常+调用方try catch</td></tr></tbody></table><blockquote><p>Compiler will check that we have done one of the two things (catch, or declare). So these are called Checked exceptions.</p></blockquote><blockquote><p>当在方法签名显式声明了throws Exception，编译器会检查（check）调用者需要执行这两个动作之一：1、进行catch  2、“继续声明throws Exception 往外抛”，否则过不了编译，所以这种异常叫做checked exception</p></blockquote><p>Checked Exceptions 应该用于可以合理恢复的可预测但不可预防的错误。</p><p>就像工作一样，处理Exception，理清责任很重要，如果一个checked exception由当前方法处理不当导致，则当前方法需要catch并做兜底处理，至少得打日志；反之如果判断它是由上层参数导致，则把异常外抛给调用层，而不是自己揽过来处理。</p><p>参考文章：</p><ul><li><a href="https://webcache.googleusercontent.com/search?q=cache:zKMFajzvoiQJ:https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java/+&cd=4&hl=zh-CN&ct=clnk">Checked vs Unchecked Exceptions in Java - GeeksforGeeks (googleusercontent.com)</a></li><li><a href="https://stackoverflow.com/questions/27578/when-to-choose-checked-and-unchecked-exceptions">java - When to choose checked and unchecked exceptions - Stack Overflow</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;checked exception 即你在方法里某个逻辑抛出了这个异常，且在方法签名显式声明会抛出这个异常。&lt;br&gt;unchecked exception 即你在方法里某个逻辑抛出了这个异常，但是不会在方法签名显式声明抛出这个异常。&lt;/p&gt;
&lt;p&gt;一个是抛了且要求调用层处理</summary>
      
    
    
    
    
    <category term="java" scheme="http://donnieyeh.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>股票开户学习笔记</title>
    <link href="http://donnieyeh.github.io/2022/05/15/%E8%82%A1%E7%A5%A8%E5%BC%80%E6%88%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://donnieyeh.github.io/2022/05/15/%E8%82%A1%E7%A5%A8%E5%BC%80%E6%88%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-15T11:07:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<ol><li>本地有营业部很重要</li><li>佣金分为全佣和净佣+规费（常规费用？印花税+过户费）</li><li>大部分在线开户佣金都为万2.5~万3，费率高</li><li>建议找对应券商经理人开户，可以谈低佣金，记得只谈全佣</li><li>国内开户建议搜索202x年证券公司排名，找排前的大公司准没错，看中之后先体验下对方的app是否顺手好用</li><li>国外（港美股）开户建议富途证券，因为是腾讯系，总部在深圳网络会好点</li><li>港美股交易一般佣金较高，一单至少得有15R以上</li><li>港美股一些交易所如果没相应资质证，会接入第三方在线国际券商，来代理交易，相当于被薅多一层羊毛，最好不要选这种交易所</li><li>同花顺只是一个第三方交易平台，作为中介接入多个券商平台，实际上是后台接入真正开户的平台来进行交易的。实际使用界面也就那样，盯盘体验还不如支付宝股票。而且作为一个中介，开户佣金都是收取最高的点数万2.5~3</li><li>建议“支付宝股票”用于盯盘，搭配“开户平台自家APP”交易</li><li>综上，炒港美股实在不太划算，首先要开户，其次佣金费率高。此时炒币成了跨国投资的一个重要的手段，它不需要开户，而且走势和美股挂钩（高度相关）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;本地有营业部很重要&lt;/li&gt;
&lt;li&gt;佣金分为全佣和净佣+规费（常规费用？印花税+过户费）&lt;/li&gt;
&lt;li&gt;大部分在线开户佣金都为万2.5~万3，费率高&lt;/li&gt;
&lt;li&gt;建议找对应券商经理人开户，可以谈低佣金，记得只谈全佣&lt;/li&gt;
&lt;li&gt;国内开户建议搜索</summary>
      
    
    
    
    
    <category term="投资" scheme="http://donnieyeh.github.io/tags/%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>C++指针理解</title>
    <link href="http://donnieyeh.github.io/2022/04/28/C++%E6%8C%87%E9%92%88%E7%90%86%E8%A7%A3/"/>
    <id>http://donnieyeh.github.io/2022/04/28/C++%E6%8C%87%E9%92%88%E7%90%86%E8%A7%A3/</id>
    <published>2022-04-28T15:01:00.000Z</published>
    <updated>2022-09-17T09:51:31.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h2><pre><code class="hljs c++"><span class="hljs-keyword">int</span> j = <span class="hljs-number">49</span>;<span class="hljs-keyword">int</span> *i = &amp;j;# 更好的声明方式<span class="hljs-keyword">int</span>* i = &amp;j;</code></pre><p>只要声明的时候，加了<code>*</code> 号，这个变量就是<code>指针变量</code>，比如这个 i 就是一个<code>指针类型的变量</code>，而不是一个<code>int类型的变量</code></p><h3 id="那这个int在这里的作用是什么？"><a href="#那这个int在这里的作用是什么？" class="headerlink" title="那这个int在这里的作用是什么？"></a>那这个int在这里的作用是什么？</h3><p>先说结论：这个int，表明了从指针指向的头地址开始，需要往后取多少位长度的数据。</p><p>我们首先要知道，各个基础类型，都有自己的长度，如int型是32位，long型是64位。而指针类型也有自己的长度，它的值存放的是一个内存地址，即寻址长度。在32位系统中，指针类型的长度是32；在64位系统中，指针类型的长度为64。</p><p>由于指针存放的是一个内存地址，它指向的是内存中的某个比特位，即所谓的头地址。如果单看头地址的这个比特位，并没有什么实际意义，因为它只能包含0/1两种信息。而<code>int* i</code>这样声明指针类型的话，实际是在指导机器不止要看头地址，而且还要往后取32位，才能完整的把int类型的数据取出来。总结来说，单纯的指针类型变量只包含了某个内存地址（头地址）指向的那一个bit的信息，并无实际意义，只有带上具体的类型，指针类型变量才具有意义。</p><h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><p>假如当前声明了一个指针变量<code>int* i</code>，一个普通变量<code>int j</code></p><ul><li><code>i</code> 表示内存地址，类型为<code>指针类型</code></li><li><code>*i</code>表示真正的数据，类型为具体声明的类型，如<code>int</code></li><li><code>&amp;j</code>表示变量 j 的内存首地址，类型为<code>指针类型</code></li><li><code>&amp;</code>也可以用在指针类型上，如：<code>&amp;i</code>得到的是<code>指针类型的</code> <code>变量i</code>的内存首地址</li></ul><p>示例：</p><ul><li><code>cout &lt;&lt; i</code> 可以的得到<code>指针变量</code>对应的值（即某内存地址）</li><li><code>cout &lt;&lt; *i</code> 可以可以得到真正的数据，通过 <code>头地址+类型长度</code> 获取</li></ul><h2 id="指针类型变量存在栈中还是堆中"><a href="#指针类型变量存在栈中还是堆中" class="headerlink" title="指针类型变量存在栈中还是堆中"></a>指针类型变量存在栈中还是堆中</h2><p>指针类型的变量，以<code>int* i</code>为例，它可能存在于方法栈的内存空间中，也可能存在堆空间中（通过malloc函数）。</p><h3 id="为什么要有堆内存？"><a href="#为什么要有堆内存？" class="headerlink" title="为什么要有堆内存？"></a>为什么要有堆内存？</h3><p>局部变量在方法栈中分配空间，当方法执行结束、方法栈弹出之后它也会跟着被清除。此时哪怕把局部变量的指针返回出去，外部拿到的指针对应的值也是空的。只有在堆中分配的内存空间，才不会随着方法结束出栈而被清理，此时对应的指针在外部就依然能够正常获取数据。</p><p>堆内存的局限在于需要开发者手动回收，不然程序长时间运行可能会导致内存溢出。当然很多语言自带的GC也是一种优雅手段。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">43</span>;    <span class="hljs-keyword">int</span>* i;    std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;    i = <span class="hljs-built_in">b</span>();    std::cout &lt;&lt; i&lt;&lt; std::endl;    std::cout &lt;&lt; *i&lt;&lt; std::endl;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">100</span>; z++)    &#123;        <span class="hljs-comment">/* code */</span>    &#125;    std::cout &lt;&lt; i&lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">49</span>;    <span class="hljs-comment">// int* i = &amp;j;</span>    <span class="hljs-keyword">int</span>* i = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);    *i = <span class="hljs-number">256</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;in b:&quot;</span> &lt;&lt;*i&lt;&lt; std::endl;    <span class="hljs-keyword">return</span> i;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;指针的声明&quot;&gt;&lt;a href=&quot;#指针的声明&quot; class=&quot;headerlink&quot; title=&quot;指针的声明&quot;&gt;&lt;/a&gt;指针的声明&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/s</summary>
      
    
    
    
    <category term="c++" scheme="http://donnieyeh.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="http://donnieyeh.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper / etcd 的区别</title>
    <link href="http://donnieyeh.github.io/2022/04/05/zookeeper%20,%20etcd%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://donnieyeh.github.io/2022/04/05/zookeeper%20,%20etcd%20%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-04-05T13:30:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper-etcd-的区别"><a href="#zookeeper-etcd-的区别" class="headerlink" title="zookeeper / etcd 的区别"></a>zookeeper / etcd 的区别</h1><p>etcd，分布式一致性键值存储引擎，专门为分布式系统提供服务。它基于Raft共识算法，使用GOlang开发（这点很重要），由<a href="https://zh.wikipedia.org/wiki/CoreOS" title="CoreOS">CoreOS</a>开发。在github release上可以跟踪到最早发布在2013年8月12号，最近更新是在3天前，可以说是相当活跃了。</p><p>zookeeper，官方介绍是一个高可靠分布式<strong>协调</strong>服务。它提供配置维护、命名、分布式同步、分组服务（group services）等等功能。它起源于雅虎研究院的一个研究小组，后来成为hadoop的子项目，主要<strong>为Hadoop生态系统中一些列组件提供统一的分布式协作服务</strong>，再后来在（Hadoop 1.0时代）<strong>2011年1月</strong>， ZooKeeper 脱离Hadoop，成为Apache顶级项目，并成为开源项目，一直发展至今。它在官网上可找到最早的发布版本是2008年10月27好，github上最近的提交是4天前，且仅有少量提交，活跃对相对etcd较低。它基于基于 ZAB （Zookeeper Atomic Broadcast）协议实现，由java语言编写。</p><table><thead><tr><th>-</th><th>语言</th><th>能力</th><th>社区活跃度</th><th>其他</th></tr></thead><tbody><tr><td>zookeeper</td><td>java</td><td>配置维护、命名、分布式同步、分组服务</td><td>良</td><td>老牌分布式同步工具，kafka、dubbo、hadoop等都在用</td></tr><tr><td>etcd</td><td>GO</td><td>分布式键值存储、共享配置、服务发现</td><td>优</td><td>因支撑k8s而火</td></tr></tbody></table><h2 id="Raft-consensus-algorithm"><a href="#Raft-consensus-algorithm" class="headerlink" title="Raft consensus algorithm"></a>Raft consensus algorithm</h2><p>参考大神的动画： <a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p>raft其实是一个协议（protocol）。在这个协议当中，参与通信的结点有三种状态，leader、follower、candidate。在协议当中，有两种超时类型（timeout），election timeout，heartbeat timeout。leader 以 heartbeat timeout 为周期同步信息，follower 收到消息立即响应。同时存在多个节点进行leader选举时，先得到半数响应的节点成为leader。leader通过两阶段（预设、提交）同步数据，并且会记录log。</p><h2 id="ZAB（Zookeeper-Atomic-Broadcast）协议"><a href="#ZAB（Zookeeper-Atomic-Broadcast）协议" class="headerlink" title="ZAB（Zookeeper Atomic Broadcast）协议"></a>ZAB（Zookeeper Atomic Broadcast）协议</h2><p>选举通常是选zxid，sid（myid）最大的。新选举完毕会产生新的纪元，epoch，老leader恢复后其他节点也不听他管，毕竟前朝的剑不能斩本朝的官。</p><hr><p>Zookeeper的ZAB，Viewstamped Replication（VR），raft，multi-paxos，这些都可以被称之为Leader-based一致性协议。总的来说raft相对来说比较亲民好理解。</p><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/weixin_38256474/article/details/90636262">[zookeeper] 00 - 初识：由来、版本、架构_神是念着倒-CSDN博客_zookeeper发展历史</a></li><li><a href="https://blog.csdn.net/qq_22115231/article/details/80784535">Zookeeper理解_老史的足迹-CSDN博客</a></li><li><a href="https://www.zhihu.com/question/36648084">raft算法与paxos算法相比有什么优势，使用场景有什么差异？ - 知乎 (zhihu.com)</a></li><li><a href="https://dzone.com/articles/apache-zookeeper-vs-etcd3">https://dzone.com/articles/apache-zookeeper-vs-etcd3</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;zookeeper-etcd-的区别&quot;&gt;&lt;a href=&quot;#zookeeper-etcd-的区别&quot; class=&quot;headerlink&quot; title=&quot;zookeeper / etcd 的区别&quot;&gt;&lt;/a&gt;zookeeper / etcd 的区别&lt;/h1&gt;&lt;p&gt;et</summary>
      
    
    
    
    <category term="工具调研" scheme="http://donnieyeh.github.io/categories/%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/"/>
    
    
    <category term="zookeeper" scheme="http://donnieyeh.github.io/tags/zookeeper/"/>
    
    <category term="etcd" scheme="http://donnieyeh.github.io/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>python 实现图片汉字识别</title>
    <link href="http://donnieyeh.github.io/2022/04/05/python%20%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B1%89%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://donnieyeh.github.io/2022/04/05/python%20%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B1%89%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2022-04-05T13:19:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心库使用"><a href="#核心库使用" class="headerlink" title="核心库使用"></a>核心库使用</h1><p>相关库：tesseract-ocr<br><strong><a href="https://github.com/tesseract-ocr">https://github.com/tesseract-ocr/</a></strong></p><p>核心库软件：tesseract<br>语言模块：tessdata，其中汉字的是 <code>chi_sim</code></p><p>步骤：</p><ol><li>下载安装核心库，自己编译太麻烦了，直接下载安装包</li><li>下载汉字模块：<code>chi_sim.traineddata</code>、<code>chi_sim_vert.traineddata</code><ol><li>放到 tresseract根目录/tessdata/下</li></ol></li><li>命令行测试：tesseract -v</li><li>图片识别：<code>tesseract 输入文件 输出路径 -l 解析使用到的语言模块</code><ol><li>例：<code>tesseract E://figures/other/timg.jpg E://figures/other/timg.txt -l chi_sim</code></li></ol></li></ol><p>核心库已经能正常使用，接下来安装python相关库。</p><h1 id="安装python-依赖"><a href="#安装python-依赖" class="headerlink" title="安装python 依赖"></a>安装python 依赖</h1><ol><li>安装 tesseract api：<code>pip install pytesseract</code></li><li>安装图片处理模块：<code>pip install Pillow</code></li><li>测试实践：<pre><code class="hljs python"><span class="hljs-keyword">import</span> pytesseract<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Imagepytesseract.pytesseract.tesseract_cmd = <span class="hljs-string">&#x27;C://Program Files (x86)/Tesseract-OCR/tesseract.exe&#x27;</span>text = pytesseract.image_to_string(Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E://figures/other/poems.jpg&#x27;</span>),lang=<span class="hljs-string">&#x27;chi_sim&#x27;</span>)<span class="hljs-built_in">print</span>(text)</code></pre></li></ol><h1 id="提升识别度（实践）"><a href="#提升识别度（实践）" class="headerlink" title="提升识别度（实践）"></a>提升识别度（实践）</h1><p>对于提升识别度，官方有一个较全面的指导，点击<a href="https://github.com/tesseract-ocr/tessdoc/blob/main/ImproveQuality.md">链接</a>查看<br>经实践，想要提升识别度，提升图片的分辨率是最简单直接有效的方式。建议图片的分辨率转换到300以上，再走tesseract进行处理。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/T_maker/article/details/82622447">python 5行代码实现图片中文字识别_T_maker的博客-CSDN博客_文字识别python代码实现</a></li><li><a href="https://blog.51cto.com/u_12139363/3025427">python ocr图片中汉字识别【图文】_gisoracleplus_51CTO博客</a></li></ul><p>待参考：</p><ul><li><a href="http://3ms.huawei.com/km/blogs/details/11393875">python——识别图片中的文字 - 王耀的博客 (huawei.com)</a></li><li><a href="http://3ms.huawei.com/km/blogs/details/9519567">通过Tesseract OCR识别扫描件PDF - 高文光的博客 (huawei.com)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;核心库使用&quot;&gt;&lt;a href=&quot;#核心库使用&quot; class=&quot;headerlink&quot; title=&quot;核心库使用&quot;&gt;&lt;/a&gt;核心库使用&lt;/h1&gt;&lt;p&gt;相关库：tesseract-ocr&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/t</summary>
      
    
    
    
    
    <category term="python" scheme="http://donnieyeh.github.io/tags/python/"/>
    
    <category term="ocr" scheme="http://donnieyeh.github.io/tags/ocr/"/>
    
  </entry>
  
  <entry>
    <title>apache common-lang3 DateUtils使用</title>
    <link href="http://donnieyeh.github.io/2022/04/05/apache%20common-lang3%20DateUtils%E4%BD%BF%E7%94%A8/"/>
    <id>http://donnieyeh.github.io/2022/04/05/apache%20common-lang3%20DateUtils%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-05T13:17:00.000Z</published>
    <updated>2022-09-17T09:51:31.026Z</updated>
    
    <content type="html"><![CDATA[<ul><li>isSameDay</li><li>parseDate：传入多个模板，直到匹配其中一个就可以，若全不匹配则抛出异常</li><li>addXXX</li><li>setXXX</li><li>toCalendar(date)</li><li>round：其注释描述的<a href="https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%97%B6%E5%88%B6">夏时制</a>（daylight time），只针对特定timezone的国家，对我们没影响</li><li>truncate：裁剪尾部</li><li>ceiling：跟truncate一样，但是会向上对齐</li><li>getFragmentInXXX：裁剪头部，跟truncate相反</li><li>truncatedEquals：两日期裁剪后对比，可以达到和isSameDay一样的效果</li><li>truncatedCompareTo：两日期裁剪后对比</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;isSameDay&lt;/li&gt;
&lt;li&gt;parseDate：传入多个模板，直到匹配其中一个就可以，若全不匹配则抛出异常&lt;/li&gt;
&lt;li&gt;addXXX&lt;/li&gt;
&lt;li&gt;setXXX&lt;/li&gt;
&lt;li&gt;toCalendar(date)&lt;/li&gt;
&lt;li&gt;round</summary>
      
    
    
    
    <category term="apache生态" scheme="http://donnieyeh.github.io/categories/apache%E7%94%9F%E6%80%81/"/>
    
    
    <category term="apache" scheme="http://donnieyeh.github.io/tags/apache/"/>
    
    <category term="使用手册" scheme="http://donnieyeh.github.io/tags/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>what does &quot;TCP segment of a reassembled PDU&quot; mean?</title>
    <link href="http://donnieyeh.github.io/2022/04/05/TCP%20segment%20of%20a%20reassembled%20PDU/"/>
    <id>http://donnieyeh.github.io/2022/04/05/TCP%20segment%20of%20a%20reassembled%20PDU/</id>
    <published>2022-04-05T13:06:00.000Z</published>
    <updated>2022-09-17T09:51:31.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="what-does-“TCP-segment-of-a-reassembled-PDU”-mean"><a href="#what-does-“TCP-segment-of-a-reassembled-PDU”-mean" class="headerlink" title="what does “TCP segment of a reassembled PDU” mean?"></a>what does “TCP segment of a reassembled PDU” mean?</h3><p>wireshark抓TCP包抓到<code>&quot;TCP segment of a reassembled PDU&quot;</code>，表示该TCP包是被分片了的，被分片的理由是因为发送方的原数据太大，当原数据长度超过了双方协商的<code>MSS</code>值，就会将数据进行TCP分片。</p><pre><code>注意与IP层切片参数`MTU`区分。</code></pre><p>当使用wireshark抓包时，有以下分辨方法</p><ol><li>若多个TCP包作为一个大段数据的分片进行传输，它们的ACK会是一样的，这很好分辨</li><li>或者点开任意分片的数据包查看内容，里面会出现诸如<code>[Reassembled PDU in frame: 9]</code>的信息，表示这些分片将在9号记录中整合。此时跳到9号记录，可以看到<code>[3 Reassembled TCP Segments (2782 bytes): #6(1306), #7(1360), #9(116)]</code>这样的描述，表示这段完整的数据由6、7、9号记录整合而成。</li></ol><p>参考文献：</p><ul><li><a href="https://www.cnblogs.com/tomato0906/articles/3991388.html">TCP segment of a reassembled PDU - 小西红柿 - 博客园 (cnblogs.com)</a></li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>MTU全程最大传输单元，相当于划了一条红线。TCP的MSS将基于MTU来计算获得。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;what-does-“TCP-segment-of-a-reassembled-PDU”-mean&quot;&gt;&lt;a href=&quot;#what-does-“TCP-segment-of-a-reassembled-PDU”-mean&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="网络" scheme="http://donnieyeh.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://donnieyeh.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>如何在一台机器管理两个github账号</title>
    <link href="http://donnieyeh.github.io/2022/03/23/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%AE%A1%E7%90%86%E4%B8%A4%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/"/>
    <id>http://donnieyeh.github.io/2022/03/23/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%AE%A1%E7%90%86%E4%B8%A4%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/</id>
    <published>2022-03-23T14:14:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题的背景比较特殊，不是每个人都会遇到</p><p>比如你和你的对象都有github账号，而且两人偶尔会用同一台电脑push东西，就会遇到这种问题</p><p>现假如我要在本机维护两套github账号，一个是donnie，一个是alpha</p><h1 id="一-创建密钥对"><a href="#一-创建密钥对" class="headerlink" title="一. 创建密钥对"></a>一. 创建密钥对</h1><p>先用命令创建各自对应的密钥对，按着步骤走，密钥存储的文件名要各自命名</p><pre><code class="hljs bash">ssh-keygen</code></pre><p>此时两个账号的密钥对存放到了<code>~/.ssh/</code>目录下了</p><h1 id="二-配置pubKey到GitHub账号下"><a href="#二-配置pubKey到GitHub账号下" class="headerlink" title="二. 配置pubKey到GitHub账号下"></a>二. 配置pubKey到GitHub账号下</h1><p>在本例中，会把<code>~/.ssh/id_rsa_alpha.pub</code>里的公钥配到<code>alpha</code>的GitHub账号下；<code>~/.ssh/id_rsa_donnie.pub</code>里的公钥配置到donnie的GitHub账号下</p><h1 id="三-配置ssh-config"><a href="#三-配置ssh-config" class="headerlink" title="三. 配置ssh config"></a>三. 配置ssh config</h1><p>创建<code>~/.ssh/config</code>文件，为每个账号配置如下内容</p><pre><code class="hljs crmsh"><span class="hljs-comment"># donnie </span>Host donnieHostName github.com<span class="hljs-keyword">User</span> <span class="hljs-title">git</span>IdentityFile ~/.ssh/id_rsa_donnie<span class="hljs-comment"># alpha</span>Host alphaHostName github.com<span class="hljs-keyword">User</span> <span class="hljs-title">git</span>IdentityFile ~/.ssh/id_rsa_alpha</code></pre><p>配置完后可以使用命令<code>ssh -T git@$&#123;Host&#125;</code>验证效果，例：</p><pre><code class="hljs bash">ssh -T git@donniessh -T git@alpha</code></pre><p>出现以下响应代表配置成功了</p><pre><code class="hljs ada">Hi xxx! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.</code></pre><h1 id="四-修改提交人信息"><a href="#四-修改提交人信息" class="headerlink" title="四. 修改提交人信息"></a>四. 修改提交人信息</h1><p>由于一台机器有两个GitHub账号使用，所以不能配置全局提交人，不然提交信息就乱套了。</p><p>首先删除全局配置：</p><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> <span class="hljs-string">&#x27;user.name&#x27;</span>git config --global --<span class="hljs-built_in">unset</span> <span class="hljs-string">&#x27;user.email&#x27;</span></code></pre><p>然后再在各自的git仓库设置本地配置：</p><pre><code class="hljs bash">git config user.email xxx@gmail.comgit config user.name xxx</code></pre><h1 id="五-将远程仓库地址与账号配置进行关联"><a href="#五-将远程仓库地址与账号配置进行关联" class="headerlink" title="五. 将远程仓库地址与账号配置进行关联"></a>五. 将远程仓库地址与账号配置进行关联</h1><p>假如原仓库地址为：<br><code>git@github.com:donnieYeh/picCrawler.git</code><br>或<br><code>https://github.com/donnieYeh/picCrawler.git</code></p><p>则重新关联的远程仓库格式为：<br><code>git@$&#123;Host&#125;:donnieYeh/picCrawler.git</code></p><p>之后进行远程仓库操作，git会自动按照<code>config</code>文件中的配置把<code>$&#123;Host&#125;</code>映射成<code>$&#123;HostName&#125;</code>，而且会使用对应的私钥进行通信</p><h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><p>若已经有现成的拉下来的远程仓库，则修改远程仓库的地址：</p><pre><code class="hljs bash"><span class="hljs-comment"># 查看现有的关联</span>$ git remote -vorigin  https://github.com/donnieYeh/picCrawler.git (fetch)origin  https://github.com/donnieYeh/picCrawler.git (push)<span class="hljs-comment"># 先删除原先绑定的地址</span>$ git remote remove origin<span class="hljs-comment"># 再重新添加 </span>$ git remote add origin git@donnie:donnieYeh/picCrawler.git</code></pre><p>若是新clone的仓库，自行手动把clone地址的<code>github.com</code>改成自己的<code>$&#123;Host&#125;</code>：</p><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@donnie:donnieYeh/picCrawler.git</code></pre><p>之后就能正常的进行仓库的各种管理操作啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个问题的背景比较特殊，不是每个人都会遇到&lt;/p&gt;
&lt;p&gt;比如你和你的对象都有github账号，而且两人偶尔会用同一台电脑push东西，就会遇到这种问题&lt;/p&gt;
&lt;p&gt;现假如我要在本机维护两套github账号，一个是donnie，一个是alpha&lt;/p&gt;
&lt;h1 id=&quot;一</summary>
      
    
    
    
    <category term="日常经验" scheme="http://donnieyeh.github.io/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="github" scheme="http://donnieyeh.github.io/tags/github/"/>
    
    <category term="ssh" scheme="http://donnieyeh.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>《java并发编程实战》读书笔记</title>
    <link href="http://donnieyeh.github.io/2022/03/10/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://donnieyeh.github.io/2022/03/10/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-10T13:16:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<p>书籍：《java concurrency in practice》英文原版<br>作者：Brian Goetz</p><p><strong>2.1</strong><br>线程安全如何定义？</p><p>首先，“线程安全”针对的对象是java的类。通常是描述“某个类是否线程安全”。<br>其次，一个类是“线程安全”，意味着它不需要使用任何“同步”、“协调”的代码就能在多个线程内正常运行<br>由此可知，只有“非线程安全”的类，才需要借助“同步”工具进行辅助</p><blockquote><p>我们很难理解线程安全的概念，是由于缺乏一个清晰精准的定义，而“精准”意味着class必须要遵循它的规范。一个好的规范定义了约束对象状态的不变量(invariants)和描述其操作效果的后置条件(postconditions)。</p></blockquote><p>说人话就是：书中给与”线程安全”的定义是：一个类是线程安全的话，那它必须保证在多线程操作下，它的invariants保持不变，而且操作结果符合给定的条件。</p><p>举个例子，”因素分解servlet缓存”例子中，请求入参的<strong>lastNumber</strong>和计算出来的<strong>lastFactors</strong>，组成了一个不变量（invariant），就是无论如何操作，用lastNumber在缓存取得的值一定与计算出来的lastFactors的一样。此处可见一个invariant可由多个相关联的state组成</p><p><strong>2.1.1</strong><br>无状态的类总是线程安全的。</p><p><strong>2.2</strong><br>通过了一个”counter++”的例子，解释了什么叫有状态，且有状态是线程不安全的。因为“counter”的操作包含了”读、改、写“三步，在多线程中这种操作并不是原子的。这种情况叫做”竞态（race condition）“</p><p><strong>2.2.1</strong><br>通过了”两人相约星巴克”的例子，展示了竞态的问题。简单来说就是：你观察某个条件为ture，当你基于这个观测来行动的时候，在观测到行动的这段时间内系统的状态已经发生了改变。这种竞态问题叫做“<strong>检查后行动（check-then-act）</strong>”</p><p><strong>2.2.2</strong><br>通过“懒初始化（lazy initialization）”例子来展示了代码层面的“检查后行动”问题。同时揭示了“counter”问题属于另一种竞态问题：“<strong>读、改、写（Read-modify-write）</strong>”。还举了些例子也会有这种问题，诸如：注册器、id生成器</p><p><strong>2.2.3</strong><br>把”检查后行动“和”读、改、写“这两种竞态问题概括为”<strong>复合操作（compound actions）</strong>”。而“复合操作”必须保证<strong>原子性</strong>。介绍了现成的”线程安全类”：Atomic*，用于解决“读改写”问题。同时作者建议多使用现成的“线程安全对象“来解决线程安全问题，而不是一上来就加锁。</p><p><strong>2.3</strong><br>通过了”对servlet的请求处理增加缓存”的例子，揭示了当程序有多个状态时，我们对每个状态都使用”线程安全对象”来维护，也是没法保证线程安全性的。因为这多个状态是相互关注的，为了保护状态的一致性，应当在原子性操作里更新相关联的变量。</p><p><strong>2.3.1</strong><br>介绍了保证多个状态原子性的手段：<strong>内置锁 synchronized</strong>，又称 intrinsic locks，monitor locks。</p><p>介绍了注解：@GuardedBy(“this”)，可以标注变量由哪个锁保护，仅用于提高可读性。</p><p>同时注明了过度的”线程安全”则会造成”性能问题”，</p><p><strong>2.3.2</strong><br>介绍了什么叫<strong>可重入</strong></p><p><strong>2.3.4</strong><br>当可变状态被多个线程访问时，要对所有的访问动作都加同一个锁，此时可以说这个状态被那个锁保护着。<br>每个可变的、共享的状态都应该只由一个锁来保护，我们应该让维护者明确的知道保护状态的是哪个锁。<br>一个常见的做法是，当一个对象封装了多个可变状态，这些状态通常会用封装它们的对象的内置锁来保护。<br>作者再次强调，只有可能被多线程访问的可变对象，才需要使用锁来保护。<br>一个invariant设计的多个state，应该由同一把锁来保护</p><p>总的来说，线程安全围绕着三种解决思路，按顺序优先使用：</p><ul><li>要么不共享</li><li>要么发布不可变对象，对此有三个要求</li><li>对象状态不可变（指操作）</li><li>对象里的引用需要使用final修饰</li><li>正确的构造（不暴露this）</li><li>最后他自己是要可见的（添加volatile修饰）</li><li>要么使用同步机制（synchronized 、 lock）</li></ul><p><strong>2.4</strong><br>最后还强调了并不是对每个方法都加锁就能解决竞态问题，因为有些需要原子性的复合操作需要涉及到多个方法，而且这样做反而有可能造成活跃性问题和性能问题。</p><p><strong>2.5</strong><br>作者说明了对整个方法加锁不是一种好的做法，会直接导致所有线程都排队执行该业务，称其为“弱并发”。并提供了一种思路，就是尽量把不影响”共享状态”的耗时操作移出同步块，让这些耗时操作可以利用到并发的优势。这个思路能让我们在简单性、安全性和并发性之间找到一个平衡。如何找到这种平衡，衡量同步块的规模，要求要有tradeoffs思维。有时候简单性和性能是互相矛盾的，在实现同步的时候要注意抵制”过早牺牲简单性来满足性能”的诱惑。要避免在漫长的计算过程中持有锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书籍：《java concurrency in practice》英文原版&lt;br&gt;作者：Brian Goetz&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1&lt;/strong&gt;&lt;br&gt;线程安全如何定义？&lt;/p&gt;
&lt;p&gt;首先，“线程安全”针对的对象是java的类。通常是描述“某个类是否</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://donnieyeh.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发编程" scheme="http://donnieyeh.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>github actions checkout失败问题</title>
    <link href="http://donnieyeh.github.io/2022/03/09/github%20actions%20checkout%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://donnieyeh.github.io/2022/03/09/github%20actions%20checkout%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-09T02:33:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>最近github主页项目，提交代码后CI流程失败。提示</p><pre><code class="hljs clean">##[error]fatal: could not read Username for <span class="hljs-string">&#x27;https://github.com&#x27;</span>: terminal prompts disabled</code></pre><p>以前都是跟着教程搭的github page 的CI配置，也没有认真了解过其原理，正好借着这次机会学习下。</p><h1 id="github-workflow工作流程："><a href="#github-workflow工作流程：" class="headerlink" title="github workflow工作流程："></a>github workflow工作流程：</h1><ol><li>编写一个CI流程配置文件，里面包含了：<ol><li>触发CI的条件</li><li>CI流程每一步的操作</li></ol></li><li>接下来比如从本地仓push代码到github，触发CI条件，然后github Actions 下的workflow就会按照CI配置文件对应的步骤进行相应的构建、部署操作。</li></ol><h1 id="CI配置文件的结构："><a href="#CI配置文件的结构：" class="headerlink" title="CI配置文件的结构："></a>CI配置文件的结构：</h1><ul><li><p>触发条件</p></li><li><p>执行的任务（可有多个）</p><ul><li>任务的每一步具体做什么</li></ul><p>  该配置通常为存放在项目根目录的 <code>.github/workflows/</code>下的yml文件</p></li></ul><h1 id="什么是actions？"><a href="#什么是actions？" class="headerlink" title="什么是actions？"></a>什么是actions？</h1><p>通常 “任务的每一步具体动作”，由 run 命令来执行。而github的actions市场，则提供了一系列封装好的通用动作库。用法则是使用uses 命令来引入。</p><h1 id="checkout-actions"><a href="#checkout-actions" class="headerlink" title="checkout actions"></a>checkout actions</h1><p>其中一个最流行的actions就是 actions/checkout@v2，可以在github.com/actions 页找到它，然后点进去查看相应文档。<br>该actions中的token选项，是指定PAT（Personal access token）</p><h1 id="什么是PAT"><a href="#什么是PAT" class="headerlink" title="什么是PAT"></a>什么是PAT</h1><p>Personal access token，个人账号范围（可以是组织范围）的一个token，在<code>个人Setting/developer settings</code>里面创建，该token用于在命令行操作个人github资源时鉴权用。在创建的时候，会让你选择该token的授权范围，以及指定token的过期时间，通常不建议设置永久期限，定期更换能减少token暴露风险。</p><h1 id="如何在actions中引入PAT"><a href="#如何在actions中引入PAT" class="headerlink" title="如何在actions中引入PAT"></a>如何在actions中引入PAT</h1><p>可以通过表达式<code>$&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125; </code>来引入，其中 secrets 是指<strong>项目setting</strong>中的secrets栏，PERSONAL_TOKEN是我们在secrets栏中创建的变量，创建的时候把上一步创建的PAT粘贴到变量值，之后即可以在actions中通过表达式<code>$&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125;</code> 引入环境变量PAT</p><h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>造成该异常的主要原因就是PAT过期了，解决办法就是重新生成一个PAT，并重新设置到项目的”secrets.自定义变量名”中，只要CI配置文件的变量名跟”secrets.自定义变量名”匹配，就能重新成功跑通actions/checkout@v2构建流程了。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://www.bilibili.com/video/BV1RE411R7Uy?from=search&seid=4861890920343690403&spm_id_from=333.337.0.0" title="【CICD】github新功能actions全方位讲解！！">【CICD】_github_新功能_actions_全方位讲解！！</a></li><li><a href="https://github.com/actions/checkout/issues/26">https://github.com/actions/checkout/issues/26</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h1&gt;&lt;p&gt;最近github主页项目，提交代码后CI流程失败。提示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs clean&quot;&gt;##[e</summary>
      
    
    
    
    
    <category term="CI" scheme="http://donnieyeh.github.io/tags/CI/"/>
    
    <category term="github" scheme="http://donnieyeh.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>张执中——说服力（1）</title>
    <link href="http://donnieyeh.github.io/2022/02/27/%E5%BC%A0%E6%89%A7%E4%B8%AD%E2%80%94%E2%80%94%E8%AF%B4%E6%9C%8D%E5%8A%9B%EF%BC%881%EF%BC%89/"/>
    <id>http://donnieyeh.github.io/2022/02/27/%E5%BC%A0%E6%89%A7%E4%B8%AD%E2%80%94%E2%80%94%E8%AF%B4%E6%9C%8D%E5%8A%9B%EF%BC%881%EF%BC%89/</id>
    <published>2022-02-27T15:29:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>听了张执中的公开课，觉得颠覆了以前的很多观点，遂记录</p></blockquote><ul><li><p>每个人的看法都是其过往人生的总结</p></li><li><p>别说“你应该”，要说“我需要”</p></li></ul><p><strong>说教5典</strong></p><ol><li>你为什么不去试试呢                   <blockquote><p>—— 帮助别人复习反驳的理由</p></blockquote></li><li>我可以陪你去做<blockquote><p>—— 热心只会给人压力</p></blockquote></li><li>你有什么困难吗<blockquote><p>—— 你只是在想机会反驳对方</p></blockquote></li><li>当你这么样这么样做完以后，不会觉得很舒服吗<blockquote><p>—— 别告诉对方，他该有什么感觉</p></blockquote></li><li>我觉得你应该不是这种人，你可以做的更好<blockquote><p>—— 不要替我决定我是谁</p></blockquote></li></ol><ul><li><p>别问“为什么不”，要问“为什么要”</p></li><li><p>说教者的反面：点燃者（每个人都想改变，只是需要发觉和点燃！）</p></li></ul><p><strong>说教者总是以自己目的为出发点去控制他人，而不是去理解他人</strong></p><ul><li>你只看到了对方点炸鸡，却没看到对方点无糖可乐</li><li>你只看到了他平时不好好学习，却没看到他临时抱佛脚</li></ul><p>点燃句式</p><ol><li>咦，你为什么会提起xx？<blockquote><p>—— 针对既有行为/让对方找出自己的理由</p></blockquote></li><li>这理由，真有那么重要吗？<blockquote><p>—— 让他为自己的理由辩护</p></blockquote></li><li>没想到，你是在意这种事的人<blockquote><p>—— 让对方重新定义自己</p></blockquote></li></ol><p>综上：所有说服，本质上都是自我说服</p><p>不是找个说服他的理由，而是帮他找到说服自己的理由</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;听了张执中的公开课，觉得颠覆了以前的很多观点，遂记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个人的看法都是其过往人生的总结&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;别说“你应该”，要说“我需要”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="张执中——说服力" scheme="http://donnieyeh.github.io/categories/%E5%BC%A0%E6%89%A7%E4%B8%AD%E2%80%94%E2%80%94%E8%AF%B4%E6%9C%8D%E5%8A%9B/"/>
    
    
    <category term="笔记" scheme="http://donnieyeh.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="公开课" scheme="http://donnieyeh.github.io/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>python爬取邮件订阅的pinterest热门图片</title>
    <link href="http://donnieyeh.github.io/2022/02/26/python%E7%88%AC%E5%8F%96%E9%82%AE%E4%BB%B6%E8%AE%A2%E9%98%85%E7%9A%84pinterest%E7%83%AD%E9%97%A8%E5%9B%BE%E7%89%87/"/>
    <id>http://donnieyeh.github.io/2022/02/26/python%E7%88%AC%E5%8F%96%E9%82%AE%E4%BB%B6%E8%AE%A2%E9%98%85%E7%9A%84pinterest%E7%83%AD%E9%97%A8%E5%9B%BE%E7%89%87/</id>
    <published>2022-02-26T16:31:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/donnieYeh/picCrawler">项目地址</a></p><h1 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h1><p>不知何时开始订阅了pinterest的消息，pinterest会不时的发送热门图片到邮箱里。无奈于平时没时间也懒得去翻阅，堆积了有900+封pinterest的邮件。在某个下午突发奇想：如果能自动爬取热门图片，然后在电视大屏里轮播，把平时不怎么开的电视利用起来，当成一块动态大画框，貌似也挺不错。然后这个工具就产生了。</p><h1 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h1><p>要实现我的想法，梳理了以下大致有如下几步：</p><ol><li>获取pinterest邮件记录</li><li>打开热图链接，获取网页dom</li><li>解析网页dom，获取图片地址列表</li><li>爬取图片，保存到本地目录</li><li>电视通过smb协议访问电脑的壁纸目录，轮播图片</li></ol><p>拓展：</p><ol><li>图片去重，hash值存db中</li></ol><h1 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h1><h2 id="获取pinterest邮件记录"><a href="#获取pinterest邮件记录" class="headerlink" title="获取pinterest邮件记录"></a>获取pinterest邮件记录</h2><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/35521803">https://zhuanlan.zhihu.com/p/35521803</a></li></ul><p>使用python读取outlook邮件</p><ul><li>需要关注每次只拉未处理过的邮件</li></ul><p>跟着文章操作，可以顺利获取到pinterest未读邮件列表，以及其内容</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.office.interop.outlook.items?view=outlook-pia">outlookAPI相关文档</a></p><h3 id="2种邮件处理策略"><a href="#2种邮件处理策略" class="headerlink" title="2种邮件处理策略"></a>2种邮件处理策略</h3><p>公共特征： </p><ul><li>sender address 包含 recommend</li><li>跳转链接带有 “utm_content” 字符串</li></ul><h4 id="图板推荐"><a href="#图板推荐" class="headerlink" title="图板推荐"></a>图板推荐</h4><p>特征：</p><ul><li>subject 包含“<strong>图板</strong>”二字</li><li>跳转到图板页，需要模拟浏览器动作以获取二级图片</li></ul><p>策略：</p><ul><li>图板的图我们可以只下载前20张</li></ul><h4 id="热门pin图"><a href="#热门pin图" class="headerlink" title="热门pin图"></a>热门pin图</h4><p>特征</p><ul><li>subject包含“pin图”二字</li><li>跳转到图片页，可直接获取图片链接</li></ul><hr><p>此处涉及到使用正则表达式过滤关键链接，相关操作参考：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> re// 匹配整串re.match// 搜索第一个匹配re.search// 搜索所有匹配re.findall</code></pre><h2 id="打开热图链接，获取网页dom"><a href="#打开热图链接，获取网页dom" class="headerlink" title="打开热图链接，获取网页dom"></a>打开热图链接，获取网页dom</h2><p>参考文章：</p><ul><li><a href="https://steam.oxxostudio.tw/category/python/spider/pinterest.html">https://steam.oxxostudio.tw/category/python/spider/pinterest.html</a></li><li><a href="https://www.selenium.dev/selenium/docs/api/py/index.html">selenium学习</a></li><li><a href="https://www.w3schools.com/xml/xpath_intro.asp">xpath学习</a></li><li><a href="https://www.w3schools.com/xml/xpath_syntax.asp">xpath语法手册</a></li><li><a href="https://blog.csdn.net/butthechi/article/details/80844330">https://blog.csdn.net/butthechi/article/details/80844330</a></li></ul><p>由于pinterest网页有个特性，就是每次只展示特定窗口范围的图片，在浏览器滚动过程中，前面的图片结点会消失，后面的图片结点会加载。所以没法一次性获取整个dom资源，需要模拟滚动网页，才能获取到完整的DOM。</p><p>这里使用selenium来实现模拟，需要了解一些前置知识：XPATH</p><h3 id="XPATH"><a href="#XPATH" class="headerlink" title="XPATH"></a>XPATH</h3><p>有7种结点类型：<br> element, attribute, text, namespace, processing-instruction, comment, and document nodes</p><ul><li>最上层的为 root Element node</li><li><code>&lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;</code> 中的<code> lang=&quot;en&quot;</code>为attribute node</li><li><code>&lt;author&gt;J K. Rowling&lt;/author&gt;</code>中的<code>J K. Rowling</code>为text node</li><li>atomic value 指的是没有子节点和父节点的node，如text node</li><li>Items 指的是 atomic values 或者 nodes</li><li>ancestors（祖先）结点指的是<strong>包括父节点</strong>的所有上级结点</li><li>descendants（子孙）结点指的是<strong>包括子节点</strong>的所有下级结点</li></ul><p>模糊匹配属性：<code>//tr[contains(@class,&#39;result&#39;)] # 得到所有class 包含result的语句</code></p><hr><p>python set 定义：<code>imgs = &#123;&#125;</code></p><h2 id="解析网页dom，获取图片地址列表"><a href="#解析网页dom，获取图片地址列表" class="headerlink" title="解析网页dom，获取图片地址列表"></a>解析网页dom，获取图片地址列表</h2><p>使用BeautifulSoup + 正则轻松搞定</p><h2 id="爬取图片，保存到本地目录"><a href="#爬取图片，保存到本地目录" class="headerlink" title="爬取图片，保存到本地目录"></a>爬取图片，保存到本地目录</h2><hr><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><ul><li>由于使用单线程处理，对pinterest服务器是友好的，以后考虑提升效率，或许会使用代理池+多线程抓取</li><li>后续考虑TB上看下有没有电子相框，这样连电视都不用开了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/donnieYeh/picCrawler&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;来由&quot;&gt;&lt;a href=&quot;#来由&quot; class=&quot;headerlink&quot; title=&quot;来由&quot;&gt;&lt;/a&gt;来由&lt;/h1&gt;&lt;p&gt;不知何时</summary>
      
    
    
    
    
    <category term="python" scheme="http://donnieyeh.github.io/tags/python/"/>
    
    <category term="爬虫" scheme="http://donnieyeh.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>PostMan自动生成鉴权参数</title>
    <link href="http://donnieyeh.github.io/2022/01/28/PostMan%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%89%B4%E6%9D%83%E5%8F%82%E6%95%B0/"/>
    <id>http://donnieyeh.github.io/2022/01/28/PostMan%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%89%B4%E6%9D%83%E5%8F%82%E6%95%B0/</id>
    <published>2022-01-28T06:50:00.000Z</published>
    <updated>2022-09-17T09:51:31.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工具版本：</p><ul><li>PostMan: 8.0.7</li><li>Crypto-js: 3.1.9</li></ul><p>我们通常联调的时候，有可能会需要协商好密钥，用于在API调用时加签和验签。由于签名是基于请求体和请求头动态生成的，postman预置静态参数的方式根本不能满足我们对效率的追求，然后我就捣鼓了一下用postman为每个请求动态生成鉴权参数，以此文章来记录过程中的经验心得。</p><p>postman中有个选项页叫做<code>Pre-request script</code>，顾名思义，它可以在请求前执行该脚本。它本质上就是个js脚本，而我们主要就是要在这里编写脚本生成所需数据。</p><h2 id="零、预研"><a href="#零、预研" class="headerlink" title="零、预研"></a>零、预研</h2><p>调查了一下找到了JS里好评率较高的密钥库<a href="https://github.com/brix/crypto-js">Crypto-js</a>，随便谷歌一个好用的CDN地址，我这里使用的是jsdelivr的源（jsdelivr真的太香了）。为了验证它好不好使，我习惯先用交互式编程研究下它的用法（使用ipython留下的习惯），最好的JS交互式界面当然就是Chrome了。</p><p>打开Chrome控制台，输入命令，引入密钥库。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);script.src = <span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js&quot;</span><span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].appendChild(script);</code></pre><p>简单找下，很容易找到它的主类是<code>CryptoJS</code></p><p>我这里需要用到密钥库里的HmacSHA256、Base64两个工具，通过摸索它的API，很快了解了用法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> key = foo<span class="hljs-keyword">var</span> message = bar<span class="hljs-keyword">var</span> sign = CryptoJS.HmacSHA256(<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-keyword">var</span> signenc = CryptoJS.enc.Base64.stringify(sign)</code></pre><pre><code>此处要注意一个大坑，由于CryptoJS生成的Sign是特别的数据结构，而不是纯粹的二进制，所以用chrome自带的base64工具（btoa、atob）是无法得到正确的编码的，总之别人工具库都给你准备好了那就直接用工具库里的Base64吧。</code></pre><p>然后用得到的签名跟服务器生成的签名作比对，或者直接调用API验证，验证成功，至此前期工作已经准备好。</p><h2 id="一、引入密钥库"><a href="#一、引入密钥库" class="headerlink" title="一、引入密钥库"></a>一、引入密钥库</h2><p>打开PostMan的 <code>Pre-request script</code> 界面，编写脚本，在脚本初始化阶段引入密钥库。</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(!pm.globals.has(<span class="hljs-string">&quot;cryptojs&quot;</span>))&#123; pm.sendRequest(<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> &#123; <span class="hljs-keyword">if</span> (!err) &#123; pm.globals.set(<span class="hljs-string">&quot;cryptojs&quot;</span>, res.text()) &#125;&#125;)&#125;<span class="hljs-built_in">eval</span>(pm.globals.get(<span class="hljs-string">&quot;cryptojs&quot;</span>));</code></pre><h2 id="二、构造鉴权数据"><a href="#二、构造鉴权数据" class="headerlink" title="二、构造鉴权数据"></a>二、构造鉴权数据</h2><p>先确定构造数据所需的关键元素，参考对接文档，用注释把步骤大致整理出来</p><pre><code class="hljs javascript"><span class="hljs-comment">// plaintext = httpmethod + RequestURI + http body</span><span class="hljs-comment">// key=AppSecret + Nonce + timestamp</span><span class="hljs-comment">// token=BASE64(HMAC_SHA256(plaintext, key))</span></code></pre><p>然后对着注释把代码补全</p><blockquote><p>有条件的都建议使用新版客户端，不建议用chrome插件。客户端会在编写脚本的时候有智能代码提醒，很方便。</p></blockquote><pre><code>1. 获取请求头使用 pm.request.headers2. 获取body使用 pm.request.url.getPath(true)，加true是指不按&#39;/&#39;切割路径</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// let plaintext = httpmethod+RequestURI+http body</span><span class="hljs-keyword">let</span> plaintext = <span class="hljs-string">&#x27;POST&#x27;</span>+pm.request.url.getPath(<span class="hljs-literal">true</span>)+pm.request.body.raw;<span class="hljs-comment">// key=AppSecret(主题服务器分配)+Nonce+timestamp</span><span class="hljs-keyword">let</span> appSecret = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<span class="hljs-keyword">let</span> key = appSecret+pm.request.headers.get(<span class="hljs-string">&quot;nonce&quot;</span>)+pm.request.headers.get(<span class="hljs-string">&quot;timestamp&quot;</span>);<span class="hljs-comment">// token=BASE64(HMAC_SHA256(plaintext, key))</span><span class="hljs-keyword">let</span> sign = CryptoJS.HmacSHA256(plaintext,key);<span class="hljs-keyword">let</span> signenc = CryptoJS.enc.Base64.stringify(sign);pm.collectionVariables.set(<span class="hljs-string">&quot;usertoken&quot;</span>, signenc);</code></pre><p>最后把构造好的<code>token</code>设置到环境变量中：<code>pm.collectionVariables.set(&quot;usertoken&quot;, signenc);</code></p><h2 id="三、引用鉴权参数"><a href="#三、引用鉴权参数" class="headerlink" title="三、引用鉴权参数"></a>三、引用鉴权参数</h2><p>在请求用例的Header中，就可以用PostMan的匹配字符来引用上一步放置到环境变量中的数据了。<br>![[Pasted image 20220128154749.png]]</p><p>之后就可以点击请求按钮验证结果了，此时无论我怎样的修改请求体，修改timestamp，都可以自行动态生成token了，舒畅~。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工具版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PostMan: 8.0.7&lt;/li&gt;
&lt;li&gt;Crypto-js: 3.1.9&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="效率人生" scheme="http://donnieyeh.github.io/categories/%E6%95%88%E7%8E%87%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="PostMan" scheme="http://donnieyeh.github.io/tags/PostMan/"/>
    
    <category term="测试" scheme="http://donnieyeh.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数字证书与安全协议</title>
    <link href="http://donnieyeh.github.io/2022/01/22/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
    <id>http://donnieyeh.github.io/2022/01/22/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-01-22T17:07:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="什么是是数字证书"><a href="#什么是是数字证书" class="headerlink" title="什么是是数字证书"></a>什么是是数字证书</h3><h4 id="数字身份"><a href="#数字身份" class="headerlink" title="数字身份"></a>数字身份</h4><p>数字身份的本质是一对秘钥，分别为公钥和私钥。</p><p>把数字身份比喻成一个证件，那么数字证书就是“身份认证机构”盖在证件上的一个章（即权威机构的背书）。没有背书的数字身份是没实际意义的。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="生活中"><a href="#生活中" class="headerlink" title="生活中"></a>生活中</h4><p>一切进行数据通信的地方都有可能会用到数字证书，如</p><ul><li>电子邮件</li><li>浏览网页</li><li>手机APP</li><li>科学上网</li></ul><h4 id="开发中"><a href="#开发中" class="headerlink" title="开发中"></a>开发中</h4><ul><li>工具抓包：fiddler</li></ul><h3 id="为什么要有数字证书"><a href="#为什么要有数字证书" class="headerlink" title="为什么要有数字证书"></a>为什么要有数字证书</h3><h4 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h4><p>下面展示了网络安全通信是如何逐步衍生出数字证书的。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B1.gif"></p><p>第一阶段，双方协商好对称密钥，之后的通信都使用对称密钥对明文进行加密解密操作。但是这个阶段的缺点是双方需要提前约定好密钥，该模式无法满足临时与陌生对象通信的需求。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B2.gif"><br>第二阶段，双方使用非对称秘钥通信，其中bob有一对公私钥，通信初始他会把公钥提供给alice，alice使用该公钥来加密明文。由于密文只有bob的私钥能解密，所以在通信过程中其他人是无法解开密文的（未被篡改的情况下）。<br>该阶段的主要问题在于非对称加密明文的性能相较对称加密性能要差很多。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B3.gif"><br>第三阶段，alice使用了临时生成的<strong>对称密钥</strong>来加密明文，然后再用bob的公钥加密<strong>对称密钥</strong>，然后把<strong>被加密的明文</strong>和<strong>被加密的密钥</strong>发送给bob，由于<strong>被加密的密钥</strong>只能用bob的私钥解密，所以过程是安全的（未被篡改的情况下），同时<strong>对称密钥</strong>加密明文保证了性能。但这个过程真的没缺陷了吗？我们看看以下场景：<br><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B3-%E7%BC%BA%E9%99%B7.gif"><br>该过程中，中间人可以拦截bob发给alice的公钥，同时发送自己的公钥给alice，伪装成bob。之后的通信过程中，alice使用伪装的公钥加密出的密文，自然能被中间人破解。更有甚者中间人可以伪造一份欺骗性的报文发给bob。该过程省略了alice用自己私钥加签的过程，本质上一样是不安全的，中间人既然能伪造bob给alice的公钥，当然也能伪造alice给bob的公钥，那么这个过程中的签名自然也是可以伪造的。<br><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B4.gif"><br>上一阶段的核心问题在于bob的公钥在传输过程中被篡改了，对于alice来说bob的公钥是不可信的。那么解决了公钥的信任问题，这个过程就安全了。</p><p>第四阶段：这一阶段bob把自己的公钥封装到数字证书里。在之后的通信初始阶段bob会先把数字证书发给alice，alice去CA机构验证数字证书的合法性，若验证通过，则代表bob的数字证书是可信的，那么证书里面的公钥自然也是可信的。这样就顺利的解决了公钥的信任问题。</p><h3 id="为什么数字证书的认证过程是可信的"><a href="#为什么数字证书的认证过程是可信的" class="headerlink" title="为什么数字证书的认证过程是可信的"></a>为什么数字证书的认证过程是可信的</h3><p><img src="/images/%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E5%8F%AF%E4%BF%A1.gif"><br>在服务域名上线之前，会先用自己的公钥生成一份证书签名请求文件（certificate sign request，csr），可以理解为填了份带有公钥的申请表单，发给CA机构，然后CA机构会把这份表单里面的关键信息（包括公钥、服务域名、所属机构等）提取成摘要，用自己的私钥进行加签。然后把签名和关键信息，输出到正式的数据结构中，形成了数字证书，再把这个数字证书发送给服务方，这个过程就叫做证书的签发。</p><p>服务器得到了具有公证力的证书，上线新的域名。随后客户端就可以访问该域名对服务器发起握手，握手阶段服务器会把证书发给客户端，客户端在证书里找到它的签发机构，遂去获取签发机构的证书。此时我们注意服务器证书的签名是用CA机构的私钥加签的，理所当然可以用CA机构的公钥进行验签。如果验签成功，则说明了服务器的证书是可信的。</p><p>可是此时出现了新的问题，我们通过这个流程可以验证服务器证书的有效性，前提是CA机构的证书也是合法的，但如何保证CA证书不会被篡改呢？</p><p>同理我们的客户端可以走相同的流程，去获取CA机构的上级机构的证书，来验证CA证书的有效性，这样就形成了一个递归验证链。这个递归链是有边界的，它的边界就是<strong>根证书。</strong></p><p><img src="/images/Pasted%20image%2020220123125102.png"></p><p>由上图的信任链我们可以看出验证操作会一直递归到根证书。这里的关键就在于根证书是内置于我们操作系统本地的，那么在获取根证书的时候就不想要经过网络。若不经过网络，则就不存在被中间人攻击的风险。所以，到根证书为止，就可以证明整个信任链是可信的了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>加密技术的存在是为了保障通信信息不被第三方窃取，保证信息的安全性，该技术甚至可以追溯到3900年前的古希腊。但是随着互联网尤其是无线网络的发展，出现了一种新的场景，就是通信双方节点，通常都是需要临时交换密钥来进行安全通信。伴随着这种场景，新的攻击手段也应运而生，那就是中间人攻击，简单来说就是中间人可以伪装成你的通信对象，交换非法秘钥，以达到监听窃取、篡改信息的目的。</p><p>而<strong>数字证书</strong>就是为了解决<strong>信任危机</strong>而的产生。<br>目前大部分数字证书都采用 x509第三版数据结构<br>数字证书是实现<strong>安全协议</strong>过程的基石。</p><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p>为什么要有中间证书？<br>1.根证书的私钥安全性隔离<br>A.降低替换私钥成本<br>B.降低暴露私钥风险<br>2.根证书的操作效率无法满足要求</p><p>浏览器如何获取中间证书？<br>一般来说，服务器会将中间证书一并发送过来。也就是说，当我们访问某个网站时，收到的不是一个证书，而是一系列证书。<br>当然，这不是强制要求，在服务器不发送的情况下，浏览器也会使用一些方法去定位中间证书，比如缓存之前下载过的证书<br>证书文件中的 Authority Information Access (AIA) Extension 里面含有上级证书的相关信息，浏览器可以使用这个信息去下载上级证书</p><h3 id="PKI-Public-Key-Infrastructure-体系"><a href="#PKI-Public-Key-Infrastructure-体系" class="headerlink" title="PKI(Public Key Infrastructure)体系"></a>PKI(Public Key Infrastructure)体系</h3><p>当我们掌握了证书的理论性知识后。需要有一套完整的创建, 管理, 分发, 使用, 存储 和 吊销 证书的体系，这就是PKI体系。该体系里完整的囊括了所需的指导性工具，包括规则、策略、相关软硬件、和流程。该体系并不由某一家制定，而是互联网组织共同参与，其中做出过贡献的组织包括但不限于 ITU-T（X.500~X.599系列）、IETF、RSA实验室（RSA Security，PKCS系列）、ISO。综上所述，PKI可以认为是一系列的规范和标准。而为了实现安全基础服务目的的技术都可称为PKI。## 安全协议</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><h4 id="TLS属于哪层协议？"><a href="#TLS属于哪层协议？" class="headerlink" title="TLS属于哪层协议？"></a>TLS属于哪层协议？</h4><p>TLS所处的协议层如下：<br>数据帧{ IP层{ TCP层{ <strong>TLS层{</strong> 应用层{} <strong>}</strong> } } }</p><p>可见TLS介于传输层（TCP）和应用层之间。</p><p>如果把网络协议想象成一个纸团，协议之间的嵌套就像一张纸包住另一个纸团一样。最里面的一层就是应用层协议，如HTTP。而网络报文的传输过程中，任何人能够截获这个纸团，并层层剥开，但是如果没有相应的秘钥，是没法剥开TLS这一层的，也就没法看到里面的HTTP报文。<br><img src="/images/Pasted%20image%2020220123093321.png"></p><h4 id="SSL和TLS的关系"><a href="#SSL和TLS的关系" class="headerlink" title="SSL和TLS的关系"></a>SSL和TLS的关系</h4><p>SSL是网景制定的，TLS是IETF指定的。TLS1.0建立在SSL3.0基础之上，可以理解为SSL3.1。由于习惯原因，现在很多对安全层依旧沿用SSL的称呼，但实际上已经使用的是TLS的技术了。</p><p>网景是一家传说级的公司，Mozilla（火狐前身）和JavaScript都诞生于这家公司。<br>而IETF是一个开放的标准组织，网络上随处可见的RFC标准就是出自他们。</p><p><img src="/images/Pasted%20image%2020220123093824.png"></p><h4 id="TLS-的运作过程"><a href="#TLS-的运作过程" class="headerlink" title="TLS 的运作过程"></a>TLS 的运作过程</h4><p><img src="/images/Pasted%20image%2020220123121739.png"></p><h4 id="TLS的关键阶段"><a href="#TLS的关键阶段" class="headerlink" title="TLS的关键阶段"></a>TLS的关键阶段</h4><p>握手阶段是TLS的关键<br>握手过程，主要就是双方交换公共参数，生成对称密钥，用于加密通信<br>秘钥交换算法（key exchange）：</p><ul><li>RSA based key exchange</li><li>DH(Diffie-Hellman) based key exchange</li></ul><h4 id="交换秘钥过程"><a href="#交换秘钥过程" class="headerlink" title="交换秘钥过程"></a>交换秘钥过程</h4><p>HTTPS常用的密钥交换算法有两种，分别是<code>RSA</code>和<code>ECDHE</code><br>由于RSA不具备向前安全性质，现在大部分服务器不会使用它来交换秘钥<br>每个通信过程的秘钥没有关系，相互独立，才能保证 <strong>「前向安全」</strong>。<br><code>DH</code>作为<code>ECDHE</code>的基础，详细介绍参考[DH]一节<br><code>ECDHE</code>的演进路线基本是这样的：<code>DH</code>-&gt; <code>DHE</code>-&gt;<code>ECDHE</code>，</p><h4 id="向前安全性"><a href="#向前安全性" class="headerlink" title="向前安全性"></a>向前安全性</h4><p><strong>前向安全性</strong>或<strong>前向</strong>保密<strong>性</strong>（英语：Forward Secrecy，缩写：FS），有时也被称为完美<strong>前向安全</strong>（英语：Perfect Forward Secrecy，缩写：PFS），<strong>是</strong>密码学中通讯协议的<strong>安全</strong>属性，指的<strong>是</strong>长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p><h3 id="两种密钥交换模式"><a href="#两种密钥交换模式" class="headerlink" title="两种密钥交换模式"></a>两种密钥交换模式</h3><h4 id="RSA-Base"><a href="#RSA-Base" class="headerlink" title="RSA Base"></a>RSA Base</h4><p>流程<br>从浏览器请求HTTPS，到渲染数据的整个过程</p><ul><li>Client Hello</li><li>随机数、算法套件</li><li>Server Hello</li><li>随机数、选定算法、公钥</li><li>Certificate</li><li>验证身份的项目：</li><li>涉及证书链的有效期</li><li>涉及证书链的签名</li></ul><p> 举例子，证书验证不通过的情况<br> <img src="/images/Pasted%20image%2020220123121951.png"></p><ul><li>Server Hello Done</li><li>Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message</li><li>服务端 Change Cipher Spec, Encrypted Handshake Message</li><li>加密通信</li></ul><p>premaster key、masterKey的作用<br><img src="/images/Pasted%20image%2020220123122022.png"></p><h4 id="DH-Base"><a href="#DH-Base" class="headerlink" title="DH Base"></a>DH Base</h4><h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>DH算法的原理可以参考这一篇文章：<a href="https://bbs.huaweicloud.com/blogs/detail/273779">为了搞懂 HTTPS，我把大学的数学书拿了出来。。。)</a></p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>要注意dh算法本身并不能防范中间人攻击，中间人可以通过分别对双方进行DH密钥交换进行攻击，所以DH实际需要配合身份认证机制才能安全工作。DH两种工作方式：</p><ol><li>Fixed Diffie-Hellman：直接把DH公钥固化到服务方证书里，和RSA一样不具备向前安全性</li><li>Ephemeral Diffie-Hellman (简称为DHE)：服务方使用动态DH公钥，只是会对公钥进行签名</li></ol><p>在DH模式中，数字证书，不是用于生成通信用的秘钥，而是单纯用于双方认证身份（这个是大部分人很容易理解错的地方）</p><h4 id="演进过程-1"><a href="#演进过程-1" class="headerlink" title="演进过程"></a>演进过程</h4><p>以下过程基于网络交换秘钥场景</p><table><thead><tr><th>技术</th><th>性能</th><th>防监听（未篡改）</th><th>防篡改</th><th>向前安全</th></tr></thead><tbody><tr><td>对称加密{原文}</td><td>√</td><td>x</td><td>x</td><td>x</td></tr><tr><td>非对称加密{原文}</td><td>x</td><td>√</td><td>x</td><td>x</td></tr><tr><td>非对称{密钥}</td><td>√</td><td>√</td><td>x</td><td>x</td></tr><tr><td>非对称{密钥}+公钥认证</td><td>√</td><td>√</td><td>√</td><td>x</td></tr><tr><td>临时DH公钥+公钥认证</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="TLS1-3介绍"><a href="#TLS1-3介绍" class="headerlink" title="TLS1.3介绍"></a>TLS1.3介绍</h3><p>TLS 1.3 是时隔九年对 TLS 1.2 等之前版本的新升级，也是迄今为止改动最大的一次。针对目前已知的安全威胁，IETF（Internet Engineering Task Force，互联网工程任务组） 正在制定 TLS 1.3 的新标准，使其有望成为有史以来最安全，但也最复杂的 TLS 协议。<br>![[Pasted image 20220112144654.png]]</p><p>v1.3 优点：<br>1.握手只需要 1TTR，性能更好<br>2.只支持向前安全的算法，安全性更高</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>相关配置</p><ul><li>internet属性<br>如何查看一个网站使用的TLS版本：f12-&gt;security<br><img src="/images/Pasted%20image%2020220123122235.png"></li></ul><h4 id="证书主要生命周期"><a href="#证书主要生命周期" class="headerlink" title="证书主要生命周期"></a>证书主要生命周期</h4><p>常见的证书管理工具有两种，一个是jdk自带的keytool；一个是开源项目openssl<br>以下命令均可以加上 –help 查看帮助，示例：<code>keytool –genkeypair -help</code></p><table><thead><tr><th>阶段</th><th>Keytool相关命令</th><th>Openssl相关命令</th></tr></thead><tbody><tr><td>生成密钥对</td><td>-genkeypair</td><td>genrsa</td></tr><tr><td>生成证书请求</td><td>-certreq</td><td>req</td></tr><tr><td>签发证书</td><td>-gencert</td><td>X509</td></tr><tr><td>管理密钥库</td><td>-list, -importkeystore</td><td>pkcs12 -nodes -nocerts</td></tr><tr><td>使用证书</td><td></td><td></td></tr><tr><td>吊销</td><td></td><td></td></tr></tbody></table><h5 id="keytool实践"><a href="#keytool实践" class="headerlink" title="keytool实践"></a>keytool实践</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成根证书，存储到密钥库caroot.ks</span>keytool -genkeypair -alias caroot -keyalg RSA -keystore caroot.ks -storepass aaaaaa<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 根据提示，把密钥库转换成pkcs12</span>keytool -importkeystore -srckeystore caroot.ks -destkeystore caroot.p12 -deststoretype pkcs12<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 这里我们可以把keytool命令做个别名，方便调用（可选）</span>alias mykt=&#x27;keytool -keystore $ksfile -storepass $kspass $*&#x27;export ksfile=caroot.p12 &amp;&amp; export kspass=aaaaaa<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 生成服务证书，存储到密钥库server.p12</span>keytool -genkeypair -alias server -keyalg rsa -keysize 1024 -keystore server.p12 -storepass aaaaaa -storetype pkcs12<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 生成服务证书签名申请</span>keytool -certreq -alias server -file server.csr -storepass aaaaaa -keystore server.p12<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 使用ca根证书签发服务证书</span>keytool -gencert -infile server.csr -outfile server.crt -alias caroot -keystore caroot.p12 -storepass aaaaaa -ext san=dns:www.mycompany.com,dns:mycompany.com<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 此时我们发现ca签发的证书不可信，导出根证书并安装到本地即可解决</span>keytool -exportcert -alias caroot -file caroot.crt -keystore caroot.p12 -storepass aaaaaa</code></pre><h4 id="验证der编码和base64编码的区别"><a href="#验证der编码和base64编码的区别" class="headerlink" title="验证der编码和base64编码的区别"></a>验证der编码和base64编码的区别</h4><p>der编码           base64编码<br>直接导出证书  导出证书 -rfc<br>windows下可以点击证书复制到文件<br>相互转换：notepad++转base64</p><p>要在nginx中开启TLS，需要先生成两个文件，一个是代表公钥的服务证书文件（.pem），一个是私钥的文件（.key）。此处公钥可以直接用windows的证书工具导出，私钥需要用openssl导出。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 从密钥库中导出服务器私钥</span>openssl pkcs12 -in server.p12 -out server.key -nodes -nocerts</code></pre><pre><div class="caption"><span>config</span></div><code class="hljs nginx"><span class="hljs-section">server</span> &#123;   <span class="hljs-comment">#监听端口和域名  </span> <span class="hljs-attribute">listen</span>      <span class="hljs-number">443</span> ssl;   <span class="hljs-attribute">server_name</span>  localhost;   <span class="hljs-comment">#以下两个为证书文件  </span> <span class="hljs-attribute">ssl_certificate</span> D:/java/nginx-<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>/cert/server-p.pem;   <span class="hljs-attribute">ssl_certificate_key</span> D:/java/nginx-<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>/cert/server.key;   <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">1m</span>;   <span class="hljs-attribute">ssl_protocols</span> SSLv2 SSLv3 TLSv1.<span class="hljs-number">2</span>;   <span class="hljs-attribute">ssl_ciphers</span>    ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256:AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;   <span class="hljs-attribute">ssl_prefer_server_ciphers</span>  <span class="hljs-literal">on</span>;   <span class="hljs-comment">#location / &#123;  </span> <span class="hljs-comment">#root D:/nginx/portal;  </span> <span class="hljs-comment">#index index.html;  </span> <span class="hljs-comment">#&#125;</span> <span class="hljs-attribute">localtion</span> / &#123; <span class="hljs-attribute">proxy_pass</span> http://localhost:8899;<span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For $remote_addr; &#125;   &#125;  <span class="hljs-comment"># 访问80端口时转发到443端口，转为https访问  </span> <span class="hljs-section">server</span> &#123;   <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;   <span class="hljs-attribute">server_name</span>  localhost;   <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$host$request_uri;   &#125;</code></pre><h5 id="ERR-CERT-COMMON-NAME-INVALID错误"><a href="#ERR-CERT-COMMON-NAME-INVALID错误" class="headerlink" title="ERR_CERT_COMMON_NAME_INVALID错误"></a>ERR_CERT_COMMON_NAME_INVALID错误</h5><p>域名和Common Name 一致，chrome依然报错，该问题如何解决？<br>原因在于浏览器校验域名并不是从CN入手，而是检查x509的扩展字段SAN（subject alter name），所以只有加上该扩展字段，才能让浏览器认为网站是安全的。</p><p>针对keytool来说，有两个阶段可以加上该扩展字段：</p><ol><li>生成密钥对时</li><li>签发证书时</li></ol><p>扩展字段的指定方法参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html">keytool文档</a></p><p>如果是重新生成的证书未生效，需要清下浏览器缓存<br>chrome://net-internals/#hsts</p><p>若还是不行，看看是不是Nginx进程没清干净。</p><h4 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h4><ul><li>什么时候会进行数字证书认证</li><li>keytool -gencert -sigalg 有什么用</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="如何理解证书链"><a href="#如何理解证书链" class="headerlink" title="如何理解证书链"></a>如何理解证书链</h4><h4 id="RSA-vs-DSA"><a href="#RSA-vs-DSA" class="headerlink" title="RSA vs DSA"></a>RSA vs DSA</h4><p>这两个算法都是对称密钥算法，其中</p><ul><li>名称问题<br>RSA三位发明者的名字的缩写<br>DSA则是 Digital Signature Algorithm 的缩写</li><li>数学基础</li><li>RSA基于大数分解（两个素数的乘积）</li><li>DSA基于离散对数难题<h4 id="指纹和签名的区别"><a href="#指纹和签名的区别" class="headerlink" title="指纹和签名的区别"></a>指纹和签名的区别</h4>指纹只是证书上的散列。主要用于人工接收，检查证书是否为预定证书，比如 打电话给 CA认证机构 并说出指纹进行核对。 浏览器是通过签名来验证证书的有效性的，浏览器不会关注指纹。<h4 id="数字证书的数据结构"><a href="#数字证书的数据结构" class="headerlink" title="数字证书的数据结构"></a>数字证书的数据结构</h4>CN(Common Name名字与姓氏)<br>OU(Organization Unit组织单位名称)<br>O(Organization组织名称)<br>L(Locality城市或区域名称)<br>ST(State州或省份名称)<br>C(Country国家名称）</li></ul><p><img src="/images/Pasted%20image%2020220123125851.png"><br>详细参考： <a href="https://www.cem.me/20150209-cert-binaries-4.html">https://www.cem.me/20150209-cert-binaries-4.html</a></p><ul><li>头（4byte）<ul><li>body(4byte + len)</li><li>signalg(2byte + len(13))</li><li>sign(5byte+ len)</li></ul></li></ul><p>以sha256签名为例<br>计算公式：len(body) = 总大小 - 4 - (2+13) - (5 + 256)</p><p>body = cert[4:-276]</p><h4 id="truststore和keystore的区别"><a href="#truststore和keystore的区别" class="headerlink" title="truststore和keystore的区别"></a>truststore和keystore的区别</h4><p>keystore用于存放自己的证书和对应私钥，通常里面的证书作为TLS端的身份。<br>truststore用于存放自己这端信任的带签名的证书。</p><p>JKS、PKCS12都既可以做keystore也可以做truststore</p><h4 id="CRL——证书吊销列表"><a href="#CRL——证书吊销列表" class="headerlink" title="CRL——证书吊销列表"></a>CRL——证书吊销列表</h4><p>证书超出有效期后会作废，用户也可以主动向 CA 申请撤销某证书文件，由于 CA 无法强制收回已经颁发出去的数字证书，因此为了实现证书的作废，往往还需要维护一个撤销证书列表（Certificate Revocation List，CRL），用于记录已经撤销的证书序号。</p><p> 因此，通常情况下，当第三方对某个证书进行验证时，需要首先检查该证书是否在撤销列表中。如果存在，则该证书无法通过验证。如果不在，则继续进行后续的证书验证过程。</p><p>值得注意的是： 目前有些 CA 颁发的证书和大部分自签SSL证书都没有提供吊销列表 (CRL) 服务或证书 吊销列表分发点是不可访问的 ，固然更别提 OSCP 服务，这是很是危险的，由于若是证书丢失或被盗而没法吊销的话，就极有可能被用于非法用途而让用户蒙受损失。</p><h4 id="秘钥、与ssh打通"><a href="#秘钥、与ssh打通" class="headerlink" title="秘钥、与ssh打通"></a>秘钥、与ssh打通</h4><h4 id="域名及CName-AAA、AAAA"><a href="#域名及CName-AAA、AAAA" class="headerlink" title="域名及CName AAA、AAAA"></a>域名及CName AAA、AAAA</h4><h4 id="PGP和GPG加签模式的区别"><a href="#PGP和GPG加签模式的区别" class="headerlink" title="PGP和GPG加签模式的区别"></a>PGP和GPG加签模式的区别</h4><h4 id="openssl验签流程"><a href="#openssl验签流程" class="headerlink" title="openssl验签流程"></a>openssl验签流程</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 转换 DER 到 PEM 格式</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -inform der -<span class="hljs-keyword">in</span> root.cer -out root.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看证书的签名，可以看到签名所使用的的 <span class="hljs-built_in">hash</span> 算法是 sha256</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> root.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取签名内容到文件中</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> root.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame | grep -v <span class="hljs-string">&#x27;Signature Algorithm&#x27;</span> | tr -d <span class="hljs-string">&#x27;[:space:]:&#x27;</span> | xxd -r -p &gt; root-signature.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取根证书中含有的公钥</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> root.pem -noout -pubkey &gt; root-pub.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 使用公钥解密签名</span><span class="hljs-meta">$</span><span class="bash"> openssl rsautl -verify -inkey root-pub.pem -<span class="hljs-keyword">in</span> root-signature.bin -pubin &gt; root-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看解密后的内容</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -inform DER -<span class="hljs-keyword">in</span> root-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 接下来我们计算证书的 <span class="hljs-built_in">hash</span> 值</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 首先提取证书的 body</span><span class="hljs-meta">#</span><span class="bash"> 因为证书中含有签名，签名是不包含在 <span class="hljs-built_in">hash</span> 值计算中的</span><span class="hljs-meta">#</span><span class="bash"> 所以不能简单地对整个证书文件进行 <span class="hljs-built_in">hash</span> 运算</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -<span class="hljs-keyword">in</span> root.pem -strparse 4 -out root-body.bin &amp;&gt; /dev/null</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 计算 sha1 哈希值</span><span class="hljs-meta">$</span><span class="bash"> openssl dgst -sha256 root-body.bin</span><span class="hljs-meta">#</span><span class="bash">SHA1(root-body.bin)= xxx</span><span class="hljs-meta"></span><span class="hljs-meta"></span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> linux 下验证网站证书完整流程</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 新建一个文件夹 github 保存所有的文件</span><span class="hljs-meta">$</span><span class="bash"> mkdir github &amp;&amp; <span class="hljs-built_in">cd</span> github</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 首先，我们下载 github.com 发送的证书</span><span class="hljs-meta">$</span><span class="bash"> openssl s_client -connect github.com:443 -showcerts 2&gt;/dev/null &lt;/dev/null | sed -n <span class="hljs-string">&#x27;/-----BEGIN/,/-----END/p&#x27;</span> &gt; github.com.crt</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> github.com.crt 是 PEM 格式的文本文件</span><span class="hljs-meta">#</span><span class="bash"> 打开可以发现里面有两段 -----BEGIN CERTIFICATE----</span><span class="hljs-meta">#</span><span class="bash"> 这说明有两个证书，也就是 github.com 把中间证书也一并发过来了</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 接下来我们把两个证书提取出来</span><span class="hljs-meta">$</span><span class="bash"> awk <span class="hljs-string">&#x27;/BEGIN/,/END/&#123; if(/BEGIN/)&#123;a++&#125;; out=&quot;cert&quot;a&quot;.tmpcrt&quot;; print &gt;out&#125;&#x27;</span> &lt; github.com.crt &amp;&amp; <span class="hljs-keyword">for</span> cert <span class="hljs-keyword">in</span> *.tmpcrt; <span class="hljs-keyword">do</span> newname=$(openssl x509 -noout -subject -<span class="hljs-keyword">in</span> <span class="hljs-variable">$cert</span> | sed -n <span class="hljs-string">&#x27;s/^.*CN=\(.*\)$/\1/; s/[ ,.*]/_/g; s/__/_/g; s/^_//g;p&#x27;</span>).pem; mv <span class="hljs-variable">$cert</span> <span class="hljs-variable">$newname</span>; <span class="hljs-keyword">done</span></span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 我们得到了两个证书文件</span><span class="hljs-meta">#</span><span class="bash"> github_com.pem 和 DigiCert_SHA2_High_Assurance_Server_CA.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 首先，验证 github_com.pem 证书确实</span><span class="hljs-meta">#</span><span class="bash"> 是由 DigiCert_SHA2_High_Assurance_Server_CA.pem 签发的</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取 DigiCert_SHA2_High_Assurance_Server_CA 的公钥</span><span class="hljs-meta">#</span><span class="bash"> 命名为 issuer-pub.pem</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> DigiCert_SHA2_High_Assurance_Server_CA.pem -noout -pubkey &gt; issuer-pub.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看 github_com.pem 的签名</span><span class="hljs-meta">#</span><span class="bash"> 可以看到 <span class="hljs-built_in">hash</span> 算法是 sha256</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> github_com.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取签名到文件中</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> github_com.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame | grep -v <span class="hljs-string">&#x27;Signature Algorithm&#x27;</span> | tr -d <span class="hljs-string">&#x27;[:space:]:&#x27;</span> | xxd -r -p &gt; github_com-signature.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 使用上级证书的公钥解密签名</span><span class="hljs-meta">$</span><span class="bash"> openssl rsautl -verify -inkey issuer-pub.pem -<span class="hljs-keyword">in</span> github_com-signature.bin -pubin &gt; github_com-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看解密后的信息</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -inform DER -<span class="hljs-keyword">in</span> github_com-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 接下来计算 github_com.pem 的 <span class="hljs-built_in">hash</span> 值</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取证书的 body 部分</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -<span class="hljs-keyword">in</span> github_com.pem -strparse 4 -out github_com-body.bin &amp;&gt; /dev/null</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 计算 <span class="hljs-built_in">hash</span> 值</span><span class="hljs-meta">$</span><span class="bash"> openssl dgst -sha256 github_com-body.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">hash</span> 值匹配，我们成功校验了 github.pem 这个证书确实是由 DigiCert_SHA2_High_Assurance_Server_CA.pem 这个证书来签发的。</span>上面的流程比较繁琐，其实也可以直接让 openssl 来帮我们验证。<span class="hljs-meta">$</span><span class="bash"> openssl dgst -sha256 -verify issuer-pub.pem -signature github_com-signature.bin  github_com-body.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 获取上级证书的名字</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> DigiCert_SHA2_High_Assurance_Server_CA.pem -text -noout | grep Issuer:</span>        Issuer: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert High Assurance EV Root CA</code></pre><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><blockquote><p>[序号]主要责任者.电子文献题名[电子文献及载体类型标识].电子文献的出版或获得地址,发表更新日期/引用日期.</p></blockquote><blockquote><p>例如：[12]王明亮.关于中国学术期刊标准化数据库系统工程的进展[EB/OL].1998-08-16/1998-10-01.</p></blockquote><blockquote><p>[8]万锦.中国大学学报文摘(1983-1993).英文版[DB/CD].北京:<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6%E5%87%BA%E7%89%88%E7%A4%BE/2267934">中国大百科全书出版社</a>,1996.</p></blockquote><ul><li><p>[1]梁栋.java加密与解密的艺术（第二版）</p></li><li><p>[2]2018-2019年中国网络可信身份服务发展蓝皮书</p></li><li><p>[3]贾铁军.网络安全技术与应用（第三版）</p></li><li><p>[4]王绍斌.云计算安全事件：从入门到精通</p></li><li><p>[5]韩立刚.深入浅出计算机网络</p></li><li><p>[6]汪德嘉.身份危机</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD">数字身份 - 维基百科，自由的百科全书 (wikipedia.org)</a></p></li><li><p><a href="http://kapsterio.github.io/test/2021/09/17/TLS.html">TLS协议分析（密码学101以及TLS协议简介） · kaspterio (kapsterio.github.io)</a></p></li><li><p><a href="https://houbb.github.io/2018/09/26/SSL-TLS">SSL/TSL | Echo Blog (houbb.github.io)</a></p></li><li><p><a href="https://www.linuxidc.com/Linux/2015-07/120230.htm">Https SSL/TLS PreMaster/Master Secret(Key)计算_服务器应用_Linux公社-Linux系统门户网站 (linuxidc.com)</a></p></li><li><p><a href="https://dev.to/wayofthepie/structure-of-an-SSL-x-509-certificate-16b">dev.to</a></p></li><li><p><a href="https://bbs.huaweicloud.com/blogs/detail/273779">为了搞懂 HTTPS，我把大学的数学书拿了出来。。。-云社区-华为云 (huaweicloud.com)</a></p></li><li><p><a href="https://www.cnblogs.com/bonelee/p/12931388.html">DSA与RSA——DSA 只能用于数字签名，而无法用于加密（某些扩展可以支持加密）；RSA 即可作为数字签名，也可以作为加密算法。在业界支持方面，RSA 具有更为广泛的部署与支持。 - bonelee - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://www.cnblogs.com/leslies2/p/7442956.html">数字证书应用综合揭秘（包括证书生成、加密、解密、签名、验签） - 风尘浪子 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://juejin.cn/post/6930446060846481416">https://juejin.cn/post/6930446060846481416</a></p></li><li><p><a href="https://stackoverflow.com/questions/37041254/ssl-certificate-signature-algorithm-shows-sha256rsa-but-thumbprint-algorithm">security - SSL Certificate: Signature Algorithm shows “sha256rsa” but thumbprint algorithm shows “sha1” - Stack Overflow</a></p></li><li><p><a href="https://cjting.me/2021/03/02/how-to-validate-tls-certificate/">https://cjting.me/2021/03/02/how-to-validate-tls-certificate/</a></p></li><li><p><a href="https://www.ibm.com/docs/en/zosconnect/3.0?topic=ee-keystores-truststores">Keystores and truststores - IBM Documentation</a></p></li><li><p><a href="https://support.huaweicloud.com/scm_faq/scm_01_0128.html">如何将证书格式转换为PEM格式？_SSL证书管理 SCM_常见问题_其他_证书管理类_华为云 (huaweicloud.com)</a></p></li><li><p><a href="https://stackoverflow.com/questions/43665243/invalid-self-signed-ssl-cert-subject-alternative-name-missing">https://stackoverflow.com/questions/43665243/invalid-self-signed-ssl-cert-subject-alternative-name-missing</a></p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html</a></p></li><li><p><a href="https://www.rfc-editor.org/rfc/rfc5246">RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 (rfc-editor.org)</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数字证书&quot;&gt;&lt;a href=&quot;#数字证书&quot; class=&quot;headerlink&quot; title=&quot;数字证书&quot;&gt;&lt;/a&gt;数字证书&lt;/h2&gt;&lt;h3 id=&quot;什么是是数字证书&quot;&gt;&lt;a href=&quot;#什么是是数字证书&quot; class=&quot;headerlink&quot; title=&quot;什</summary>
      
    
    
    
    <category term="密码学" scheme="http://donnieyeh.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="数字证书" scheme="http://donnieyeh.github.io/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
    <category term="密码学" scheme="http://donnieyeh.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ZeroTier 梳理</title>
    <link href="http://donnieyeh.github.io/2022/01/04/ZeroTier%E6%A2%B3%E7%90%86/"/>
    <id>http://donnieyeh.github.io/2022/01/04/ZeroTier%E6%A2%B3%E7%90%86/</id>
    <published>2022-01-04T02:54:00.000Z</published>
    <updated>2022-09-17T09:51:31.026Z</updated>
    
    <content type="html"><![CDATA[<p>是一款 p2p vpn</p><p>p2p 的原理是什么</p><ol><li>中继（原始方案）：两个客户端主动连接公网服务器，由服务器中继通信</li><li>逆向链接（改良版）：要求其中一个客户端（假设是B）是公网ip，且有公网服务器做中继，B先通过服务器向A中继一个连接请求，然后A主动跟B建立连接。</li><li>UDP打洞（当前最优）：两个客户端都在NAT之后，有一台公网服务器，客户端A向B发送请求，同时要求服务器中继一个“B到A的连接请求”给B，此时两边都会导致NAT打开一个自身内网到对方外网的通信，之后双方内网就可以相互通信了。该模式适用于锥形NAT。如果有多级NAT，则要求NAT得支持回环传输(loopback transmission)。<br><a href="https://zhuanlan.zhihu.com/p/26796476">https://zhuanlan.zhihu.com/p/26796476</a><br><a href="https://evilpan.com/2015/10/31/p2p-over-middle-box/">https://evilpan.com/2015/10/31/p2p-over-middle-box/</a><br>vpn 是什么<br>vpn全称visual private network，最早是公司开发给员工远程连接内网用的，此处体现了第一个用处就是代理网络请求，其次它目的是防止公司信息泄漏给第三方，所以vpn被设计成能够加密通信。所以它具备以下特点：1、提高上网安全性；2、隐藏上网者身份；3、突破网站的地域限制</li></ol><p>NAT是什么<br>NAT即网络地址转换器，NAT不止检查进入数据包的头部,而且对其进行修改,从而实现同一内网中不同主机共用更少的公网IP（通常是一个）.</p><p>隧道是什么</p><p>STUN是什么</p><p>STUN和TUN的区别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;是一款 p2p vpn&lt;/p&gt;
&lt;p&gt;p2p 的原理是什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中继（原始方案）：两个客户端主动连接公网服务器，由服务器中继通信&lt;/li&gt;
&lt;li&gt;逆向链接（改良版）：要求其中一个客户端（假设是B）是公网ip，且有公网服务器做中继，B先通过服务器向A中</summary>
      
    
    
    
    
    <category term="vpn" scheme="http://donnieyeh.github.io/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>mysql，GROUP_CONCAT，341长度疑案</title>
    <link href="http://donnieyeh.github.io/2021/12/15/mysql%EF%BC%8CGROUP_CONCAT%EF%BC%8C341%E9%95%BF%E5%BA%A6%E7%96%91%E6%A1%88/"/>
    <id>http://donnieyeh.github.io/2021/12/15/mysql%EF%BC%8CGROUP_CONCAT%EF%BC%8C341%E9%95%BF%E5%BA%A6%E7%96%91%E6%A1%88/</id>
    <published>2021-12-15T23:33:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天被同事找来讨论一个数据库问题，一个select语句带有聚合函数<code>GROUP_CONCAT(countryCode)</code>，countryCode是纯数字，所以这一列出来的结果应该是这样的：<code>24,25,1003,1004,1025,......</code>，但是实际上结果被截断了，把结果copy出来到notepad++，发现每一条记录的长度都是<code>341</code>。</p><p>经过一番查询，发现mysql对这个函数有个配置：<code>group_concat_max_len</code>，指的是对<code>GROUP_CONCAT()</code>函数的结果进行截断。比如<code>group_concat_max_len=1024</code>，那么mysql会对该函数的结果截取前1024个字节(Byte)。看起来就是它了。</p><p>通过以下命令，可以查看该库对应的配置：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;group_concat_max_len&#x27;</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1024</span></code></pre><p>可见我们的库也是1024，那为啥实际结果长度只有<code>341</code>呢。据回答的小哥说：当<code>GROUP_CONCAT()</code> 和 <code>Order By</code>一起使用的时候，结果就会进一步裁剪到1/3，如果去掉<code>Order By</code>条件，结果长度会是<code>1024</code>。但是这个规律是实践出来的，具体为啥会这样，官方手册里并没有说。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了验证思路，可参考以下sql进行配置</p><pre><code class="hljs sql"># SESSION 表示变动只影响当前会话<span class="hljs-keyword">SET</span> SESSION group_concat_max_len<span class="hljs-operator">=</span><span class="hljs-number">102400</span>;</code></pre><p>配置后验证结果长度确实不会被截断了。</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>由于我们只在某一个环境中才复现了这个问题，别的环境都没问题，所以思路就是参考别的环境的配置，经查询发现其他环境的值都是<code>group_concat_max_len=8192</code>，所以其他环境没有这个问题，遂对齐配置即可。</p><pre><code class="hljs sql"># <span class="hljs-keyword">GLOBAL</span> 表示变动影响全局<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> group_concat_max_len<span class="hljs-operator">=</span>your_value_here;</code></pre><p>如果严谨一点，应该需要排查项目里所有用到<code>GROUP_CONCAT()</code>的地方，然后结合业务评估一下合理的大小，再找DBA协商进行变更。所幸我们生产环境配的是<code>102400</code>，足够大了，也就没这种顾虑了。</p><hr><p>参考:</p><ul><li><a href="https://stackoverflow.com/questions/12001919/mysql-truncates-concatenated-result-of-a-group-concat-function">https://stackoverflow.com/questions/12001919/mysql-truncates-concatenated-result-of-a-group-concat-function</a></li><li><a href="https://stackoverflow.com/questions/4469474/mysql-truncating-of-result-when-using-group-concat-and-concat/37979180#37979180">https://stackoverflow.com/questions/4469474/mysql-truncating-of-result-when-using-group-concat-and-concat/37979180#37979180</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;今天被同事找来讨论一个数据库问题，一个select语句带有聚合函数&lt;code&gt;GROUP_CONCAT(countryCode)&lt;/code</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://donnieyeh.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>阅读文章自动生成大纲浏览器插件</title>
    <link href="http://donnieyeh.github.io/2021/12/12/%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A4%A7%E7%BA%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://donnieyeh.github.io/2021/12/12/%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A4%A7%E7%BA%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2021-12-12T11:06:00.000Z</published>
    <updated>2022-09-17T09:51:31.030Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间读文章发现没有大纲，阅读不顺畅，针对那些没有大纲的页面，手撸了一个自动生成大纲的浏览器脚本。基本上实现了大部分想要的功能，在此记录分享。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>可以导入油猴里，打开脚本开关即可生效。</li><li>使用浏览器的dev-tools来跑。</li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/outlineTool.gif"></p><p><i class="fa fa-file-code-o" aria-hidden="true"></i><a href="/data/outlineTool.user.js">文章大纲生成插件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有段时间读文章发现没有大纲，阅读不顺畅，针对那些没有大纲的页面，手撸了一个自动生成大纲的浏览器脚本。基本上实现了大部分想要的功能，在此记录分享。&lt;/p&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://donnieyeh.github.io/tags/javascript/"/>
    
    <category term="效率工具" scheme="http://donnieyeh.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="原创" scheme="http://donnieyeh.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
</feed>
