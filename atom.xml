<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeJF的篝火</title>
  
  <subtitle>回血、存档、再出发</subtitle>
  <link href="http://xr08255920.github.io/atom.xml" rel="self"/>
  
  <link href="http://xr08255920.github.io/"/>
  <updated>2022-05-15T10:33:25.250Z</updated>
  <id>http://xr08255920.github.io/</id>
  
  <author>
    <name>yejf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++指针理解</title>
    <link href="http://xr08255920.github.io/2022/04/28/C++%E6%8C%87%E9%92%88%E7%90%86%E8%A7%A3/"/>
    <id>http://xr08255920.github.io/2022/04/28/C++%E6%8C%87%E9%92%88%E7%90%86%E8%A7%A3/</id>
    <published>2022-04-28T15:01:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h2><pre><code class="hljs c++"><span class="hljs-keyword">int</span> j = <span class="hljs-number">49</span>;<span class="hljs-keyword">int</span> *i = &amp;j;# 更好的声明方式<span class="hljs-keyword">int</span>* i = &amp;j;</code></pre><p>只要声明的时候，加了<code>*</code> 号，这个变量就是<code>指针变量</code>，比如这个 i 就是一个<code>指针类型的变量</code>，而不是一个<code>int类型的变量</code></p><h3 id="那这个int在这里的作用是什么？"><a href="#那这个int在这里的作用是什么？" class="headerlink" title="那这个int在这里的作用是什么？"></a>那这个int在这里的作用是什么？</h3><p>先说结论：这个int，表明了从指针指向的头地址开始，需要往后取多少位长度的数据。</p><p>我们首先要知道，各个基础类型，都有自己的长度，如int型是32位，long型是64位。而指针类型也有自己的长度，它的值存放的是一个内存地址，即寻址长度。在32位系统中，指针类型的长度是32；在64位系统中，指针类型的长度为64。</p><p>由于指针存放的是一个内存地址，它指向的是内存中的某个比特位，即所谓的头地址。如果单看头地址的这个比特位，并没有什么实际意义，因为它只能包含0/1两种信息。而<code>int* i</code>这样声明指针类型的话，实际是在指导机器不止要看头地址，而且还要往后取32位，才能完整的把int类型的数据取出来。总结来说，单纯的指针类型变量只包含了某个内存地址（头地址）指向的那一个bit的信息，并无实际意义，只有带上具体的类型，指针类型变量才具有意义。</p><h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><p>假如当前声明了一个指针变量<code>int* i</code>，一个普通变量<code>int j</code></p><ul><li><code>i</code> 表示内存地址，类型为<code>指针类型</code></li><li><code>*i</code>表示真正的数据，类型为具体声明的类型，如<code>int</code></li><li><code>&amp;j</code>表示变量 j 的内存首地址，类型为<code>指针类型</code></li><li><code>&amp;</code>也可以用在指针类型上，如：<code>&amp;i</code>得到的是<code>指针类型的</code> <code>变量i</code>的内存首地址</li></ul><p>示例：</p><ul><li><code>cout &lt;&lt; i</code> 可以的得到<code>指针变量</code>对应的值（即某内存地址）</li><li><code>cout &lt;&lt; *i</code> 可以可以得到真正的数据，通过 <code>头地址+类型长度</code> 获取</li></ul><h2 id="指针类型变量存在栈中还是堆中"><a href="#指针类型变量存在栈中还是堆中" class="headerlink" title="指针类型变量存在栈中还是堆中"></a>指针类型变量存在栈中还是堆中</h2><p>指针类型的变量，以<code>int* i</code>为例，它可能存在于方法栈的内存空间中，也可能存在堆空间中（通过malloc函数）。</p><h3 id="为什么要有堆内存？"><a href="#为什么要有堆内存？" class="headerlink" title="为什么要有堆内存？"></a>为什么要有堆内存？</h3><p>局部变量在方法栈中分配空间，当方法执行结束、方法栈弹出之后它也会跟着被清除。此时哪怕把局部变量的指针返回出去，外部拿到的指针对应的值也是空的。只有在堆中分配的内存空间，才不会随着方法结束出栈而被清理，此时对应的指针在外部就依然能够正常获取数据。</p><p>堆内存的局限在于需要开发者手动回收，不然程序长时间运行可能会导致内存溢出。当然很多语言自带的GC也是一种优雅手段。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">43</span>;    <span class="hljs-keyword">int</span>* i;    std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;    i = <span class="hljs-built_in">b</span>();    std::cout &lt;&lt; i&lt;&lt; std::endl;    std::cout &lt;&lt; *i&lt;&lt; std::endl;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">100</span>; z++)    &#123;        <span class="hljs-comment">/* code */</span>    &#125;    std::cout &lt;&lt; i&lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">49</span>;    <span class="hljs-comment">// int* i = &amp;j;</span>    <span class="hljs-keyword">int</span>* i = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);    *i = <span class="hljs-number">256</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;in b:&quot;</span> &lt;&lt;*i&lt;&lt; std::endl;    <span class="hljs-keyword">return</span> i;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;指针的声明&quot;&gt;&lt;a href=&quot;#指针的声明&quot; class=&quot;headerlink&quot; title=&quot;指针的声明&quot;&gt;&lt;/a&gt;指针的声明&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/s</summary>
      
    
    
    
    <category term="c++" scheme="http://xr08255920.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="http://xr08255920.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper / etcd 的区别</title>
    <link href="http://xr08255920.github.io/2022/04/05/zookeeper%20,%20etcd%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://xr08255920.github.io/2022/04/05/zookeeper%20,%20etcd%20%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-04-05T13:30:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper-etcd-的区别"><a href="#zookeeper-etcd-的区别" class="headerlink" title="zookeeper / etcd 的区别"></a>zookeeper / etcd 的区别</h1><p>etcd，分布式一致性键值存储引擎，专门为分布式系统提供服务。它基于Raft共识算法，使用GOlang开发（这点很重要），由<a href="https://zh.wikipedia.org/wiki/CoreOS" title="CoreOS">CoreOS</a>开发。在github release上可以跟踪到最早发布在2013年8月12号，最近更新是在3天前，可以说是相当活跃了。</p><p>zookeeper，官方介绍是一个高可靠分布式<strong>协调</strong>服务。它提供配置维护、命名、分布式同步、分组服务（group services）等等功能。它起源于雅虎研究院的一个研究小组，后来成为hadoop的子项目，主要<strong>为Hadoop生态系统中一些列组件提供统一的分布式协作服务</strong>，再后来在（Hadoop 1.0时代）<strong>2011年1月</strong>， ZooKeeper 脱离Hadoop，成为Apache顶级项目，并成为开源项目，一直发展至今。它在官网上可找到最早的发布版本是2008年10月27好，github上最近的提交是4天前，且仅有少量提交，活跃对相对etcd较低。它基于基于 ZAB （Zookeeper Atomic Broadcast）协议实现，由java语言编写。</p><table><thead><tr><th>-</th><th>语言</th><th>能力</th><th>社区活跃度</th><th>其他</th></tr></thead><tbody><tr><td>zookeeper</td><td>java</td><td>配置维护、命名、分布式同步、分组服务</td><td>良</td><td>老牌分布式同步工具，kafka、dubbo、hadoop等都在用</td></tr><tr><td>etcd</td><td>GO</td><td>分布式键值存储、共享配置、服务发现</td><td>优</td><td>因支撑k8s而火</td></tr></tbody></table><h2 id="Raft-consensus-algorithm"><a href="#Raft-consensus-algorithm" class="headerlink" title="Raft consensus algorithm"></a>Raft consensus algorithm</h2><p>参考大神的动画： <a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p>raft其实是一个协议（protocol）。在这个协议当中，参与通信的结点有三种状态，leader、follower、candidate。在协议当中，有两种超时类型（timeout），election timeout，heartbeat timeout。leader 以 heartbeat timeout 为周期同步信息，follower 收到消息立即响应。同时存在多个节点进行leader选举时，先得到半数响应的节点成为leader。leader通过两阶段（预设、提交）同步数据，并且会记录log。</p><h2 id="ZAB（Zookeeper-Atomic-Broadcast）协议"><a href="#ZAB（Zookeeper-Atomic-Broadcast）协议" class="headerlink" title="ZAB（Zookeeper Atomic Broadcast）协议"></a>ZAB（Zookeeper Atomic Broadcast）协议</h2><p>选举通常是选zxid，sid（myid）最大的。新选举完毕会产生新的纪元，epoch，老leader恢复后其他节点也不听他管，毕竟前朝的剑不能斩本朝的官。</p><hr><p>Zookeeper的ZAB，Viewstamped Replication（VR），raft，multi-paxos，这些都可以被称之为Leader-based一致性协议。总的来说raft相对来说比较亲民好理解。</p><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/weixin_38256474/article/details/90636262">[zookeeper] 00 - 初识：由来、版本、架构_神是念着倒-CSDN博客_zookeeper发展历史</a></li><li><a href="https://blog.csdn.net/qq_22115231/article/details/80784535">Zookeeper理解_老史的足迹-CSDN博客</a></li><li><a href="https://www.zhihu.com/question/36648084">raft算法与paxos算法相比有什么优势，使用场景有什么差异？ - 知乎 (zhihu.com)</a></li><li><a href="https://dzone.com/articles/apache-zookeeper-vs-etcd3">https://dzone.com/articles/apache-zookeeper-vs-etcd3</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;zookeeper-etcd-的区别&quot;&gt;&lt;a href=&quot;#zookeeper-etcd-的区别&quot; class=&quot;headerlink&quot; title=&quot;zookeeper / etcd 的区别&quot;&gt;&lt;/a&gt;zookeeper / etcd 的区别&lt;/h1&gt;&lt;p&gt;et</summary>
      
    
    
    
    <category term="工具调研" scheme="http://xr08255920.github.io/categories/%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/"/>
    
    
    <category term="zookeeper" scheme="http://xr08255920.github.io/tags/zookeeper/"/>
    
    <category term="etcd" scheme="http://xr08255920.github.io/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>python 实现图片汉字识别</title>
    <link href="http://xr08255920.github.io/2022/04/05/python%20%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B1%89%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://xr08255920.github.io/2022/04/05/python%20%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B1%89%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2022-04-05T13:19:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心库使用"><a href="#核心库使用" class="headerlink" title="核心库使用"></a>核心库使用</h1><p>相关库：tesseract-ocr<br><strong><a href="https://github.com/tesseract-ocr">https://github.com/tesseract-ocr/</a></strong></p><p>核心库软件：tesseract<br>语言模块：tessdata，其中汉字的是 <code>chi_sim</code></p><p>步骤：</p><ol><li>下载安装核心库，自己编译太麻烦了，直接下载安装包</li><li>下载汉字模块：<code>chi_sim.traineddata</code>、<code>chi_sim_vert.traineddata</code><ol><li>放到 tresseract根目录/tessdata/下</li></ol></li><li>命令行测试：tesseract -v</li><li>图片识别：<code>tesseract 输入文件 输出路径 -l 解析使用到的语言模块</code><ol><li>例：<code>tesseract E://figures/other/timg.jpg E://figures/other/timg.txt -l chi_sim</code></li></ol></li></ol><p>核心库已经能正常使用，接下来安装python相关库。</p><h1 id="安装python-依赖"><a href="#安装python-依赖" class="headerlink" title="安装python 依赖"></a>安装python 依赖</h1><ol><li>安装 tesseract api：<code>pip install pytesseract</code></li><li>安装图片处理模块：<code>pip install Pillow</code></li><li>测试实践：<pre><code class="hljs python"><span class="hljs-keyword">import</span> pytesseract<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Imagepytesseract.pytesseract.tesseract_cmd = <span class="hljs-string">&#x27;C://Program Files (x86)/Tesseract-OCR/tesseract.exe&#x27;</span>text = pytesseract.image_to_string(Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E://figures/other/poems.jpg&#x27;</span>),lang=<span class="hljs-string">&#x27;chi_sim&#x27;</span>)<span class="hljs-built_in">print</span>(text)</code></pre></li></ol><h1 id="提升识别度（实践）"><a href="#提升识别度（实践）" class="headerlink" title="提升识别度（实践）"></a>提升识别度（实践）</h1><p>对于提升识别度，官方有一个较全面的指导，点击<a href="https://github.com/tesseract-ocr/tessdoc/blob/main/ImproveQuality.md">链接</a>查看<br>经实践，想要提升识别度，提升图片的分辨率是最简单直接有效的方式。建议图片的分辨率转换到300以上，再走tesseract进行处理。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/T_maker/article/details/82622447">python 5行代码实现图片中文字识别_T_maker的博客-CSDN博客_文字识别python代码实现</a></li><li><a href="https://blog.51cto.com/u_12139363/3025427">python ocr图片中汉字识别【图文】_gisoracleplus_51CTO博客</a></li></ul><p>待参考：</p><ul><li><a href="http://3ms.huawei.com/km/blogs/details/11393875">python——识别图片中的文字 - 王耀的博客 (huawei.com)</a></li><li><a href="http://3ms.huawei.com/km/blogs/details/9519567">通过Tesseract OCR识别扫描件PDF - 高文光的博客 (huawei.com)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;核心库使用&quot;&gt;&lt;a href=&quot;#核心库使用&quot; class=&quot;headerlink&quot; title=&quot;核心库使用&quot;&gt;&lt;/a&gt;核心库使用&lt;/h1&gt;&lt;p&gt;相关库：tesseract-ocr&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/t</summary>
      
    
    
    
    
    <category term="python" scheme="http://xr08255920.github.io/tags/python/"/>
    
    <category term="ocr" scheme="http://xr08255920.github.io/tags/ocr/"/>
    
  </entry>
  
  <entry>
    <title>apache common-lang3 DateUtils使用</title>
    <link href="http://xr08255920.github.io/2022/04/05/apache%20common-lang3%20DateUtils%E4%BD%BF%E7%94%A8/"/>
    <id>http://xr08255920.github.io/2022/04/05/apache%20common-lang3%20DateUtils%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-05T13:17:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>isSameDay</li><li>parseDate：传入多个模板，直到匹配其中一个就可以，若全不匹配则抛出异常</li><li>addXXX</li><li>setXXX</li><li>toCalendar(date)</li><li>round：其注释描述的<a href="https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%97%B6%E5%88%B6">夏时制</a>（daylight time），只针对特定timezone的国家，对我们没影响</li><li>truncate：裁剪尾部</li><li>ceiling：跟truncate一样，但是会向上对齐</li><li>getFragmentInXXX：裁剪头部，跟truncate相反</li><li>truncatedEquals：两日期裁剪后对比，可以达到和isSameDay一样的效果</li><li>truncatedCompareTo：两日期裁剪后对比</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;isSameDay&lt;/li&gt;
&lt;li&gt;parseDate：传入多个模板，直到匹配其中一个就可以，若全不匹配则抛出异常&lt;/li&gt;
&lt;li&gt;addXXX&lt;/li&gt;
&lt;li&gt;setXXX&lt;/li&gt;
&lt;li&gt;toCalendar(date)&lt;/li&gt;
&lt;li&gt;round</summary>
      
    
    
    
    <category term="apache生态" scheme="http://xr08255920.github.io/categories/apache%E7%94%9F%E6%80%81/"/>
    
    
    <category term="apache" scheme="http://xr08255920.github.io/tags/apache/"/>
    
    <category term="使用手册" scheme="http://xr08255920.github.io/tags/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>what does &quot;TCP segment of a reassembled PDU&quot; mean?</title>
    <link href="http://xr08255920.github.io/2022/04/05/TCP%20segment%20of%20a%20reassembled%20PDU/"/>
    <id>http://xr08255920.github.io/2022/04/05/TCP%20segment%20of%20a%20reassembled%20PDU/</id>
    <published>2022-04-05T13:06:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="what-does-“TCP-segment-of-a-reassembled-PDU”-mean"><a href="#what-does-“TCP-segment-of-a-reassembled-PDU”-mean" class="headerlink" title="what does “TCP segment of a reassembled PDU” mean?"></a>what does “TCP segment of a reassembled PDU” mean?</h3><p>wireshark抓TCP包抓到<code>&quot;TCP segment of a reassembled PDU&quot;</code>，表示该TCP包是被分片了的，被分片的理由是因为发送方的原数据太大，当原数据长度超过了双方协商的<code>MSS</code>值，就会将数据进行TCP分片。</p><pre><code>注意与IP层切片参数`MTU`区分。</code></pre><p>当使用wireshark抓包时，有以下分辨方法</p><ol><li>若多个TCP包作为一个大段数据的分片进行传输，它们的ACK会是一样的，这很好分辨</li><li>或者点开任意分片的数据包查看内容，里面会出现诸如<code>[Reassembled PDU in frame: 9]</code>的信息，表示这些分片将在9号记录中整合。此时跳到9号记录，可以看到<code>[3 Reassembled TCP Segments (2782 bytes): #6(1306), #7(1360), #9(116)]</code>这样的描述，表示这段完整的数据由6、7、9号记录整合而成。</li></ol><p>参考文献：</p><ul><li><a href="https://www.cnblogs.com/tomato0906/articles/3991388.html">TCP segment of a reassembled PDU - 小西红柿 - 博客园 (cnblogs.com)</a></li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>MTU全程最大传输单元，相当于划了一条红线。TCP的MSS将基于MTU来计算获得。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;what-does-“TCP-segment-of-a-reassembled-PDU”-mean&quot;&gt;&lt;a href=&quot;#what-does-“TCP-segment-of-a-reassembled-PDU”-mean&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="网络" scheme="http://xr08255920.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://xr08255920.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>如何在一台机器管理两个github账号</title>
    <link href="http://xr08255920.github.io/2022/03/23/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%AE%A1%E7%90%86%E4%B8%A4%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/"/>
    <id>http://xr08255920.github.io/2022/03/23/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%AE%A1%E7%90%86%E4%B8%A4%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7/</id>
    <published>2022-03-23T14:14:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题的背景比较特殊，不是每个人都会遇到</p><p>比如你和你的对象都有github账号，而且两人偶尔会用同一台电脑push东西，就会遇到这种问题</p><p>现假如我要在本机维护两套github账号，一个是donnie，一个是alpha</p><h1 id="一-创建密钥对"><a href="#一-创建密钥对" class="headerlink" title="一. 创建密钥对"></a>一. 创建密钥对</h1><p>先用命令创建各自对应的密钥对，按着步骤走，密钥存储的文件名要各自命名</p><pre><code class="hljs bash">ssh-keygen</code></pre><p>此时两个账号的密钥对存放到了<code>~/.ssh/</code>目录下了</p><h1 id="二-配置pubKey到GitHub账号下"><a href="#二-配置pubKey到GitHub账号下" class="headerlink" title="二. 配置pubKey到GitHub账号下"></a>二. 配置pubKey到GitHub账号下</h1><p>在本例中，会把<code>~/.ssh/id_rsa_alpha.pub</code>里的公钥配到<code>alpha</code>的GitHub账号下；<code>~/.ssh/id_rsa_donnieyeh.pub</code>里的公钥配置到donnie的GitHub账号下</p><h1 id="三-配置ssh-config"><a href="#三-配置ssh-config" class="headerlink" title="三. 配置ssh config"></a>三. 配置ssh config</h1><p>创建<code>~/.ssh/config</code>文件，为每个账号配置如下内容</p><pre><code class="hljs crmsh"><span class="hljs-comment"># donnie </span>Host donnieYehHostName github.com<span class="hljs-keyword">User</span> <span class="hljs-title">git</span>IdentityFile ~/.ssh/id_rsa_donnieyeh<span class="hljs-comment"># alpha</span>Host alphaHostName github.com<span class="hljs-keyword">User</span> <span class="hljs-title">git</span>IdentityFile ~/.ssh/id_rsa_alpha</code></pre><p>配置完后可以使用命令<code>ssh -T git@$&#123;Host&#125;</code>验证效果，例：</p><pre><code class="hljs bash">ssh -T git@donnieYehssh -T git@alpha</code></pre><p>出现以下响应代表配置成功了</p><pre><code class="hljs ada">Hi xxx! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.</code></pre><h1 id="四-修改提交人信息"><a href="#四-修改提交人信息" class="headerlink" title="四. 修改提交人信息"></a>四. 修改提交人信息</h1><p>由于一台机器有两个GitHub账号使用，所以不能配置全局提交人，不然提交信息就乱套了。</p><p>首先删除全局配置：</p><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> <span class="hljs-string">&#x27;user.name&#x27;</span>git config --global --<span class="hljs-built_in">unset</span> <span class="hljs-string">&#x27;user.email&#x27;</span></code></pre><p>然后再在各自的git仓库设置本地配置：</p><pre><code class="hljs bash">git config user.email xxx@gmail.comgit config user.name xxx</code></pre><h1 id="五-将远程仓库地址与账号配置进行关联"><a href="#五-将远程仓库地址与账号配置进行关联" class="headerlink" title="五. 将远程仓库地址与账号配置进行关联"></a>五. 将远程仓库地址与账号配置进行关联</h1><p>假如原仓库地址为：<br><code>git@github.com:xr08255920/picCrawler.git</code><br>或<br><code>https://github.com/donnieYeh/picCrawler.git</code></p><p>则重新关联的远程仓库格式为：<br><code>git@$&#123;Host&#125;:xr08255920/picCrawler.git</code></p><p>之后进行远程仓库操作，git会自动按照<code>config</code>文件中的配置把<code>$&#123;Host&#125;</code>映射成<code>$&#123;HostName&#125;</code>，而且会使用对应的私钥进行通信</p><h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><p>若已经有现成的拉下来的远程仓库，则修改远程仓库的地址：</p><pre><code class="hljs bash"><span class="hljs-comment"># 查看现有的关联</span>$ git remote -vorigin  https://github.com/donnieYeh/picCrawler.git (fetch)origin  https://github.com/donnieYeh/picCrawler.git (push)<span class="hljs-comment"># 先删除原先绑定的地址</span>$ git remote remove origin<span class="hljs-comment"># 再重新添加 </span>$ git remote add origin git@donnieYeh:xr08255920/picCrawler.git</code></pre><p>若是新clone的仓库，自行手动把clone地址的<code>github.com</code>改成自己的<code>$&#123;Host&#125;</code>：</p><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@donnieYeh:xr08255920/picCrawler.git</code></pre><p>之后就能正常的进行仓库的各种管理操作啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个问题的背景比较特殊，不是每个人都会遇到&lt;/p&gt;
&lt;p&gt;比如你和你的对象都有github账号，而且两人偶尔会用同一台电脑push东西，就会遇到这种问题&lt;/p&gt;
&lt;p&gt;现假如我要在本机维护两套github账号，一个是donnie，一个是alpha&lt;/p&gt;
&lt;h1 id=&quot;一</summary>
      
    
    
    
    <category term="日常经验" scheme="http://xr08255920.github.io/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="github" scheme="http://xr08255920.github.io/tags/github/"/>
    
    <category term="ssh" scheme="http://xr08255920.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>《java并发编程实战》读书笔记</title>
    <link href="http://xr08255920.github.io/2022/03/10/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://xr08255920.github.io/2022/03/10/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-10T13:16:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p>书籍：《java concurrency in practice》英文原版<br>作者：Brian Goetz</p><p><strong>2.1</strong><br>线程安全如何定义？</p><p>首先，“线程安全”针对的对象是java的类。通常是描述“某个类是否线程安全”。<br>其次，一个类是“线程安全”，意味着它不需要使用任何“同步”、“协调”的代码就能在多个线程内正常运行<br>由此可知，只有“非线程安全”的类，才需要借助“同步”工具进行辅助</p><blockquote><p>我们很难理解线程安全的概念，是由于缺乏一个清晰精准的定义，而“精准”意味着class必须要遵循它的规范。一个好的规范定义了约束对象状态的不变量(invariants)和描述其操作效果的后置条件(postconditions)。</p></blockquote><p>说人话就是：书中给与”线程安全”的定义是：一个类是线程安全的话，那它必须保证在多线程操作下，它的invariants保持不变，而且操作结果符合给定的条件。</p><p>举个例子，”因素分解servlet缓存”例子中，请求入参的<strong>lastNumber</strong>和计算出来的<strong>lastFactors</strong>，组成了一个不变量（invariant），就是无论如何操作，用lastNumber在缓存取得的值一定与计算出来的lastFactors的一样。此处可见一个invariant可由多个相关联的state组成</p><p><strong>2.1.1</strong><br>无状态的类总是线程安全的。</p><p><strong>2.2</strong><br>通过了一个”counter++”的例子，解释了什么叫有状态，且有状态是线程不安全的。因为“counter”的操作包含了”读、改、写“三步，在多线程中这种操作并不是原子的。这种情况叫做”竞态（race condition）“</p><p><strong>2.2.1</strong><br>通过了”两人相约星巴克”的例子，展示了竞态的问题。简单来说就是：你观察某个条件为ture，当你基于这个观测来行动的时候，在观测到行动的这段时间内系统的状态已经发生了改变。这种竞态问题叫做“<strong>检查后行动（check-then-act）</strong>”</p><p><strong>2.2.2</strong><br>通过“懒初始化（lazy initialization）”例子来展示了代码层面的“检查后行动”问题。同时揭示了“counter”问题属于另一种竞态问题：“<strong>读、改、写（Read-modify-write）</strong>”。还举了些例子也会有这种问题，诸如：注册器、id生成器</p><p><strong>2.2.3</strong><br>把”检查后行动“和”读、改、写“这两种竞态问题概括为”<strong>复合操作（compound actions）</strong>”。而“复合操作”必须保证<strong>原子性</strong>。介绍了现成的”线程安全类”：Atomic*，用于解决“读改写”问题。同时作者建议多使用现成的“线程安全对象“来解决线程安全问题，而不是一上来就加锁。</p><p><strong>2.3</strong><br>通过了”对servlet的请求处理增加缓存”的例子，揭示了当程序有多个状态时，我们对每个状态都使用”线程安全对象”来维护，也是没法保证线程安全性的。因为这多个状态是相互关注的，为了保护状态的一致性，应当在原子性操作里更新相关联的变量。</p><p><strong>2.3.1</strong><br>介绍了保证多个状态原子性的手段：<strong>内置锁 synchronized</strong>，又称 intrinsic locks，monitor locks。</p><p>介绍了注解：@GuardedBy(“this”)，可以标注变量由哪个锁保护，仅用于提高可读性。</p><p>同时注明了过度的”线程安全”则会造成”性能问题”，</p><p><strong>2.3.2</strong><br>介绍了什么叫<strong>可重入</strong></p><p><strong>2.3.4</strong><br>当可变状态被多个线程访问时，要对所有的访问动作都加同一个锁，此时可以说这个状态被那个锁保护着。<br>每个可变的、共享的状态都应该只由一个锁来保护，我们应该让维护者明确的知道保护状态的是哪个锁。<br>一个常见的做法是，当一个对象封装了多个可变状态，这些状态通常会用封装它们的对象的内置锁来保护。<br>作者再次强调，只有可能被多线程访问的可变对象，才需要使用锁来保护。<br>一个invariant设计的多个state，应该由同一把锁来保护</p><p>总的来说，线程安全围绕着三种解决思路，按顺序优先使用：</p><ul><li>要么不共享</li><li>要么发布不可变对象，对此有三个要求</li><li>对象状态不可变（指操作）</li><li>对象里的引用需要使用final修饰</li><li>正确的构造（不暴露this）</li><li>最后他自己是要可见的（添加volatile修饰）</li><li>要么使用同步机制（synchronized 、 lock）</li></ul><p><strong>2.4</strong><br>最后还强调了并不是对每个方法都加锁就能解决竞态问题，因为有些需要原子性的复合操作需要涉及到多个方法，而且这样做反而有可能造成活跃性问题和性能问题。</p><p><strong>2.5</strong><br>作者说明了对整个方法加锁不是一种好的做法，会直接导致所有线程都排队执行该业务，称其为“弱并发”。并提供了一种思路，就是尽量把不影响”共享状态”的耗时操作移出同步块，让这些耗时操作可以利用到并发的优势。这个思路能让我们在简单性、安全性和并发性之间找到一个平衡。如何找到这种平衡，衡量同步块的规模，要求要有tradeoffs思维。有时候简单性和性能是互相矛盾的，在实现同步的时候要注意抵制”过早牺牲简单性来满足性能”的诱惑。要避免在漫长的计算过程中持有锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书籍：《java concurrency in practice》英文原版&lt;br&gt;作者：Brian Goetz&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1&lt;/strong&gt;&lt;br&gt;线程安全如何定义？&lt;/p&gt;
&lt;p&gt;首先，“线程安全”针对的对象是java的类。通常是描述“某个类是否</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://xr08255920.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="并发编程" scheme="http://xr08255920.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>github actions checkout失败问题</title>
    <link href="http://xr08255920.github.io/2022/03/09/github%20actions%20checkout%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://xr08255920.github.io/2022/03/09/github%20actions%20checkout%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-09T02:33:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>最近github主页项目，提交代码后CI流程失败。提示</p><pre><code class="hljs clean">##[error]fatal: could not read Username for <span class="hljs-string">&#x27;https://github.com&#x27;</span>: terminal prompts disabled</code></pre><p>以前都是跟着教程搭的github page 的CI配置，也没有认真了解过其原理，正好借着这次机会学习下。</p><h1 id="github-workflow工作流程："><a href="#github-workflow工作流程：" class="headerlink" title="github workflow工作流程："></a>github workflow工作流程：</h1><ol><li>编写一个CI流程配置文件，里面包含了：<ol><li>触发CI的条件</li><li>CI流程每一步的操作</li></ol></li><li>接下来比如从本地仓push代码到github，触发CI条件，然后github Actions 下的workflow就会按照CI配置文件对应的步骤进行相应的构建、部署操作。</li></ol><h1 id="CI配置文件的结构："><a href="#CI配置文件的结构：" class="headerlink" title="CI配置文件的结构："></a>CI配置文件的结构：</h1><ul><li><p>触发条件</p></li><li><p>执行的任务（可有多个）</p><ul><li>任务的每一步具体做什么</li></ul><p>  该配置通常为存放在项目根目录的 <code>.github/workflows/</code>下的yml文件</p></li></ul><h1 id="什么是actions？"><a href="#什么是actions？" class="headerlink" title="什么是actions？"></a>什么是actions？</h1><p>通常 “任务的每一步具体动作”，由 run 命令来执行。而github的actions市场，则提供了一系列封装好的通用动作库。用法则是使用uses 命令来引入。</p><h1 id="checkout-actions"><a href="#checkout-actions" class="headerlink" title="checkout actions"></a>checkout actions</h1><p>其中一个最流行的actions就是 actions/checkout@v2，可以在github.com/actions 页找到它，然后点进去查看相应文档。<br>该actions中的token选项，是指定PAT（Personal access token）</p><h1 id="什么是PAT"><a href="#什么是PAT" class="headerlink" title="什么是PAT"></a>什么是PAT</h1><p>Personal access token，个人账号范围（可以是组织范围）的一个token，在<code>个人Setting/developer settings</code>里面创建，该token用于在命令行操作个人github资源时鉴权用。在创建的时候，会让你选择该token的授权范围，以及指定token的过期时间，通常不建议设置永久期限，定期更换能减少token暴露风险。</p><h1 id="如何在actions中引入PAT"><a href="#如何在actions中引入PAT" class="headerlink" title="如何在actions中引入PAT"></a>如何在actions中引入PAT</h1><p>可以通过表达式<code>$&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125; </code>来引入，其中 secrets 是指<strong>项目setting</strong>中的secrets栏，PERSONAL_TOKEN是我们在secrets栏中创建的变量，创建的时候把上一步创建的PAT粘贴到变量值，之后即可以在actions中通过表达式<code>$&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125;</code> 引入环境变量PAT</p><h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>造成该异常的主要原因就是PAT过期了，解决办法就是重新生成一个PAT，并重新设置到项目的”secrets.自定义变量名”中，只要CI配置文件的变量名跟”secrets.自定义变量名”匹配，就能重新成功跑通actions/checkout@v2构建流程了。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://www.bilibili.com/video/BV1RE411R7Uy?from=search&seid=4861890920343690403&spm_id_from=333.337.0.0" title="【CICD】github新功能actions全方位讲解！！">【CICD】_github_新功能_actions_全方位讲解！！</a></li><li><a href="https://github.com/actions/checkout/issues/26">https://github.com/actions/checkout/issues/26</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h1&gt;&lt;p&gt;最近github主页项目，提交代码后CI流程失败。提示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs clean&quot;&gt;##[e</summary>
      
    
    
    
    
    <category term="CI" scheme="http://xr08255920.github.io/tags/CI/"/>
    
    <category term="github" scheme="http://xr08255920.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>张执中——说服力（1）</title>
    <link href="http://xr08255920.github.io/2022/02/27/%E5%BC%A0%E6%89%A7%E4%B8%AD%E2%80%94%E2%80%94%E8%AF%B4%E6%9C%8D%E5%8A%9B%EF%BC%881%EF%BC%89/"/>
    <id>http://xr08255920.github.io/2022/02/27/%E5%BC%A0%E6%89%A7%E4%B8%AD%E2%80%94%E2%80%94%E8%AF%B4%E6%9C%8D%E5%8A%9B%EF%BC%881%EF%BC%89/</id>
    <published>2022-02-27T15:29:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>听了张执中的公开课，觉得颠覆了以前的很多观点，遂记录</p></blockquote><ul><li><p>每个人的看法都是其过往人生的总结</p></li><li><p>别说“你应该”，要说“我需要”</p></li></ul><p><strong>说教5典</strong></p><ol><li>你为什么不去试试呢                   <blockquote><p>—— 帮助别人复习反驳的理由</p></blockquote></li><li>我可以陪你去做<blockquote><p>—— 热心只会给人压力</p></blockquote></li><li>你有什么困难吗<blockquote><p>—— 你只是在想机会反驳对方</p></blockquote></li><li>当你这么样这么样做完以后，不会觉得很舒服吗<blockquote><p>—— 别告诉对方，他该有什么感觉</p></blockquote></li><li>我觉得你应该不是这种人，你可以做的更好<blockquote><p>—— 不要替我决定我是谁</p></blockquote></li></ol><ul><li><p>别问“为什么不”，要问“为什么要”</p></li><li><p>说教者的反面：点燃者（每个人都想改变，只是需要发觉和点燃！）</p></li></ul><p><strong>说教者总是以自己目的为出发点去控制他人，而不是去理解他人</strong></p><ul><li>你只看到了对方点炸鸡，却没看到对方点无糖可乐</li><li>你只看到了他平时不好好学习，却没看到他临时抱佛脚</li></ul><p>点燃句式</p><ol><li>咦，你为什么会提起xx？<blockquote><p>—— 针对既有行为/让对方找出自己的理由</p></blockquote></li><li>这理由，真有那么重要吗？<blockquote><p>—— 让他为自己的理由辩护</p></blockquote></li><li>没想到，你是在意这种事的人<blockquote><p>—— 让对方重新定义自己</p></blockquote></li></ol><p>综上：所有说服，本质上都是自我说服</p><p>不是找个说服他的理由，而是帮他找到说服自己的理由</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;听了张执中的公开课，觉得颠覆了以前的很多观点，遂记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个人的看法都是其过往人生的总结&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;别说“你应该”，要说“我需要”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="张执中——说服力" scheme="http://xr08255920.github.io/categories/%E5%BC%A0%E6%89%A7%E4%B8%AD%E2%80%94%E2%80%94%E8%AF%B4%E6%9C%8D%E5%8A%9B/"/>
    
    
    <category term="笔记" scheme="http://xr08255920.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="公开课" scheme="http://xr08255920.github.io/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>python爬取邮件订阅的pinterest热门图片</title>
    <link href="http://xr08255920.github.io/2022/02/26/python%E7%88%AC%E5%8F%96%E9%82%AE%E4%BB%B6%E8%AE%A2%E9%98%85%E7%9A%84pinterest%E7%83%AD%E9%97%A8%E5%9B%BE%E7%89%87/"/>
    <id>http://xr08255920.github.io/2022/02/26/python%E7%88%AC%E5%8F%96%E9%82%AE%E4%BB%B6%E8%AE%A2%E9%98%85%E7%9A%84pinterest%E7%83%AD%E9%97%A8%E5%9B%BE%E7%89%87/</id>
    <published>2022-02-26T16:31:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/donnieYeh/picCrawler">项目地址</a></p><h1 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h1><p>不知何时开始订阅了pinterest的消息，pinterest会不时的发送热门图片到邮箱里。无奈于平时没时间也懒得去翻阅，堆积了有900+封pinterest的邮件。在某个下午突发奇想：如果能自动爬取热门图片，然后在电视大屏里轮播，把平时不怎么开的电视利用起来，当成一块动态大画框，貌似也挺不错。然后这个工具就产生了。</p><h1 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h1><p>要实现我的想法，梳理了以下大致有如下几步：</p><ol><li>获取pinterest邮件记录</li><li>打开热图链接，获取网页dom</li><li>解析网页dom，获取图片地址列表</li><li>爬取图片，保存到本地目录</li><li>电视通过smb协议访问电脑的壁纸目录，轮播图片</li></ol><p>拓展：</p><ol><li>图片去重，hash值存db中</li></ol><h1 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h1><h2 id="获取pinterest邮件记录"><a href="#获取pinterest邮件记录" class="headerlink" title="获取pinterest邮件记录"></a>获取pinterest邮件记录</h2><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/35521803">https://zhuanlan.zhihu.com/p/35521803</a></li></ul><p>使用python读取outlook邮件</p><ul><li>需要关注每次只拉未处理过的邮件</li></ul><p>跟着文章操作，可以顺利获取到pinterest未读邮件列表，以及其内容</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.office.interop.outlook.items?view=outlook-pia">outlookAPI相关文档</a></p><h3 id="2种邮件处理策略"><a href="#2种邮件处理策略" class="headerlink" title="2种邮件处理策略"></a>2种邮件处理策略</h3><p>公共特征： </p><ul><li>sender address 包含 recommend</li><li>跳转链接带有 “utm_content” 字符串</li></ul><h4 id="图板推荐"><a href="#图板推荐" class="headerlink" title="图板推荐"></a>图板推荐</h4><p>特征：</p><ul><li>subject 包含“<strong>图板</strong>”二字</li><li>跳转到图板页，需要模拟浏览器动作以获取二级图片</li></ul><p>策略：</p><ul><li>图板的图我们可以只下载前20张</li></ul><h4 id="热门pin图"><a href="#热门pin图" class="headerlink" title="热门pin图"></a>热门pin图</h4><p>特征</p><ul><li>subject包含“pin图”二字</li><li>跳转到图片页，可直接获取图片链接</li></ul><hr><p>此处涉及到使用正则表达式过滤关键链接，相关操作参考：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> re// 匹配整串re.match// 搜索第一个匹配re.search// 搜索所有匹配re.findall</code></pre><h2 id="打开热图链接，获取网页dom"><a href="#打开热图链接，获取网页dom" class="headerlink" title="打开热图链接，获取网页dom"></a>打开热图链接，获取网页dom</h2><p>参考文章：</p><ul><li><a href="https://steam.oxxostudio.tw/category/python/spider/pinterest.html">https://steam.oxxostudio.tw/category/python/spider/pinterest.html</a></li><li><a href="https://www.selenium.dev/selenium/docs/api/py/index.html">selenium学习</a></li><li><a href="https://www.w3schools.com/xml/xpath_intro.asp">xpath学习</a></li><li><a href="https://www.w3schools.com/xml/xpath_syntax.asp">xpath语法手册</a></li><li><a href="https://blog.csdn.net/butthechi/article/details/80844330">https://blog.csdn.net/butthechi/article/details/80844330</a></li></ul><p>由于pinterest网页有个特性，就是每次只展示特定窗口范围的图片，在浏览器滚动过程中，前面的图片结点会消失，后面的图片结点会加载。所以没法一次性获取整个dom资源，需要模拟滚动网页，才能获取到完整的DOM。</p><p>这里使用selenium来实现模拟，需要了解一些前置知识：XPATH</p><h3 id="XPATH"><a href="#XPATH" class="headerlink" title="XPATH"></a>XPATH</h3><p>有7种结点类型：<br> element, attribute, text, namespace, processing-instruction, comment, and document nodes</p><ul><li>最上层的为 root Element node</li><li><code>&lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;</code> 中的<code> lang=&quot;en&quot;</code>为attribute node</li><li><code>&lt;author&gt;J K. Rowling&lt;/author&gt;</code>中的<code>J K. Rowling</code>为text node</li><li>atomic value 指的是没有子节点和父节点的node，如text node</li><li>Items 指的是 atomic values 或者 nodes</li><li>ancestors（祖先）结点指的是<strong>包括父节点</strong>的所有上级结点</li><li>descendants（子孙）结点指的是<strong>包括子节点</strong>的所有下级结点</li></ul><p>模糊匹配属性：<code>//tr[contains(@class,&#39;result&#39;)] # 得到所有class 包含result的语句</code></p><hr><p>python set 定义：<code>imgs = &#123;&#125;</code></p><h2 id="解析网页dom，获取图片地址列表"><a href="#解析网页dom，获取图片地址列表" class="headerlink" title="解析网页dom，获取图片地址列表"></a>解析网页dom，获取图片地址列表</h2><p>使用BeautifulSoup + 正则轻松搞定</p><h2 id="爬取图片，保存到本地目录"><a href="#爬取图片，保存到本地目录" class="headerlink" title="爬取图片，保存到本地目录"></a>爬取图片，保存到本地目录</h2><hr><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><ul><li>由于使用单线程处理，对pinterest服务器是友好的，以后考虑提升效率，或许会使用代理池+多线程抓取</li><li>后续考虑TB上看下有没有电子相框，这样连电视都不用开了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/donnieYeh/picCrawler&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;来由&quot;&gt;&lt;a href=&quot;#来由&quot; class=&quot;headerlink&quot; title=&quot;来由&quot;&gt;&lt;/a&gt;来由&lt;/h1&gt;&lt;p&gt;不知何时</summary>
      
    
    
    
    
    <category term="python" scheme="http://xr08255920.github.io/tags/python/"/>
    
    <category term="爬虫" scheme="http://xr08255920.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>PostMan自动生成鉴权参数</title>
    <link href="http://xr08255920.github.io/2022/01/28/PostMan%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%89%B4%E6%9D%83%E5%8F%82%E6%95%B0/"/>
    <id>http://xr08255920.github.io/2022/01/28/PostMan%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%89%B4%E6%9D%83%E5%8F%82%E6%95%B0/</id>
    <published>2022-01-28T06:50:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工具版本：</p><ul><li>PostMan: 8.0.7</li><li>Crypto-js: 3.1.9</li></ul><p>我们通常联调的时候，有可能会需要协商好密钥，用于在API调用时加签和验签。由于签名是基于请求体和请求头动态生成的，postman预置静态参数的方式根本不能满足我们对效率的追求，然后我就捣鼓了一下用postman为每个请求动态生成鉴权参数，以此文章来记录过程中的经验心得。</p><p>postman中有个选项页叫做<code>Pre-request script</code>，顾名思义，它可以在请求前执行该脚本。它本质上就是个js脚本，而我们主要就是要在这里编写脚本生成所需数据。</p><h2 id="零、预研"><a href="#零、预研" class="headerlink" title="零、预研"></a>零、预研</h2><p>调查了一下找到了JS里好评率较高的密钥库<a href="https://github.com/brix/crypto-js">Crypto-js</a>，随便谷歌一个好用的CDN地址，我这里使用的是jsdelivr的源（jsdelivr真的太香了）。为了验证它好不好使，我习惯先用交互式编程研究下它的用法（使用ipython留下的习惯），最好的JS交互式界面当然就是Chrome了。</p><p>打开Chrome控制台，输入命令，引入密钥库。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);script.src = <span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js&quot;</span><span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].appendChild(script);</code></pre><p>简单找下，很容易找到它的主类是<code>CryptoJS</code></p><p>我这里需要用到密钥库里的HmacSHA256、Base64两个工具，通过摸索它的API，很快了解了用法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> key = foo<span class="hljs-keyword">var</span> message = bar<span class="hljs-keyword">var</span> sign = CryptoJS.HmacSHA256(<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-keyword">var</span> signenc = CryptoJS.enc.Base64.stringify(sign)</code></pre><pre><code>此处要注意一个大坑，由于CryptoJS生成的Sign是特别的数据结构，而不是纯粹的二进制，所以用chrome自带的base64工具（btoa、atob）是无法得到正确的编码的，总之别人工具库都给你准备好了那就直接用工具库里的Base64吧。</code></pre><p>然后用得到的签名跟服务器生成的签名作比对，或者直接调用API验证，验证成功，至此前期工作已经准备好。</p><h2 id="一、引入密钥库"><a href="#一、引入密钥库" class="headerlink" title="一、引入密钥库"></a>一、引入密钥库</h2><p>打开PostMan的 <code>Pre-request script</code> 界面，编写脚本，在脚本初始化阶段引入密钥库。</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(!pm.globals.has(<span class="hljs-string">&quot;cryptojs&quot;</span>))&#123; pm.sendRequest(<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> &#123; <span class="hljs-keyword">if</span> (!err) &#123; pm.globals.set(<span class="hljs-string">&quot;cryptojs&quot;</span>, res.text()) &#125;&#125;)&#125;<span class="hljs-built_in">eval</span>(pm.globals.get(<span class="hljs-string">&quot;cryptojs&quot;</span>));</code></pre><h2 id="二、构造鉴权数据"><a href="#二、构造鉴权数据" class="headerlink" title="二、构造鉴权数据"></a>二、构造鉴权数据</h2><p>先确定构造数据所需的关键元素，参考对接文档，用注释把步骤大致整理出来</p><pre><code class="hljs javascript"><span class="hljs-comment">// plaintext = httpmethod + RequestURI + http body</span><span class="hljs-comment">// key=AppSecret + Nonce + timestamp</span><span class="hljs-comment">// token=BASE64(HMAC_SHA256(plaintext, key))</span></code></pre><p>然后对着注释把代码补全</p><blockquote><p>有条件的都建议使用新版客户端，不建议用chrome插件。客户端会在编写脚本的时候有智能代码提醒，很方便。</p></blockquote><pre><code>1. 获取请求头使用 pm.request.headers2. 获取body使用 pm.request.url.getPath(true)，加true是指不按&#39;/&#39;切割路径</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// let plaintext = httpmethod+RequestURI+http body</span><span class="hljs-keyword">let</span> plaintext = <span class="hljs-string">&#x27;POST&#x27;</span>+pm.request.url.getPath(<span class="hljs-literal">true</span>)+pm.request.body.raw;<span class="hljs-comment">// key=AppSecret(主题服务器分配)+Nonce+timestamp</span><span class="hljs-keyword">let</span> appSecret = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<span class="hljs-keyword">let</span> key = appSecret+pm.request.headers.get(<span class="hljs-string">&quot;nonce&quot;</span>)+pm.request.headers.get(<span class="hljs-string">&quot;timestamp&quot;</span>);<span class="hljs-comment">// token=BASE64(HMAC_SHA256(plaintext, key))</span><span class="hljs-keyword">let</span> sign = CryptoJS.HmacSHA256(plaintext,key);<span class="hljs-keyword">let</span> signenc = CryptoJS.enc.Base64.stringify(sign);pm.collectionVariables.set(<span class="hljs-string">&quot;usertoken&quot;</span>, signenc);</code></pre><p>最后把构造好的<code>token</code>设置到环境变量中：<code>pm.collectionVariables.set(&quot;usertoken&quot;, signenc);</code></p><h2 id="三、引用鉴权参数"><a href="#三、引用鉴权参数" class="headerlink" title="三、引用鉴权参数"></a>三、引用鉴权参数</h2><p>在请求用例的Header中，就可以用PostMan的匹配字符来引用上一步放置到环境变量中的数据了。<br>![[Pasted image 20220128154749.png]]</p><p>之后就可以点击请求按钮验证结果了，此时无论我怎样的修改请求体，修改timestamp，都可以自行动态生成token了，舒畅~。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工具版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PostMan: 8.0.7&lt;/li&gt;
&lt;li&gt;Crypto-js: 3.1.9&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="效率人生" scheme="http://xr08255920.github.io/categories/%E6%95%88%E7%8E%87%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="PostMan" scheme="http://xr08255920.github.io/tags/PostMan/"/>
    
    <category term="测试" scheme="http://xr08255920.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数字证书与安全协议</title>
    <link href="http://xr08255920.github.io/2022/01/22/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
    <id>http://xr08255920.github.io/2022/01/22/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-01-22T17:07:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="什么是是数字证书"><a href="#什么是是数字证书" class="headerlink" title="什么是是数字证书"></a>什么是是数字证书</h3><h4 id="数字身份"><a href="#数字身份" class="headerlink" title="数字身份"></a>数字身份</h4><p>数字身份的本质是一对秘钥，分别为公钥和私钥。</p><p>把数字身份比喻成一个证件，那么数字证书就是“身份认证机构”盖在证件上的一个章（即权威机构的背书）。没有背书的数字身份是没实际意义的。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="生活中"><a href="#生活中" class="headerlink" title="生活中"></a>生活中</h4><p>一切进行数据通信的地方都有可能会用到数字证书，如</p><ul><li>电子邮件</li><li>浏览网页</li><li>手机APP</li><li>科学上网</li></ul><h4 id="开发中"><a href="#开发中" class="headerlink" title="开发中"></a>开发中</h4><ul><li>工具抓包：fiddler</li></ul><h3 id="为什么要有数字证书"><a href="#为什么要有数字证书" class="headerlink" title="为什么要有数字证书"></a>为什么要有数字证书</h3><h4 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h4><p>下面展示了网络安全通信是如何逐步衍生出数字证书的。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B1.gif"></p><p>第一阶段，双方协商好对称密钥，之后的通信都使用对称密钥对明文进行加密解密操作。但是这个阶段的缺点是双方需要提前约定好密钥，该模式无法满足临时与陌生对象通信的需求。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B2.gif"><br>第二阶段，双方使用非对称秘钥通信，其中bob有一对公私钥，通信初始他会把公钥提供给alice，alice使用该公钥来加密明文。由于密文只有bob的私钥能解密，所以在通信过程中其他人是无法解开密文的（未被篡改的情况下）。<br>该阶段的主要问题在于非对称加密明文的性能相较对称加密性能要差很多。</p><p><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B3.gif"><br>第三阶段，alice使用了临时生成的<strong>对称密钥</strong>来加密明文，然后再用bob的公钥加密<strong>对称密钥</strong>，然后把<strong>被加密的明文</strong>和<strong>被加密的密钥</strong>发送给bob，由于<strong>被加密的密钥</strong>只能用bob的私钥解密，所以过程是安全的（未被篡改的情况下），同时<strong>对称密钥</strong>加密明文保证了性能。但这个过程真的没缺陷了吗？我们看看以下场景：<br><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B3-%E7%BC%BA%E9%99%B7.gif"><br>该过程中，中间人可以拦截bob发给alice的公钥，同时发送自己的公钥给alice，伪装成bob。之后的通信过程中，alice使用伪装的公钥加密出的密文，自然能被中间人破解。更有甚者中间人可以伪造一份欺骗性的报文发给bob。该过程省略了alice用自己私钥加签的过程，本质上一样是不安全的，中间人既然能伪造bob给alice的公钥，当然也能伪造alice给bob的公钥，那么这个过程中的签名自然也是可以伪造的。<br><img src="/images/%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B4.gif"><br>上一阶段的核心问题在于bob的公钥在传输过程中被篡改了，对于alice来说bob的公钥是不可信的。那么解决了公钥的信任问题，这个过程就安全了。</p><p>第四阶段：这一阶段bob把自己的公钥封装到数字证书里。在之后的通信初始阶段bob会先把数字证书发给alice，alice去CA机构验证数字证书的合法性，若验证通过，则代表bob的数字证书是可信的，那么证书里面的公钥自然也是可信的。这样就顺利的解决了公钥的信任问题。</p><h3 id="为什么数字证书的认证过程是可信的"><a href="#为什么数字证书的认证过程是可信的" class="headerlink" title="为什么数字证书的认证过程是可信的"></a>为什么数字证书的认证过程是可信的</h3><p><img src="/images/%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E5%8F%AF%E4%BF%A1.gif"><br>在服务域名上线之前，会先用自己的公钥生成一份证书签名请求文件（certificate sign request，csr），可以理解为填了份带有公钥的申请表单，发给CA机构，然后CA机构会把这份表单里面的关键信息（包括公钥、服务域名、所属机构等）提取成摘要，用自己的私钥进行加签。然后把签名和关键信息，输出到正式的数据结构中，形成了数字证书，再把这个数字证书发送给服务方，这个过程就叫做证书的签发。</p><p>服务器得到了具有公证力的证书，上线新的域名。随后客户端就可以访问该域名对服务器发起握手，握手阶段服务器会把证书发给客户端，客户端在证书里找到它的签发机构，遂去获取签发机构的证书。此时我们注意服务器证书的签名是用CA机构的私钥加签的，理所当然可以用CA机构的公钥进行验签。如果验签成功，则说明了服务器的证书是可信的。</p><p>可是此时出现了新的问题，我们通过这个流程可以验证服务器证书的有效性，前提是CA机构的证书也是合法的，但如何保证CA证书不会被篡改呢？</p><p>同理我们的客户端可以走相同的流程，去获取CA机构的上级机构的证书，来验证CA证书的有效性，这样就形成了一个递归验证链。这个递归链是有边界的，它的边界就是<strong>根证书。</strong></p><p><img src="/images/Pasted%20image%2020220123125102.png"></p><p>由上图的信任链我们可以看出验证操作会一直递归到根证书。这里的关键就在于根证书是内置于我们操作系统本地的，那么在获取根证书的时候就不想要经过网络。若不经过网络，则就不存在被中间人攻击的风险。所以，到根证书为止，就可以证明整个信任链是可信的了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>加密技术的存在是为了保障通信信息不被第三方窃取，保证信息的安全性，该技术甚至可以追溯到3900年前的古希腊。但是随着互联网尤其是无线网络的发展，出现了一种新的场景，就是通信双方节点，通常都是需要临时交换密钥来进行安全通信。伴随着这种场景，新的攻击手段也应运而生，那就是中间人攻击，简单来说就是中间人可以伪装成你的通信对象，交换非法秘钥，以达到监听窃取、篡改信息的目的。</p><p>而<strong>数字证书</strong>就是为了解决<strong>信任危机</strong>而的产生。<br>目前大部分数字证书都采用 x509第三版数据结构<br>数字证书是实现<strong>安全协议</strong>过程的基石。</p><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p>为什么要有中间证书？<br>1.根证书的私钥安全性隔离<br>A.降低替换私钥成本<br>B.降低暴露私钥风险<br>2.根证书的操作效率无法满足要求</p><p>浏览器如何获取中间证书？<br>一般来说，服务器会将中间证书一并发送过来。也就是说，当我们访问某个网站时，收到的不是一个证书，而是一系列证书。<br>当然，这不是强制要求，在服务器不发送的情况下，浏览器也会使用一些方法去定位中间证书，比如缓存之前下载过的证书<br>证书文件中的 Authority Information Access (AIA) Extension 里面含有上级证书的相关信息，浏览器可以使用这个信息去下载上级证书</p><h3 id="PKI-Public-Key-Infrastructure-体系"><a href="#PKI-Public-Key-Infrastructure-体系" class="headerlink" title="PKI(Public Key Infrastructure)体系"></a>PKI(Public Key Infrastructure)体系</h3><p>当我们掌握了证书的理论性知识后。需要有一套完整的创建, 管理, 分发, 使用, 存储 和 吊销 证书的体系，这就是PKI体系。该体系里完整的囊括了所需的指导性工具，包括规则、策略、相关软硬件、和流程。该体系并不由某一家制定，而是互联网组织共同参与，其中做出过贡献的组织包括但不限于 ITU-T（X.500~X.599系列）、IETF、RSA实验室（RSA Security，PKCS系列）、ISO。综上所述，PKI可以认为是一系列的规范和标准。而为了实现安全基础服务目的的技术都可称为PKI。## 安全协议</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><h4 id="TLS属于哪层协议？"><a href="#TLS属于哪层协议？" class="headerlink" title="TLS属于哪层协议？"></a>TLS属于哪层协议？</h4><p>TLS所处的协议层如下：<br>数据帧{ IP层{ TCP层{ <strong>TLS层{</strong> 应用层{} <strong>}</strong> } } }</p><p>可见TLS介于传输层（TCP）和应用层之间。</p><p>如果把网络协议想象成一个纸团，协议之间的嵌套就像一张纸包住另一个纸团一样。最里面的一层就是应用层协议，如HTTP。而网络报文的传输过程中，任何人能够截获这个纸团，并层层剥开，但是如果没有相应的秘钥，是没法剥开TLS这一层的，也就没法看到里面的HTTP报文。<br><img src="/images/Pasted%20image%2020220123093321.png"></p><h4 id="SSL和TLS的关系"><a href="#SSL和TLS的关系" class="headerlink" title="SSL和TLS的关系"></a>SSL和TLS的关系</h4><p>SSL是网景制定的，TLS是IETF指定的。TLS1.0建立在SSL3.0基础之上，可以理解为SSL3.1。由于习惯原因，现在很多对安全层依旧沿用SSL的称呼，但实际上已经使用的是TLS的技术了。</p><p>网景是一家传说级的公司，Mozilla（火狐前身）和JavaScript都诞生于这家公司。<br>而IETF是一个开放的标准组织，网络上随处可见的RFC标准就是出自他们。</p><p><img src="/images/Pasted%20image%2020220123093824.png"></p><h4 id="TLS-的运作过程"><a href="#TLS-的运作过程" class="headerlink" title="TLS 的运作过程"></a>TLS 的运作过程</h4><p><img src="/images/Pasted%20image%2020220123121739.png"></p><h4 id="TLS的关键阶段"><a href="#TLS的关键阶段" class="headerlink" title="TLS的关键阶段"></a>TLS的关键阶段</h4><p>握手阶段是TLS的关键<br>握手过程，主要就是双方交换公共参数，生成对称密钥，用于加密通信<br>秘钥交换算法（key exchange）：</p><ul><li>RSA based key exchange</li><li>DH(Diffie-Hellman) based key exchange</li></ul><h4 id="交换秘钥过程"><a href="#交换秘钥过程" class="headerlink" title="交换秘钥过程"></a>交换秘钥过程</h4><p>HTTPS常用的密钥交换算法有两种，分别是<code>RSA</code>和<code>ECDHE</code><br>由于RSA不具备向前安全性质，现在大部分服务器不会使用它来交换秘钥<br>每个通信过程的秘钥没有关系，相互独立，才能保证 <strong>「前向安全」</strong>。<br><code>DH</code>作为<code>ECDHE</code>的基础，详细介绍参考[DH]一节<br><code>ECDHE</code>的演进路线基本是这样的：<code>DH</code>-&gt; <code>DHE</code>-&gt;<code>ECDHE</code>，</p><h4 id="向前安全性"><a href="#向前安全性" class="headerlink" title="向前安全性"></a>向前安全性</h4><p><strong>前向安全性</strong>或<strong>前向</strong>保密<strong>性</strong>（英语：Forward Secrecy，缩写：FS），有时也被称为完美<strong>前向安全</strong>（英语：Perfect Forward Secrecy，缩写：PFS），<strong>是</strong>密码学中通讯协议的<strong>安全</strong>属性，指的<strong>是</strong>长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p><h3 id="两种密钥交换模式"><a href="#两种密钥交换模式" class="headerlink" title="两种密钥交换模式"></a>两种密钥交换模式</h3><h4 id="RSA-Base"><a href="#RSA-Base" class="headerlink" title="RSA Base"></a>RSA Base</h4><p>流程<br>从浏览器请求HTTPS，到渲染数据的整个过程</p><ul><li>Client Hello</li><li>随机数、算法套件</li><li>Server Hello</li><li>随机数、选定算法、公钥</li><li>Certificate</li><li>验证身份的项目：</li><li>涉及证书链的有效期</li><li>涉及证书链的签名</li></ul><p> 举例子，证书验证不通过的情况<br> <img src="/images/Pasted%20image%2020220123121951.png"></p><ul><li>Server Hello Done</li><li>Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message</li><li>服务端 Change Cipher Spec, Encrypted Handshake Message</li><li>加密通信</li></ul><p>premaster key、masterKey的作用<br><img src="/images/Pasted%20image%2020220123122022.png"></p><h4 id="DH-Base"><a href="#DH-Base" class="headerlink" title="DH Base"></a>DH Base</h4><h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>DH算法的原理可以参考这一篇文章：<a href="https://bbs.huaweicloud.com/blogs/detail/273779">为了搞懂 HTTPS，我把大学的数学书拿了出来。。。)</a></p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>要注意dh算法本身并不能防范中间人攻击，中间人可以通过分别对双方进行DH密钥交换进行攻击，所以DH实际需要配合身份认证机制才能安全工作。DH两种工作方式：</p><ol><li>Fixed Diffie-Hellman：直接把DH公钥固化到服务方证书里，和RSA一样不具备向前安全性</li><li>Ephemeral Diffie-Hellman (简称为DHE)：服务方使用动态DH公钥，只是会对公钥进行签名</li></ol><p>在DH模式中，数字证书，不是用于生成通信用的秘钥，而是单纯用于双方认证身份（这个是大部分人很容易理解错的地方）</p><h4 id="演进过程-1"><a href="#演进过程-1" class="headerlink" title="演进过程"></a>演进过程</h4><p>以下过程基于网络交换秘钥场景</p><table><thead><tr><th>技术</th><th>性能</th><th>防监听（未篡改）</th><th>防篡改</th><th>向前安全</th></tr></thead><tbody><tr><td>对称加密{原文}</td><td>√</td><td>x</td><td>x</td><td>x</td></tr><tr><td>非对称加密{原文}</td><td>x</td><td>√</td><td>x</td><td>x</td></tr><tr><td>非对称{密钥}</td><td>√</td><td>√</td><td>x</td><td>x</td></tr><tr><td>非对称{密钥}+公钥认证</td><td>√</td><td>√</td><td>√</td><td>x</td></tr><tr><td>临时DH公钥+公钥认证</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="TLS1-3介绍"><a href="#TLS1-3介绍" class="headerlink" title="TLS1.3介绍"></a>TLS1.3介绍</h3><p>TLS 1.3 是时隔九年对 TLS 1.2 等之前版本的新升级，也是迄今为止改动最大的一次。针对目前已知的安全威胁，IETF（Internet Engineering Task Force，互联网工程任务组） 正在制定 TLS 1.3 的新标准，使其有望成为有史以来最安全，但也最复杂的 TLS 协议。<br>![[Pasted image 20220112144654.png]]</p><p>v1.3 优点：<br>1.握手只需要 1TTR，性能更好<br>2.只支持向前安全的算法，安全性更高</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>相关配置</p><ul><li>internet属性<br>如何查看一个网站使用的TLS版本：f12-&gt;security<br><img src="/images/Pasted%20image%2020220123122235.png"></li></ul><h4 id="证书主要生命周期"><a href="#证书主要生命周期" class="headerlink" title="证书主要生命周期"></a>证书主要生命周期</h4><p>常见的证书管理工具有两种，一个是jdk自带的keytool；一个是开源项目openssl<br>以下命令均可以加上 –help 查看帮助，示例：<code>keytool –genkeypair -help</code></p><table><thead><tr><th>阶段</th><th>Keytool相关命令</th><th>Openssl相关命令</th></tr></thead><tbody><tr><td>生成密钥对</td><td>-genkeypair</td><td>genrsa</td></tr><tr><td>生成证书请求</td><td>-certreq</td><td>req</td></tr><tr><td>签发证书</td><td>-gencert</td><td>X509</td></tr><tr><td>管理密钥库</td><td>-list, -importkeystore</td><td>pkcs12 -nodes -nocerts</td></tr><tr><td>使用证书</td><td></td><td></td></tr><tr><td>吊销</td><td></td><td></td></tr></tbody></table><h5 id="keytool实践"><a href="#keytool实践" class="headerlink" title="keytool实践"></a>keytool实践</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成根证书，存储到密钥库caroot.ks</span>keytool -genkeypair -alias caroot -keyalg RSA -keystore caroot.ks -storepass aaaaaa<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 根据提示，把密钥库转换成pkcs12</span>keytool -importkeystore -srckeystore caroot.ks -destkeystore caroot.p12 -deststoretype pkcs12<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 这里我们可以把keytool命令做个别名，方便调用（可选）</span>alias mykt=&#x27;keytool -keystore $ksfile -storepass $kspass $*&#x27;export ksfile=caroot.p12 &amp;&amp; export kspass=aaaaaa<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 生成服务证书，存储到密钥库server.p12</span>keytool -genkeypair -alias server -keyalg rsa -keysize 1024 -keystore server.p12 -storepass aaaaaa -storetype pkcs12<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 生成服务证书签名申请</span>keytool -certreq -alias server -file server.csr -storepass aaaaaa -keystore server.p12<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 使用ca根证书签发服务证书</span>keytool -gencert -infile server.csr -outfile server.crt -alias caroot -keystore caroot.p12 -storepass aaaaaa -ext san=dns:www.mycompany.com,dns:mycompany.com<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 此时我们发现ca签发的证书不可信，导出根证书并安装到本地即可解决</span>keytool -exportcert -alias caroot -file caroot.crt -keystore caroot.p12 -storepass aaaaaa</code></pre><h4 id="验证der编码和base64编码的区别"><a href="#验证der编码和base64编码的区别" class="headerlink" title="验证der编码和base64编码的区别"></a>验证der编码和base64编码的区别</h4><p>der编码           base64编码<br>直接导出证书  导出证书 -rfc<br>windows下可以点击证书复制到文件<br>相互转换：notepad++转base64</p><p>要在nginx中开启TLS，需要先生成两个文件，一个是代表公钥的服务证书文件（.pem），一个是私钥的文件（.key）。此处公钥可以直接用windows的证书工具导出，私钥需要用openssl导出。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 从密钥库中导出服务器私钥</span>openssl pkcs12 -in server.p12 -out server.key -nodes -nocerts</code></pre><pre><div class="caption"><span>config</span></div><code class="hljs nginx"><span class="hljs-section">server</span> &#123;   <span class="hljs-comment">#监听端口和域名  </span> <span class="hljs-attribute">listen</span>      <span class="hljs-number">443</span> ssl;   <span class="hljs-attribute">server_name</span>  localhost;   <span class="hljs-comment">#以下两个为证书文件  </span> <span class="hljs-attribute">ssl_certificate</span> D:/java/nginx-<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>/cert/server-p.pem;   <span class="hljs-attribute">ssl_certificate_key</span> D:/java/nginx-<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>/cert/server.key;   <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">1m</span>;   <span class="hljs-attribute">ssl_protocols</span> SSLv2 SSLv3 TLSv1.<span class="hljs-number">2</span>;   <span class="hljs-attribute">ssl_ciphers</span>    ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256:AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;   <span class="hljs-attribute">ssl_prefer_server_ciphers</span>  <span class="hljs-literal">on</span>;   <span class="hljs-comment">#location / &#123;  </span> <span class="hljs-comment">#root D:/nginx/portal;  </span> <span class="hljs-comment">#index index.html;  </span> <span class="hljs-comment">#&#125;</span> <span class="hljs-attribute">localtion</span> / &#123; <span class="hljs-attribute">proxy_pass</span> http://localhost:8899;<span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For $remote_addr; &#125;   &#125;  <span class="hljs-comment"># 访问80端口时转发到443端口，转为https访问  </span> <span class="hljs-section">server</span> &#123;   <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;   <span class="hljs-attribute">server_name</span>  localhost;   <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://$host$request_uri;   &#125;</code></pre><h5 id="ERR-CERT-COMMON-NAME-INVALID错误"><a href="#ERR-CERT-COMMON-NAME-INVALID错误" class="headerlink" title="ERR_CERT_COMMON_NAME_INVALID错误"></a>ERR_CERT_COMMON_NAME_INVALID错误</h5><p>域名和Common Name 一致，chrome依然报错，该问题如何解决？<br>原因在于浏览器校验域名并不是从CN入手，而是检查x509的扩展字段SAN（subject alter name），所以只有加上该扩展字段，才能让浏览器认为网站是安全的。</p><p>针对keytool来说，有两个阶段可以加上该扩展字段：</p><ol><li>生成密钥对时</li><li>签发证书时</li></ol><p>扩展字段的指定方法参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html">keytool文档</a></p><p>如果是重新生成的证书未生效，需要清下浏览器缓存<br>chrome://net-internals/#hsts</p><p>若还是不行，看看是不是Nginx进程没清干净。</p><h4 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h4><ul><li>什么时候会进行数字证书认证</li><li>keytool -gencert -sigalg 有什么用</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="如何理解证书链"><a href="#如何理解证书链" class="headerlink" title="如何理解证书链"></a>如何理解证书链</h4><h4 id="RSA-vs-DSA"><a href="#RSA-vs-DSA" class="headerlink" title="RSA vs DSA"></a>RSA vs DSA</h4><p>这两个算法都是对称密钥算法，其中</p><ul><li>名称问题<br>RSA三位发明者的名字的缩写<br>DSA则是 Digital Signature Algorithm 的缩写</li><li>数学基础</li><li>RSA基于大数分解（两个素数的乘积）</li><li>DSA基于离散对数难题<h4 id="指纹和签名的区别"><a href="#指纹和签名的区别" class="headerlink" title="指纹和签名的区别"></a>指纹和签名的区别</h4>指纹只是证书上的散列。主要用于人工接收，检查证书是否为预定证书，比如 打电话给 CA认证机构 并说出指纹进行核对。 浏览器是通过签名来验证证书的有效性的，浏览器不会关注指纹。<h4 id="数字证书的数据结构"><a href="#数字证书的数据结构" class="headerlink" title="数字证书的数据结构"></a>数字证书的数据结构</h4>CN(Common Name名字与姓氏)<br>OU(Organization Unit组织单位名称)<br>O(Organization组织名称)<br>L(Locality城市或区域名称)<br>ST(State州或省份名称)<br>C(Country国家名称）</li></ul><p><img src="/images/Pasted%20image%2020220123125851.png"><br>详细参考： <a href="https://www.cem.me/20150209-cert-binaries-4.html">https://www.cem.me/20150209-cert-binaries-4.html</a></p><ul><li>头（4byte）<ul><li>body(4byte + len)</li><li>signalg(2byte + len(13))</li><li>sign(5byte+ len)</li></ul></li></ul><p>以sha256签名为例<br>计算公式：len(body) = 总大小 - 4 - (2+13) - (5 + 256)</p><p>body = cert[4:-276]</p><h4 id="truststore和keystore的区别"><a href="#truststore和keystore的区别" class="headerlink" title="truststore和keystore的区别"></a>truststore和keystore的区别</h4><p>keystore用于存放自己的证书和对应私钥，通常里面的证书作为TLS端的身份。<br>truststore用于存放自己这端信任的带签名的证书。</p><p>JKS、PKCS12都既可以做keystore也可以做truststore</p><h4 id="CRL——证书吊销列表"><a href="#CRL——证书吊销列表" class="headerlink" title="CRL——证书吊销列表"></a>CRL——证书吊销列表</h4><p>证书超出有效期后会作废，用户也可以主动向 CA 申请撤销某证书文件，由于 CA 无法强制收回已经颁发出去的数字证书，因此为了实现证书的作废，往往还需要维护一个撤销证书列表（Certificate Revocation List，CRL），用于记录已经撤销的证书序号。</p><p> 因此，通常情况下，当第三方对某个证书进行验证时，需要首先检查该证书是否在撤销列表中。如果存在，则该证书无法通过验证。如果不在，则继续进行后续的证书验证过程。</p><p>值得注意的是： 目前有些 CA 颁发的证书和大部分自签SSL证书都没有提供吊销列表 (CRL) 服务或证书 吊销列表分发点是不可访问的 ，固然更别提 OSCP 服务，这是很是危险的，由于若是证书丢失或被盗而没法吊销的话，就极有可能被用于非法用途而让用户蒙受损失。</p><h4 id="秘钥、与ssh打通"><a href="#秘钥、与ssh打通" class="headerlink" title="秘钥、与ssh打通"></a>秘钥、与ssh打通</h4><h4 id="域名及CName-AAA、AAAA"><a href="#域名及CName-AAA、AAAA" class="headerlink" title="域名及CName AAA、AAAA"></a>域名及CName AAA、AAAA</h4><h4 id="PGP和GPG加签模式的区别"><a href="#PGP和GPG加签模式的区别" class="headerlink" title="PGP和GPG加签模式的区别"></a>PGP和GPG加签模式的区别</h4><h4 id="openssl验签流程"><a href="#openssl验签流程" class="headerlink" title="openssl验签流程"></a>openssl验签流程</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 转换 DER 到 PEM 格式</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -inform der -<span class="hljs-keyword">in</span> root.cer -out root.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看证书的签名，可以看到签名所使用的的 <span class="hljs-built_in">hash</span> 算法是 sha256</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> root.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取签名内容到文件中</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> root.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame | grep -v <span class="hljs-string">&#x27;Signature Algorithm&#x27;</span> | tr -d <span class="hljs-string">&#x27;[:space:]:&#x27;</span> | xxd -r -p &gt; root-signature.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取根证书中含有的公钥</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> root.pem -noout -pubkey &gt; root-pub.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 使用公钥解密签名</span><span class="hljs-meta">$</span><span class="bash"> openssl rsautl -verify -inkey root-pub.pem -<span class="hljs-keyword">in</span> root-signature.bin -pubin &gt; root-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看解密后的内容</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -inform DER -<span class="hljs-keyword">in</span> root-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 接下来我们计算证书的 <span class="hljs-built_in">hash</span> 值</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 首先提取证书的 body</span><span class="hljs-meta">#</span><span class="bash"> 因为证书中含有签名，签名是不包含在 <span class="hljs-built_in">hash</span> 值计算中的</span><span class="hljs-meta">#</span><span class="bash"> 所以不能简单地对整个证书文件进行 <span class="hljs-built_in">hash</span> 运算</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -<span class="hljs-keyword">in</span> root.pem -strparse 4 -out root-body.bin &amp;&gt; /dev/null</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 计算 sha1 哈希值</span><span class="hljs-meta">$</span><span class="bash"> openssl dgst -sha256 root-body.bin</span><span class="hljs-meta">#</span><span class="bash">SHA1(root-body.bin)= xxx</span><span class="hljs-meta"></span><span class="hljs-meta"></span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> linux 下验证网站证书完整流程</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 新建一个文件夹 github 保存所有的文件</span><span class="hljs-meta">$</span><span class="bash"> mkdir github &amp;&amp; <span class="hljs-built_in">cd</span> github</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 首先，我们下载 github.com 发送的证书</span><span class="hljs-meta">$</span><span class="bash"> openssl s_client -connect github.com:443 -showcerts 2&gt;/dev/null &lt;/dev/null | sed -n <span class="hljs-string">&#x27;/-----BEGIN/,/-----END/p&#x27;</span> &gt; github.com.crt</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> github.com.crt 是 PEM 格式的文本文件</span><span class="hljs-meta">#</span><span class="bash"> 打开可以发现里面有两段 -----BEGIN CERTIFICATE----</span><span class="hljs-meta">#</span><span class="bash"> 这说明有两个证书，也就是 github.com 把中间证书也一并发过来了</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 接下来我们把两个证书提取出来</span><span class="hljs-meta">$</span><span class="bash"> awk <span class="hljs-string">&#x27;/BEGIN/,/END/&#123; if(/BEGIN/)&#123;a++&#125;; out=&quot;cert&quot;a&quot;.tmpcrt&quot;; print &gt;out&#125;&#x27;</span> &lt; github.com.crt &amp;&amp; <span class="hljs-keyword">for</span> cert <span class="hljs-keyword">in</span> *.tmpcrt; <span class="hljs-keyword">do</span> newname=$(openssl x509 -noout -subject -<span class="hljs-keyword">in</span> <span class="hljs-variable">$cert</span> | sed -n <span class="hljs-string">&#x27;s/^.*CN=\(.*\)$/\1/; s/[ ,.*]/_/g; s/__/_/g; s/^_//g;p&#x27;</span>).pem; mv <span class="hljs-variable">$cert</span> <span class="hljs-variable">$newname</span>; <span class="hljs-keyword">done</span></span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 我们得到了两个证书文件</span><span class="hljs-meta">#</span><span class="bash"> github_com.pem 和 DigiCert_SHA2_High_Assurance_Server_CA.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 首先，验证 github_com.pem 证书确实</span><span class="hljs-meta">#</span><span class="bash"> 是由 DigiCert_SHA2_High_Assurance_Server_CA.pem 签发的</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取 DigiCert_SHA2_High_Assurance_Server_CA 的公钥</span><span class="hljs-meta">#</span><span class="bash"> 命名为 issuer-pub.pem</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> DigiCert_SHA2_High_Assurance_Server_CA.pem -noout -pubkey &gt; issuer-pub.pem</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看 github_com.pem 的签名</span><span class="hljs-meta">#</span><span class="bash"> 可以看到 <span class="hljs-built_in">hash</span> 算法是 sha256</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> github_com.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取签名到文件中</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> github_com.pem -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame | grep -v <span class="hljs-string">&#x27;Signature Algorithm&#x27;</span> | tr -d <span class="hljs-string">&#x27;[:space:]:&#x27;</span> | xxd -r -p &gt; github_com-signature.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 使用上级证书的公钥解密签名</span><span class="hljs-meta">$</span><span class="bash"> openssl rsautl -verify -inkey issuer-pub.pem -<span class="hljs-keyword">in</span> github_com-signature.bin -pubin &gt; github_com-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 查看解密后的信息</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -inform DER -<span class="hljs-keyword">in</span> github_com-signature-decrypted.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 接下来计算 github_com.pem 的 <span class="hljs-built_in">hash</span> 值</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 提取证书的 body 部分</span><span class="hljs-meta">$</span><span class="bash"> openssl asn1parse -<span class="hljs-keyword">in</span> github_com.pem -strparse 4 -out github_com-body.bin &amp;&gt; /dev/null</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 计算 <span class="hljs-built_in">hash</span> 值</span><span class="hljs-meta">$</span><span class="bash"> openssl dgst -sha256 github_com-body.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">hash</span> 值匹配，我们成功校验了 github.pem 这个证书确实是由 DigiCert_SHA2_High_Assurance_Server_CA.pem 这个证书来签发的。</span>上面的流程比较繁琐，其实也可以直接让 openssl 来帮我们验证。<span class="hljs-meta">$</span><span class="bash"> openssl dgst -sha256 -verify issuer-pub.pem -signature github_com-signature.bin  github_com-body.bin</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 获取上级证书的名字</span><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> DigiCert_SHA2_High_Assurance_Server_CA.pem -text -noout | grep Issuer:</span>        Issuer: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert High Assurance EV Root CA</code></pre><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><blockquote><p>[序号]主要责任者.电子文献题名[电子文献及载体类型标识].电子文献的出版或获得地址,发表更新日期/引用日期.</p></blockquote><blockquote><p>例如：[12]王明亮.关于中国学术期刊标准化数据库系统工程的进展[EB/OL].1998-08-16/1998-10-01.</p></blockquote><blockquote><p>[8]万锦.中国大学学报文摘(1983-1993).英文版[DB/CD].北京:<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6%E5%87%BA%E7%89%88%E7%A4%BE/2267934">中国大百科全书出版社</a>,1996.</p></blockquote><ul><li><p>[1]梁栋.java加密与解密的艺术（第二版）</p></li><li><p>[2]2018-2019年中国网络可信身份服务发展蓝皮书</p></li><li><p>[3]贾铁军.网络安全技术与应用（第三版）</p></li><li><p>[4]王绍斌.云计算安全事件：从入门到精通</p></li><li><p>[5]韩立刚.深入浅出计算机网络</p></li><li><p>[6]汪德嘉.身份危机</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD">数字身份 - 维基百科，自由的百科全书 (wikipedia.org)</a></p></li><li><p><a href="http://kapsterio.github.io/test/2021/09/17/TLS.html">TLS协议分析（密码学101以及TLS协议简介） · kaspterio (kapsterio.github.io)</a></p></li><li><p><a href="https://houbb.github.io/2018/09/26/SSL-TLS">SSL/TSL | Echo Blog (houbb.github.io)</a></p></li><li><p><a href="https://www.linuxidc.com/Linux/2015-07/120230.htm">Https SSL/TLS PreMaster/Master Secret(Key)计算_服务器应用_Linux公社-Linux系统门户网站 (linuxidc.com)</a></p></li><li><p><a href="https://dev.to/wayofthepie/structure-of-an-SSL-x-509-certificate-16b">dev.to</a></p></li><li><p><a href="https://bbs.huaweicloud.com/blogs/detail/273779">为了搞懂 HTTPS，我把大学的数学书拿了出来。。。-云社区-华为云 (huaweicloud.com)</a></p></li><li><p><a href="https://www.cnblogs.com/bonelee/p/12931388.html">DSA与RSA——DSA 只能用于数字签名，而无法用于加密（某些扩展可以支持加密）；RSA 即可作为数字签名，也可以作为加密算法。在业界支持方面，RSA 具有更为广泛的部署与支持。 - bonelee - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://www.cnblogs.com/leslies2/p/7442956.html">数字证书应用综合揭秘（包括证书生成、加密、解密、签名、验签） - 风尘浪子 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://juejin.cn/post/6930446060846481416">https://juejin.cn/post/6930446060846481416</a></p></li><li><p><a href="https://stackoverflow.com/questions/37041254/ssl-certificate-signature-algorithm-shows-sha256rsa-but-thumbprint-algorithm">security - SSL Certificate: Signature Algorithm shows “sha256rsa” but thumbprint algorithm shows “sha1” - Stack Overflow</a></p></li><li><p><a href="https://cjting.me/2021/03/02/how-to-validate-tls-certificate/">https://cjting.me/2021/03/02/how-to-validate-tls-certificate/</a></p></li><li><p><a href="https://www.ibm.com/docs/en/zosconnect/3.0?topic=ee-keystores-truststores">Keystores and truststores - IBM Documentation</a></p></li><li><p><a href="https://support.huaweicloud.com/scm_faq/scm_01_0128.html">如何将证书格式转换为PEM格式？_SSL证书管理 SCM_常见问题_其他_证书管理类_华为云 (huaweicloud.com)</a></p></li><li><p><a href="https://stackoverflow.com/questions/43665243/invalid-self-signed-ssl-cert-subject-alternative-name-missing">https://stackoverflow.com/questions/43665243/invalid-self-signed-ssl-cert-subject-alternative-name-missing</a></p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html</a></p></li><li><p><a href="https://www.rfc-editor.org/rfc/rfc5246">RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 (rfc-editor.org)</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数字证书&quot;&gt;&lt;a href=&quot;#数字证书&quot; class=&quot;headerlink&quot; title=&quot;数字证书&quot;&gt;&lt;/a&gt;数字证书&lt;/h2&gt;&lt;h3 id=&quot;什么是是数字证书&quot;&gt;&lt;a href=&quot;#什么是是数字证书&quot; class=&quot;headerlink&quot; title=&quot;什</summary>
      
    
    
    
    <category term="密码学" scheme="http://xr08255920.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="数字证书" scheme="http://xr08255920.github.io/tags/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    
    <category term="密码学" scheme="http://xr08255920.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ZeroTier 梳理</title>
    <link href="http://xr08255920.github.io/2022/01/04/ZeroTier%E6%A2%B3%E7%90%86/"/>
    <id>http://xr08255920.github.io/2022/01/04/ZeroTier%E6%A2%B3%E7%90%86/</id>
    <published>2022-01-04T02:54:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p>是一款 p2p vpn</p><p>p2p 的原理是什么</p><ol><li>中继（原始方案）：两个客户端主动连接公网服务器，由服务器中继通信</li><li>逆向链接（改良版）：要求其中一个客户端（假设是B）是公网ip，且有公网服务器做中继，B先通过服务器向A中继一个连接请求，然后A主动跟B建立连接。</li><li>UDP打洞（当前最优）：两个客户端都在NAT之后，有一台公网服务器，客户端A向B发送请求，同时要求服务器中继一个“B到A的连接请求”给B，此时两边都会导致NAT打开一个自身内网到对方外网的通信，之后双方内网就可以相互通信了。该模式适用于锥形NAT。如果有多级NAT，则要求NAT得支持回环传输(loopback transmission)。<br><a href="https://zhuanlan.zhihu.com/p/26796476">https://zhuanlan.zhihu.com/p/26796476</a><br><a href="https://evilpan.com/2015/10/31/p2p-over-middle-box/">https://evilpan.com/2015/10/31/p2p-over-middle-box/</a><br>vpn 是什么<br>vpn全称visual private network，最早是公司开发给员工远程连接内网用的，此处体现了第一个用处就是代理网络请求，其次它目的是防止公司信息泄漏给第三方，所以vpn被设计成能够加密通信。所以它具备以下特点：1、提高上网安全性；2、隐藏上网者身份；3、突破网站的地域限制</li></ol><p>NAT是什么<br>NAT即网络地址转换器，NAT不止检查进入数据包的头部,而且对其进行修改,从而实现同一内网中不同主机共用更少的公网IP（通常是一个）.</p><p>隧道是什么</p><p>STUN是什么</p><p>STUN和TUN的区别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;是一款 p2p vpn&lt;/p&gt;
&lt;p&gt;p2p 的原理是什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中继（原始方案）：两个客户端主动连接公网服务器，由服务器中继通信&lt;/li&gt;
&lt;li&gt;逆向链接（改良版）：要求其中一个客户端（假设是B）是公网ip，且有公网服务器做中继，B先通过服务器向A中</summary>
      
    
    
    
    
    <category term="vpn" scheme="http://xr08255920.github.io/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>mysql，GROUP_CONCAT，341长度疑案</title>
    <link href="http://xr08255920.github.io/2021/12/15/mysql%EF%BC%8CGROUP_CONCAT%EF%BC%8C341%E9%95%BF%E5%BA%A6%E7%96%91%E6%A1%88/"/>
    <id>http://xr08255920.github.io/2021/12/15/mysql%EF%BC%8CGROUP_CONCAT%EF%BC%8C341%E9%95%BF%E5%BA%A6%E7%96%91%E6%A1%88/</id>
    <published>2021-12-15T23:33:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天被同事找来讨论一个数据库问题，一个select语句带有聚合函数<code>GROUP_CONCAT(countryCode)</code>，countryCode是纯数字，所以这一列出来的结果应该是这样的：<code>24,25,1003,1004,1025,......</code>，但是实际上结果被截断了，把结果copy出来到notepad++，发现每一条记录的长度都是<code>341</code>。</p><p>经过一番查询，发现mysql对这个函数有个配置：<code>group_concat_max_len</code>，指的是对<code>GROUP_CONCAT()</code>函数的结果进行截断。比如<code>group_concat_max_len=1024</code>，那么mysql会对该函数的结果截取前1024个字节(Byte)。看起来就是它了。</p><p>通过以下命令，可以查看该库对应的配置：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;group_concat_max_len&#x27;</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1024</span></code></pre><p>可见我们的库也是1024，那为啥实际结果长度只有<code>341</code>呢。据回答的小哥说：当<code>GROUP_CONCAT()</code> 和 <code>Order By</code>一起使用的时候，结果就会进一步裁剪到1/3，如果去掉<code>Order By</code>条件，结果长度会是<code>1024</code>。但是这个规律是实践出来的，具体为啥会这样，官方手册里并没有说。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了验证思路，可参考以下sql进行配置</p><pre><code class="hljs sql"># SESSION 表示变动只影响当前会话<span class="hljs-keyword">SET</span> SESSION group_concat_max_len<span class="hljs-operator">=</span><span class="hljs-number">102400</span>;</code></pre><p>配置后验证结果长度确实不会被截断了。</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>由于我们只在某一个环境中才复现了这个问题，别的环境都没问题，所以思路就是参考别的环境的配置，经查询发现其他环境的值都是<code>group_concat_max_len=8192</code>，所以其他环境没有这个问题，遂对齐配置即可。</p><pre><code class="hljs sql"># <span class="hljs-keyword">GLOBAL</span> 表示变动影响全局<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> group_concat_max_len<span class="hljs-operator">=</span>your_value_here;</code></pre><p>如果严谨一点，应该需要排查项目里所有用到<code>GROUP_CONCAT()</code>的地方，然后结合业务评估一下合理的大小，再找DBA协商进行变更。所幸我们生产环境配的是<code>102400</code>，足够大了，也就没这种顾虑了。</p><hr><p>参考:</p><ul><li><a href="https://stackoverflow.com/questions/12001919/mysql-truncates-concatenated-result-of-a-group-concat-function">https://stackoverflow.com/questions/12001919/mysql-truncates-concatenated-result-of-a-group-concat-function</a></li><li><a href="https://stackoverflow.com/questions/4469474/mysql-truncating-of-result-when-using-group-concat-and-concat/37979180#37979180">https://stackoverflow.com/questions/4469474/mysql-truncating-of-result-when-using-group-concat-and-concat/37979180#37979180</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;今天被同事找来讨论一个数据库问题，一个select语句带有聚合函数&lt;code&gt;GROUP_CONCAT(countryCode)&lt;/code</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://xr08255920.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>阅读文章自动生成大纲浏览器插件</title>
    <link href="http://xr08255920.github.io/2021/12/12/%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A4%A7%E7%BA%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://xr08255920.github.io/2021/12/12/%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A4%A7%E7%BA%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2021-12-12T11:06:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间读文章发现没有大纲，阅读不顺畅，针对那些没有大纲的页面，手撸了一个自动生成大纲的浏览器脚本。基本上实现了大部分想要的功能，在此记录分享。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>可以导入油猴里，打开脚本开关即可生效。</li><li>使用浏览器的dev-tools来跑。</li></ol><p><i class="fa fa-file-code-o" aria-hidden="true"></i><a href="/data/outlineTool.user.js">文章大纲生成插件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有段时间读文章发现没有大纲，阅读不顺畅，针对那些没有大纲的页面，手撸了一个自动生成大纲的浏览器脚本。基本上实现了大部分想要的功能，在此记录分享。&lt;/p&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://xr08255920.github.io/tags/javascript/"/>
    
    <category term="效率工具" scheme="http://xr08255920.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="原创" scheme="http://xr08255920.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>js模块化简述</title>
    <link href="http://xr08255920.github.io/2021/12/09/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E8%BF%B0/"/>
    <id>http://xr08255920.github.io/2021/12/09/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E8%BF%B0/</id>
    <published>2021-12-09T02:05:00.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p>本文是阅读《mastering-modular-javascript》的心得笔记，该书成书于2018年，对当前JS技术的描述有较新的时效性。同时其模块化思想比较实用，可以应用到任何语言</p><h2 id="历史简述"><a href="#历史简述" class="headerlink" title="历史简述"></a>历史简述</h2><h3 id="scriptTag和闭包"><a href="#scriptTag和闭包" class="headerlink" title="scriptTag和闭包"></a>scriptTag和闭包</h3><p>原生js提供使用<code>&lt;script&gt;</code>tag的方式引入，这样一个页面会看到一大坨的第三方库以<code>&lt;script&gt;</code>的方式引入。但是这种引入天生是有缺陷的，引入的函数和变量都会挂载到window下成为全局对象。这样导致一个长期存在的毛病就是各个包之间定义的变量会相互覆盖，稍有差池就会让页面渲染失败。</p><p>之后官方推出了IIFE的特性（也就是闭包），各个库的代码以闭包的方式包裹，这样它们各自定义的变量的作用域都是在闭包范围之内的，也就解决了全部暴露到全局的问题。</p><p>但是这种方式弊病在于它不会显式的声明依赖的库，这样就需要手动精细调整各个<code>&lt;script&gt;</code>的顺序，以达到被依赖的库优先被引入的问题，</p><p>闭包的几种写法：</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE using parenthesis&#x27;</span>)&#125;)()~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE using a bitwise operator&#x27;</span>)&#125;()<span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;IIFE using the void operator&#x27;</span>)&#125;()</code></pre><blockquote><p>&lt;mastering-modular-javascript&gt; chapter1</p></blockquote><h3 id="RequireJs，AngularJs，和依赖注入"><a href="#RequireJs，AngularJs，和依赖注入" class="headerlink" title="RequireJs，AngularJs，和依赖注入"></a>RequireJs，AngularJs，和依赖注入</h3><p>上节描述的问题一直都是让前端开发人员头疼的问题，直到模块化框架RequireJs以及AngularJS中依赖注入机制的降临。</p><h4 id="RequireJs"><a href="#RequireJs" class="headerlink" title="RequireJs"></a>RequireJs</h4><p>通过如下方式暴露接口，define()是RequireJs框架暴露到全局的函数<br>第一个参数的数组元素声明了该模块的路径，第二个参数意思是通过把函数传入回调接口，返回该路径对应的接口</p><pre><code class="hljs javascript">define([<span class="hljs-string">&#x27;mathlib/sum&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sum</span>) </span>&#123;  <span class="hljs-keyword">return</span> &#123; sum &#125;&#125;)</code></pre><p>通过如下方式调用依赖项，require()跟define()一样，<br>第一个参数声明了需要引入的依赖路径，可以引入多个依赖<br>这些依赖会按顺序放到第二个回调函数的参数中，提供使用。</p><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;mathlib&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mathlib</span>) </span>&#123;  mathlib.sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment">// &lt;- 6</span>&#125;)</code></pre><p>requireJS也有它的问题，首先整个模式围绕着它的异步请求能力，这导致了每个引用点都要发起网络请求获取对应的模块，这会导致一个页面发起瀑布式的上百个加载模块的网络请求，这无疑是性能很差的一件事。为此，需要引入一个构建工具，把所有模块整合成一个脚本，包含冗长的依赖链、require函数、和回调参数</p><h4 id="AngularJS"><a href="#AngularJS" class="headerlink" title="AngularJS"></a>AngularJS</h4><p>AngularJS中的依赖注入系统也遇到了许多相同的问题。它通过解析参数名来解决依赖问题。但是这导致了进行代码混淆时，参数名被改变而依赖失败的问题。在AngularJS v1后期，引入了一个构建任务来解决这个问题，它会进行如下的代码转换：</p><pre><code class="hljs javascript"><span class="hljs-comment">//转换前</span><span class="hljs-built_in">module</span>.factory(<span class="hljs-string">&#x27;calculator&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mathlib【&lt;-通过该参数名来引入依赖】</span>) </span>&#123;  <span class="hljs-comment">// …</span>&#125;)</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//转换后</span><span class="hljs-built_in">module</span>.factory(<span class="hljs-string">&#x27;calculator&#x27;</span>, [<span class="hljs-string">&#x27;mathlib&#x27;</span>【&lt;-显式的指明了依赖的模块名称，像RequireJs一样】, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mathlib</span>) </span>&#123;  <span class="hljs-comment">// …</span>&#125;])</code></pre><blockquote><p>不用说，引入这个鲜为人知的构建工具的延迟，加上过度设计的方面，有一个额外的构建步骤来解开不应该被破坏的东西，我无论如何都不鼓励使用一种能带来如此微不足道的好处的模式。开发人员大多选择坚持使用熟悉的类似RequireJS的硬编码依赖数组格式。——&lt;mastering-modular-javascript&gt;</p></blockquote><h3 id="Node-js和CommonJS的降临和Browserify"><a href="#Node-js和CommonJS的降临和Browserify" class="headerlink" title="Node.js和CommonJS的降临和Browserify"></a>Node.js和CommonJS的降临和Browserify</h3><p>在Node.js被称赞的众多创新中，一个是CommonJS模块系统——简称CJS。利用Node.js程序可以访问文件系统的能力，CommonJS标准更符合传统的模块加载机制。在CommonJS中，每个文件都是一个具有自己作用域和上下文的模块。依赖关系是使用同步<code>require</code>函数加载的，该函数可以在模块生命周期中的任何时候动态调用，如下一个代码段所示。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mathlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./mathlib&#x27;</span>)</code></pre><p>可见，与RequireJs、AngularJS一样，都是使用路径来指定模块，而不同之处在于曾经的样板函数、依赖数组已经不复存在。像前两者，它们可以在一个文件里定义多个模块的接口，但是CJS相对比较严格，它约定一个模块就是一个文件，通过<code>module.exports</code>就能暴露该模块的接口。其实这样的好处也显而易见，这样可以让开发者更加清晰的了解CJS模块的层次结构，也便于IDE去解析。</p><p>由于CJS是提供给NodeJs用的，浏览器引擎并没有能力去引入依赖，这个时候就要靠<code>Browserify</code>，来把所有的依赖打包到供浏览器使用的捆绑包中。</p><h3 id="ES6-import-Babel-and-Webpack"><a href="#ES6-import-Babel-and-Webpack" class="headerlink" title="ES6, import, Babel, and Webpack"></a>ES6, <code>import</code>, Babel, and Webpack</h3><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>ECMA标准组织一直都在持续的采纳和计划新的语法标准。很多时候一些很实用的语法已经提上议程，但是待各大浏览器对标准进行实现，开发者还是得苦苦的等待一段漫长的事间。Babel的出现就是为了解决这个问题，它是一个语法转换工具，能够把ES6语法的代码，转换成当前浏览器都能兼容的ES5语法，解决了很多开发想要尝试新的语法特性的燃眉之急</p><p>随着ES6在2015年6月标准化，以及Babel在那之前很久就一直有将ES6转换为ES5，一场新的革命正在迅速临近。ES6规范包括JavaScript原生的模块语法，通常被称为ECMAScript模块（ESM）。</p><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><p>ESM在很大程度上受到CJS及其前身的影响，提供了静态声明性API以及基于承诺的动态可编程API，如下所示。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> mathlib <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mathlib&#x27;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./mathlib&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">mathlib</span> =&gt;</span> &#123;  <span class="hljs-comment">// …</span>&#125;)</code></pre><p>同CJS一样，ESM约定一个文件就是一个模块。而优秀于CJS的地方是ESM能引用静态依赖，静态依赖意味着可以无需运行代码就能被工具检测出相关的依赖，我猜应该是能够便于编辑工具进行依赖解析吧，对书本原文说的“内省”不是很理解。（参考：<a href="https://stackoverflow.com/questions/52965907/what-is-the-meaning-of-static-import-in-es6">javascript - what is the meaning of static import in ES6? - Stack Overflow</a>）。</p><blockquote><p>Static imports vastly improve the introspection capabilities of module systems, given they can be analyzed statically and lexically extracted from the abstract syntax tree (AST) of each module in the system.    ——&lt;mastering-modular-javascript&gt;</p></blockquote><p>另外ESM比CJS更强的一个地方在于它可以指定加载模块的异步完成事件（<code>.then()</code>）。这让模块加载的动作变得更加灵活和更多可能性。</p><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>Webpack是browserify的接班人。</p><hr><p>综上所述，由于ESM纯正血统以及优异表现，毫无疑问ESM将在未来的几年内，将会接管整个JS模块化生态。</p><p>参考文献：<a href="https://github.com/mjavascript/mastering-modular-javascript">GitHub - mjavascript/mastering-modular-javascript: 📦 Module thinking, principles, design patterns and best practices.</a></p><h2 id="模块化原则"><a href="#模块化原则" class="headerlink" title="模块化原则"></a>模块化原则</h2><h3 id="模块化精要"><a href="#模块化精要" class="headerlink" title="模块化精要"></a>模块化精要</h3><ol><li>单一职责原则</li><li>API优先原则</li><li>不暴露非必要的方法或变量（public 要有度，能private的尽量private）<ol><li>从使用者角度去考虑暴露的粒度</li></ol></li><li>找到合适的抽象（最好就是在第二次出现重复的时候进行重构）</li><li>状态管理<ol><li>模块化设计的一个目标就是让状态最小化，不要让功能内部存在太多可能性</li><li>把状态树砍成更好管理的状态树分支，每个分支都是状态树的一个子集</li><li>纯粹的函数不应该对其它地方有影响，下面是例子 <pre><code class="hljs javascript"><span class="hljs-comment">// 纯粹函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">numbers</span>) </span>&#123;<span class="hljs-keyword">return</span> numbers.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>)&#125;<span class="hljs-comment">// 非纯粹函数，每次调用的结果可能被其他调用影响</span><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><span class="hljs-keyword">const</span> increment = <span class="hljs-function">() =&gt;</span> count++<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> increment</code></pre></li><li>可以通过工厂来封装可能暴露给外部的状态，来减少状态的熵值 <pre><code class="hljs javascript"><span class="hljs-keyword">const</span> factory = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> increment = <span class="hljs-function">() =&gt;</span> count++  <span class="hljs-keyword">return</span> increment&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> factory</code></pre></li></ol></li></ol><h3 id="CRUST-Consistent-Resilient-Unambiguous-Simple-and-Tiny"><a href="#CRUST-Consistent-Resilient-Unambiguous-Simple-and-Tiny" class="headerlink" title="CRUST: Consistent, Resilient, Unambiguous, Simple and Tiny"></a>CRUST: Consistent, Resilient, Unambiguous, Simple and Tiny</h3><ol><li>Consistent：一个接口只要输入一样，无论执行多少次，输出都应该一样</li><li>Resilient：接口应能够灵活的指定参数，包括可选参数和重载</li><li>Unambiguous：接口应该是明确的，不存在多种用法、多套不同业务意义的入参、多套不同解释的返回值</li><li>Simple：接口应该保持简单，它可以以少配置甚至无配置，执行常规的用例，同时也能允许用户通过传递自定义配置执行更高级的用例</li><li>Tiny：它应该是精简的，保持高扩展性</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是阅读《mastering-modular-javascript》的心得笔记，该书成书于2018年，对当前JS技术的描述有较新的时效性。同时其模块化思想比较实用，可以应用到任何语言&lt;/p&gt;
&lt;h2 id=&quot;历史简述&quot;&gt;&lt;a href=&quot;#历史简述&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="js系列" scheme="http://xr08255920.github.io/categories/js%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="javascript" scheme="http://xr08255920.github.io/tags/javascript/"/>
    
    <category term="modular" scheme="http://xr08255920.github.io/tags/modular/"/>
    
    <category term="模块化" scheme="http://xr08255920.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>DDD——驱动领域设计</title>
    <link href="http://xr08255920.github.io/2021/11/26/DDD%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://xr08255920.github.io/2021/11/26/DDD%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="如何应对复杂软件开发？以unix为例"><a href="#如何应对复杂软件开发？以unix为例" class="headerlink" title="如何应对复杂软件开发？以unix为例"></a>如何应对复杂软件开发？以unix为例</h3><ol><li>封装与抽象</li><li>分层与模块化</li><li>基于接口通信</li><li>为扩展而设计</li></ol><blockquote><p>linux运作漫画图）理论太干，辅以图片说明，同时让听众思考buffer</p></blockquote><h3 id="DDD介绍"><a href="#DDD介绍" class="headerlink" title="DDD介绍"></a>DDD介绍</h3><ul><li>历史</li><li>简介<ul><li>   一种思维模式</li><li>   本质是方法论</li><li>   by experience</li></ul></li></ul><h4 id="由数据模型驱动设计-引入"><a href="#由数据模型驱动设计-引入" class="headerlink" title="由数据模型驱动设计 引入"></a>由数据模型驱动设计 引入</h4><p>一门语言的基本语法和编程技巧、一个ORM框架的使用方法及基本的sql编写能力——就这三板斧，足以！</p><p>这种设计方式的弊端：mvc模式</p><ul><li>缺乏边界</li><li>贫血模型，transactional scripts</li><li>由贫血症导致的失忆症（即业务代码意图不明</li><li>跟数据库表定义强耦合</li><li>缺乏对领域模型的思考和建模</li></ul><h3 id="正式引入DDD"><a href="#正式引入DDD" class="headerlink" title="正式引入DDD"></a>正式引入DDD</h3><h4 id="怎么玩？"><a href="#怎么玩？" class="headerlink" title="怎么玩？"></a>怎么玩？</h4><ol><li>团队+领域专家讨论，统一语言</li><li>战略设计：划分界限上下文</li><li>战术设计：界限上下文落地</li><li>根据实际情况迭代、重构界限上下文，往复循环</li></ol><h4 id="对比数据模型驱动模式"><a href="#对比数据模型驱动模式" class="headerlink" title="对比数据模型驱动模式"></a>对比数据模型驱动模式</h4><p>虚拟钱包案例</p><p><strong>mvc模型</strong></p><ul><li>贫血模型，不够面向对象</li><li>业务类命名太泛，缺乏边界，职责模糊，后续很容易被腐化</li><li>数据库表模型散落到业务层，灵活性差</li></ul><p><strong>ddd建模</strong></p><ul><li>充血模型，更加面向对象</li><li>使用门面模式，屏蔽数据库操作细节</li><li>service层变逻辑变简单，领域逻辑交给领域层做，service层只负责编排</li></ul><h4 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h4><ul><li>ddd非银弹，不应滥用</li><li>设计系统时，多考虑墨菲定律</li><li>划分系统时，多考虑康威定律</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>数据驱动设计有诸多弊端</li><li>DDD天生为控制大型软件的复杂度而生</li></ul><h3 id="领域建模流程"><a href="#领域建模流程" class="headerlink" title="领域建模流程"></a>领域建模流程</h3><ol><li>事件风暴。一起头脑风暴，完善用例图</li><li>抽象。提炼出系统的主要行为</li><li>划分界限上下文。主要区分好核心域、支撑域、公共域</li><li>界限上下文映射。主要区分好各个上下文的上下游关系</li><li>翻译为代码。一个上下文一个module</li></ol><h3 id="DDD的基本概念"><a href="#DDD的基本概念" class="headerlink" title="DDD的基本概念"></a>DDD的基本概念</h3><ul><li>领域、子域</li><li>界限上下文、界限上下文映射</li><li>实体、值对象</li><li>聚合、聚合根</li><li>领域服务</li><li>领域事件</li><li>工厂</li><li>资源库</li></ul><h4 id="领域、子域"><a href="#领域、子域" class="headerlink" title="领域、子域"></a>领域、子域</h4><p>在领域部不断划分的过程中，领域会细分成不同的子域：核心域、通用域、支撑域</p><p>核心域如何区分？桃树例子。<strong>界限上下文关心的就是核心域</strong></p><h4 id="界限上下文"><a href="#界限上下文" class="headerlink" title="界限上下文"></a>界限上下文</h4><p>什么是界限上下文？<br>例子：我有 kuai di<br>①我有块地，<strong>祖上留下来的</strong><br>②我有快递，<strong>顺丰的</strong></p><p>帮助我们理解对话含义的语气和语境就是<strong>上下文</strong></p><p>例子：</p><ol><li>引用 Eric Evans 对界限上下文的解释（细胞-上下文，细胞膜-边界</li><li>我—&gt;业务流程：乘客 | 宾客 | 支付者 | 咨询师</li></ol><p>领域是问题域（即问题空间），界限上下文是问题的解决空间<br>界限上下文是直译术语，晦涩难懂，理解成本高。应该叫<strong>上下文边界</strong></p><h4 id="上下文映射（Context-Map）"><a href="#上下文映射（Context-Map）" class="headerlink" title="上下文映射（Context Map）"></a>上下文映射（Context Map）</h4><p>应该译为<strong>上下文图</strong>，是描述各个<strong>上下文之间的关系</strong>的总体视图。分别是：</p><ul><li>合作关系</li><li>共享内核（如：多个服务共享jar包，或者公共基础服务</li><li>客户/供应商（如：服务间相互约定模型，由供应方维护</li><li>追随者（如：调用支付宝接口，无法约定，只能按照他们协议走</li><li>防腐层（如：上游系统模型太烂，下游可以用防腐层来将其转换成理想模型，<strong>目的是将上游系统的影响降到最低</strong></li><li>公开主机服务（如：对外发布公共服务及接口文档</li><li>发布语言</li><li>各行其道</li><li>大泥球（ 毫无设计可言</li></ul><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>有唯一标识（可理解为其id），实现了领域行为（充血模型），对象的延续性和标识会跨越甚至超出软件的生命周期。</p><p>一个典型的实体应具备三要素：</p><ul><li>身份标识</li><li>属性</li><li>领域行为</li></ul><h4 id="值对象（-值-对象）"><a href="#值对象（-值-对象）" class="headerlink" title="值对象（= 值 + 对象）"></a>值对象（= 值 + 对象）</h4><p>是否拥有<strong>唯一标识</strong>，是实体和值对象的<strong>根本区别</strong>。<br>值对象特征：</p><ul><li>不可变，只读，安全</li><li>将不同的相关属性组合成了一个概念整体</li><li>可以和其他值对象进行相等性比较</li><li>行为不会对属性产生副作用</li></ul><h4 id="实体和值对象的区别"><a href="#实体和值对象的区别" class="headerlink" title="实体和值对象的区别"></a>实体和值对象的区别</h4><p>在实践中，实体和值对象是一起使用的，值对象作为实体的附属属性。如：领域模型中的人员是实体    （有唯一身份标识），而地址对象被人员实体引用。</p><p>值对象可以在不同的场景中被不同的实体引用。如在电商系统中，地址对象作为收货地址；在员工系统中，地址对象作为家庭地址。</p><p>此外，在某些场景中，地址会占据领域的主导地位，如行政区划中的地址信息维护，这时应该设计为实体。</p><table><thead><tr><th>实体</th><th>值对象</th></tr></thead><tbody><tr><td>具有生命周期</td><td>起描述作用</td></tr><tr><td>有唯一标识</td><td>无</td></tr><tr><td>通过id判断相等性</td><td>实现equals方法</td></tr><tr><td>增删改查/持久化</td><td>即时创建用完就扔</td></tr><tr><td>可变</td><td>不可变</td></tr><tr><td>如 Order/Car</td><td>Address/Color</td></tr></tbody></table><h4 id="聚合、聚合根"><a href="#聚合、聚合根" class="headerlink" title="聚合、聚合根"></a>聚合、聚合根</h4><p>在DDD中，实体、值对象是基础的领域对象，表现出的是个体的能力。<br>而让实体、值对象协同工作的组织，就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性</p><p>聚合定义了一组具有<strong>内聚关系</strong>的相关对象的<strong>集合</strong>。可以把聚合看做是一个修改数据的单元。</p><p>如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么需要思考聚合内哪个对象有独立存在的意义，并且可以和外部直接进行交互，以其为聚合根</p><p>聚合根是与其他聚合交互的唯一接口。</p><p>聚合设计原则：</p><ul><li>设计小聚合，79%的聚合通常只有一个实体，即聚合根</li><li>聚合之间通过Id关联，而不是对象引用</li><li>一个事务只能创建或更新一个聚合。这是理想情况，遵循最终一致性。大多数情况我们需要的是事务一致性。</li></ul><p>可打破原则的理由：</p><ul><li>方便用户界面</li><li>缺乏技术支持</li><li>全局事务</li><li>查询性能</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;h3 id=&quot;如何应对复杂软件开发？以unix为例&quot;&gt;&lt;a href=&quot;#如何应对复杂软件开发？以unix为例&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Graphviz实践手册</title>
    <link href="http://xr08255920.github.io/2021/11/26/Graphviz%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/"/>
    <id>http://xr08255920.github.io/2021/11/26/Graphviz%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dot语言"><a href="#dot语言" class="headerlink" title="dot语言"></a>dot语言</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code class="hljs clojure">[ strict ] (<span class="hljs-name">graph</span> | digraph) [ ID ] &#123;rankdir =  //布局方向，只有一个生效 <span class="hljs-string">&quot;TB&quot;</span>, <span class="hljs-string">&quot;LR&quot;</span>, <span class="hljs-string">&quot;BT&quot;</span>, <span class="hljs-string">&quot;RL&quot;</span>// 设置公共属性(<span class="hljs-name">graph</span> | node | edge) [ID = ID, ID2 = ID2, ...]<span class="hljs-comment">;</span>...// 声明节点NODEID [ port ] [ID = ID, ID2 = ID2, ...]<span class="hljs-comment">;</span>...// 节点链(<span class="hljs-name">NODEID</span> [ port ] | subgraph) edgeop (<span class="hljs-name">node_id</span> | subgraph) [ID = ID, ID2 = ID2, ...]<span class="hljs-comment">;</span>...&#125;</code></pre><h2 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h2><p><code>dot -Tpng *.dot -o *.png</code></p><h2 id="画Label格子技巧"><a href="#画Label格子技巧" class="headerlink" title="画Label格子技巧"></a>画Label格子技巧</h2><ol><li>先整理1级分类，如A|B|C</li><li>整理某分类的二级分类，如B的二级分类：{B1|B2|B3}</li><li>把二级分类挂到一级分类下边，得：A|{B|{B1|B2|B3}|C</li><li>以此类推</li><li>得到的结果方label里，如<code>nodeName [label=&quot;A|&#123;B|&#123;B1|B2|B3&#125;|C&quot;]</code></li></ol><h2 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h2><p><img src="/images/Pasted%20image%2020201218173054.png"></p><h2 id="子图边框样式"><a href="#子图边框样式" class="headerlink" title="子图边框样式"></a>子图边框样式</h2><pre><code class="hljs abnf">subgraph&#123;style = dotted<span class="hljs-comment">;</span>&#125;</code></pre><p>可选样式：<br><img src="/images/Pasted%20image%2020201222153845.png"></p><h2 id="允许子图边界可以被指定"><a href="#允许子图边界可以被指定" class="headerlink" title="允许子图边界可以被指定"></a>允许子图边界可以被指定</h2><pre><code class="hljs actionscript">digraph &#123;<span class="hljs-comment">//设置该选项开启</span>compound=<span class="hljs-literal">true</span> &#125;</code></pre><p>指定子图边界：</p><pre><code class="hljs routeros">CacheUtil -&gt; Ehcache [<span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;findCache()&quot;</span>,ltail = cluster_CatcherManager]</code></pre><h2 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h2><p>指定 <code>edge [fontname=&quot;MicroSoft YaHei&quot;]</code></p><h2 id="subgraphs-和-clusters-的区别"><a href="#subgraphs-和-clusters-的区别" class="headerlink" title="subgraphs 和 clusters 的区别"></a>subgraphs 和 clusters 的区别</h2><p>subgraph有以下几个作用：</p><ul><li>负责抽象多个节点的公共属性</li><li>给组件分组（单纯是语义上的分组，不可见）</li></ul><p>cluster继承subgraph的特性，并额外提供可视化的边界，cluster的定义方法就是给子图的名字加前缀<code>cluster_</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dot语言&quot;&gt;&lt;a href=&quot;#dot语言&quot; class=&quot;headerlink&quot; title=&quot;dot语言&quot;&gt;&lt;/a&gt;dot语言&lt;/h1&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring data</title>
    <link href="http://xr08255920.github.io/2021/11/26/Spring%20data/"/>
    <id>http://xr08255920.github.io/2021/11/26/Spring%20data/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p>Spring repository（Spring data common） 负责定义应用和数据库服务之间的抽象API接口。<br>Spring repository 从对接的数据库类型上看有多种实现，关系型数据库、nosql、内存数据库、云数据库等等。</p><p>Spring repository 对关系型数据库的实现，最主流的有 Spring Data JPA，底层使用Hibernate 这种ORM框架，此外原生一点的实现有 Spring Data JDBC。</p><p>不同的实现，需要接入不同的数据源，不同的数据源由统一的公共API操作。各数据源需要单独配置，配置相应的连接参数，如使用jdbc-Mysql作为数据源，则要为DataSource配置相应的连接串、账号、密码等等。</p><p>小结<br>Spring repository  –&gt; Spring Data JPA/JDBC/MongoDB…. –&gt; mysql/oracle/h2/… </p><h2 id="Spring-JPA"><a href="#Spring-JPA" class="headerlink" title="Spring JPA"></a>Spring JPA</h2><h3 id="引入步骤"><a href="#引入步骤" class="headerlink" title="引入步骤"></a>引入步骤</h3><p>要使用Spring Data，有一下步骤</p><ol><li>pom 引入 spring-boot-starter-data-jpa<ol><li><blockquote><p>自动依赖 spring Data common</p></blockquote></li></ol></li><li>pom 引入DataSource需要的引擎，如Driven等</li><li>自行在 Configuration 中配置 DataSource</li><li>编写model的interface，继承对应的repository，如JPA实现则继承JPArepository。Spring Data 将会自动的扫描所有 Repository，并通过动态代理来实现它。</li><li>在Configuration 中设置 @EnableJpaRepositories 使Spring Data生效</li></ol><p>####设置</p><pre><code class="hljs java"><span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;com.baeldung.spring.data.persistence.repository&quot;)</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersistenceConfig</span> </span>&#123;     ...&#125;</code></pre><h3 id="自定义DB操作"><a href="#自定义DB操作" class="headerlink" title="自定义DB操作"></a>自定义DB操作</h3><p>Spring Data 默认已经对Repository 生成好基本的db操作了。但难免有时还是无法满足需求，此时需要自定义DB操作，有如下方式可选：</p><ol><li>命名规则自定义查询</li><li>手动sql自定义查询</li></ol><h4 id="命名规则自定义查询"><a href="#命名规则自定义查询" class="headerlink" title="命名规则自定义查询"></a>命名规则自定义查询</h4><p>在 Repository 接口中定义新方法，如果Entity中有name字段，不妨可以在Repository 接口中新增 findBy<strong>Name</strong>方法，这样Spring Data会自动生成对应的实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFooDAO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Foo</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;    <span class="hljs-function">Foo <span class="hljs-title">findByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre><p>更多自动化关键字可以查阅：<a href="https://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/#jpa.query-methods.query-creation">https://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/#jpa.query-methods.query-creation</a> </p><h4 id="手动sql自定义查询"><a href="#手动sql自定义查询" class="headerlink" title="手动sql自定义查询"></a>手动sql自定义查询</h4><p>示例</p><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;SELECT f FROM Foo f WHERE LOWER(f.name) = LOWER(:name)&quot;)</span><span class="hljs-function">Foo <span class="hljs-title">retrieveByName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</code></pre><h2 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a>未分类</h2><h3 id="Modifying"><a href="#Modifying" class="headerlink" title="@Modifying"></a>@Modifying</h3><p>可在@Query上使用@Modifying注释，此时@Query可以执行查询以外的sql，如增、删、改。</p><h3 id="Modifying-和-命名方法-操作的区别"><a href="#Modifying-和-命名方法-操作的区别" class="headerlink" title="@Modifying 和 命名方法 操作的区别"></a>@Modifying 和 命名方法 操作的区别</h3><p>后者会先把DB的数据全查出来，然后逐个做操作，这样可以通过AOP对每条数据设置前置操作。而前者会直接把操作语句扔到DB执行。</p><h3 id="Modifying-与持久化容器的过期数据"><a href="#Modifying-与持久化容器的过期数据" class="headerlink" title="@Modifying 与持久化容器的过期数据"></a>@Modifying 与持久化容器的过期数据</h3><p>通过 @Modifying 执行的操作，不会同步给持久化容器，此时持久化容器的数据处于过期状态。一个方法是通过手动清空持久化容器。但也可以通过以下方式让其自动清空。</p><pre><code class="hljs java"><span class="hljs-meta">@Modifying(clearAutomatically = true)</span></code></pre><p>但如果清空持久化容器，则会导致未flush的数据也被清除，导致未保存的更改被丢弃。可以通过以下属性来在清空前flush。</p><pre><code class="hljs java"><span class="hljs-meta">@Modifying(flushAutomatically = true)</span></code></pre><h3 id="Query"><a href="#Query" class="headerlink" title="@Query"></a>@Query</h3><p>@Query的优先度优先于按方法名查询。</p><p>@Query 优先使用JPQL语法，如果要使用原生SQL语法，需要指定native=ture。</p><pre><code class="hljs java"><span class="hljs-comment">//JPQL语法</span><span class="hljs-meta">@Query(&quot;SELECT u FROM User u WHERE u.status = 1&quot;)</span><span class="hljs-function">Collection&lt;User&gt; <span class="hljs-title">findAllActiveUsers</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//原生SQL</span><span class="hljs-meta">@Query(</span><span class="hljs-meta">  value = &quot;SELECT * FROM USERS u WHERE u.status = 1&quot;, </span><span class="hljs-meta">  nativeQuery = true)</span><span class="hljs-function">Collection&lt;User&gt; <span class="hljs-title">findAllActiveUsersNative</span><span class="hljs-params">()</span></span>;</code></pre><h3 id="连接持久层"><a href="#连接持久层" class="headerlink" title="连接持久层"></a>连接持久层</h3><p>至少需要：</p><ol><li>datasource，涉及和维护driver、username、password</li><li>SqlSessionFactory，用来连接服务器，创建sqlSession</li><li>mapper，定义相关的Query（在JPA中，一个方法就是一个mapper）</li></ol><p>图示：<br><img src="/images/Pasted%20image%2020201222154530.png"></p><h4 id="JPA需要准备环境"><a href="#JPA需要准备环境" class="headerlink" title="JPA需要准备环境"></a>JPA需要准备环境</h4><p>对于JPA，是一回事。</p><ol><li>DataSource</li><li>EntityManager —— 相当于SqlSessionFactory</li><li>Entity Repository —— 相当于Mapper</li></ol><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><p>需要注册Bean org.mybatis.spring.mapper.MapperScannerConfigurer 或者 注解 @MapperScanner，来生效mybatis。该bean负责整合上述的组件到DAO的代理类中，开发者就可以通过dao接口来操作db了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring repository（Spring data common） 负责定义应用和数据库服务之间的抽象API接口。&lt;br&gt;Spring repository 从对接的数据库类型上看有多种实现，关系型数据库、nosql、内存数据库、云数据库等等。&lt;/p&gt;
&lt;p&gt;Spr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>aop实践手册</title>
    <link href="http://xr08255920.github.io/2021/11/26/aop%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/"/>
    <id>http://xr08255920.github.io/2021/11/26/aop%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/</id>
    <published>2021-11-26T11:59:13.000Z</published>
    <updated>2022-05-15T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="aspect语法"><a href="#aspect语法" class="headerlink" title="aspect语法"></a>aspect语法</h3><h4 id="call和execution的区别"><a href="#call和execution的区别" class="headerlink" title="call和execution的区别"></a>call和execution的区别</h4><p>结合这篇<a href="https://stackoverflow.com/questions/28251596/difference-between-call-and-execution-pointcuts-in-php/28252742#28252742">java - Difference between call and execution pointcuts in PHP? - Stack Overflow</a>食用<br><img src="/images/Pasted%20image%2020210820103450.png"></p><p>重点：But wait a minute, it still makes a difference: <code>execution</code> is just woven in one place while <code>call</code> it woven into potentially many places, so the amount of code generated is smaller for <code>execution</code>.</p><p>搞清楚 @target、@withIn 的区别<br>参考<a href="https://blog.csdn.net/jinnianshilongnian/article/details/84156354?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">»Spring 之AOP AspectJ切入点语法详解（最全了，不需要再去其他地找了）_jinnianshilongnian的专栏-CSDN博客</a></p><h4 id="语法表"><a href="#语法表" class="headerlink" title="语法表"></a>语法表</h4><p>execution(annotation scope return package.Class.method( params ) )</p><ul><li>可省略：annotation、scope</li><li>任意 return、包、方法：*</li><li>任意参数：（..）</li><li>任意多个包：..</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;aspect语法&quot;&gt;&lt;a href=&quot;#aspect语法&quot; class=&quot;headerlink&quot; title=&quot;aspect语法&quot;&gt;&lt;/a&gt;aspect语法&lt;/h3&gt;&lt;h4 id=&quot;call和execution的区别&quot;&gt;&lt;a href=&quot;#call和executi</summary>
      
    
    
    
    
  </entry>
  
</feed>
